<?xml version="1.0" encoding="UTF-8"?>
<chapter><title>Active Object Migration</title>
<!--  File: /home/irosenbe/PA_new_doc/docbook-tuto/doc-files/Migration.html  -->
  
    <sect1 remap="h2">
      <title><anchor id="dbdoclet.id.Migration_html_prim"/>Migration Primitive</title>
      <para>The migration of an active object can be triggered by the active object
 itself, or by an external agent. In both cases a single primitive will eventually get called to
 perform the migration. It is the method <literal>
 migrateTo</literal> accessible from a migratable body (a body that inherits from <literal>AbstractMigratableBody</literal>).</para>
      <para>In order to ease the use of the migration, we provide 2 sets of static
 methods on the <literal>ProActive</literal> class. The first set is
 aimed at the migration triggered from the active object that wants to migrate. The methods rely
 on the fact that the calling thread <emphasis role="bold">is</emphasis> the active thread of the active object :</para>
      <itemizedlist>
        <listitem>
          <para><literal>migrateTo(Object o)</literal>  : migrate to the
 same location as an existing active object</para>
        </listitem>
        <listitem>
          <para><literal>migrateTo(String nodeURL)</literal>  : migrate
 to the location given by the URL of the node</para>
        </listitem>
        <listitem>
          <para><literal>migrateTo(Node
 node)</literal>  : migrate to the location of the given node</para>
        </listitem>
</itemizedlist>
      <para>The second set is aimed at the migration triggered from another agent than
 the target active object. In this case the external agent must have a reference to the Body of
 the active object it wants to migrate.</para>
      <itemizedlist>
        <listitem>
          <para><literal>migrateTo(Body
 body, Object o, boolean priority)</literal>  : migrate to the same location as an existing
 active object</para>
        </listitem>
        <listitem>
          <para><literal>migrateTo(Body
 body, String nodeURL, boolean priority)</literal>  : migrate to the location given by the URL
 of the node</para>
        </listitem>
        <listitem>
          <para><literal>
 migrateTo(Body body, Node node, boolean priority)</literal>  : migrate to the location of the
 given node</para>
        </listitem>
</itemizedlist>
    </sect1>
    <sect1 remap="h2">
      <title><anchor id="dbdoclet.id.Migration_html_use"/>Using migration</title>
      <para>Any active object has the ability to migrate. If it references some passive
 objects, they will also migrate to the new location. Since we rely on the serialization to send
 the object on the network, <emphasis role="bold">the active object must implement the serializable interface</emphasis>. To
 migrate, an active object must have a method which contains a call to the migration primitive.
 This call must be the last one in the method, i.e the method must return immediately after. Here
 is an example of a method in an active object :</para>
      <blockquote>
        <para>
          <screen>
   public void moveTo(String t) {
     try {
       ProActive.migrateTo(t);
     } catch (Exception e) {
       e.printStackTrace();
     }
   }
          </screen>
</para>
      </blockquote>
      <para>We don&#39;t provide any test to check if the call to migrateTo is the last
 one in the method, hence if this rule is not enforced, it can lead to unexpected behavior. Now to
 make this object move, you just have to call its <literal>moveTo()</literal> method.</para>
    </sect1>
    <sect1 remap="h2">
      <title><anchor id="dbdoclet.id.Migration_html_example"/>Complete example</title>
      <blockquote>
        <para>
          <screen>
  import org.objectweb.proactive.ProActive;
  public class SimpleAgent implements Serializable {
    public SimpleAgent() {
    }
    public void moveTo(String t) {
      try {
        ProActive.migrateTo(t);
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    public String whereAreYou() {
      try {
        return InetAddress.getLocalHost().getHostName();
      } catch (Exception e) {
        return &quot;Localhost lookup failed&quot;;
      }
    }
    public static void main (String[] args) {
      if (!(args.length&gt;0)) {
        System.out.println(&quot;Usage: java migration.test.TestSimple hostname/N\
odeName &quot;);
        System.exit(-1);
      }
      SimpleAgent t = null;
      try {
        // create the SimpleAgent in this JVM
        t = (SimpleAgent) ProActive.newActive(&quot;migration.test.SimpleAgent&quot;,nu\
ll);
      } catch (Exception e) {
        e.printStackTrace();
      }
      // migrate the SimpleAgent to the location identified by the given no\
de URL
      // we assume here that the node does already exist
      t.moveTo(args[0]);
      System.out.println(&quot;The Active Object is now on host &quot; + t.whereAreYou(\
));
    }
  }
          </screen>
</para>
      </blockquote>
      <para>The class SimpleAgent implements <literal>Serializable</literal> so the objects
 created will be able to migrate. We need to provide an empty constructor to avoid side effects
 during the creation of active objects. This object has two methods, <literal>moveTo()</literal> which
 makes it migrate to the specified location, and <literal>whereAreYou()</literal> which returns the
 hostname of the new location of the agent.</para>
      <para>In the main method, we first need to create an active object, which is done through the call
 to <literal>newActive()</literal>. Once this is done, we can call methods on it as on any object. We
 call its <literal>moveTo</literal> method which will make it migrate to the node specified as parameter
 and then we ask it what is its current location.</para>
    </sect1>
    <sect1 remap="h2">
      <title><anchor id="dbdoclet.id.Migration_html_non_seri"/>Dealing with non-serializable
 attributes</title>
      <para>The migration of an active object uses the serialization. Unfortunately,
 not all the objects in the Java language are serializable. We are going to see a simple method to
 deal with such attributes in the case their value does not need to be saved. For more complex
 cases, the reader can have a look to the Java RMI specifications.</para>
      <para>When a <literal>NotSerializable</literal> exception is thrown, the first step to
 solve the problem is to identify the variable responsible, i.e the one which is not
 serializable... In front of the declaration of this variable, put the keyword <literal>transient</literal>. This indicates that the value of this variable should not be serialized.
 After the first migration, this field will be set to null since it has not been saved. So we have
 to rebuild it upon arrival of the active object on its new location. This can easily be done by
 providing in the active object the standard method</para>
      <blockquote>
        <para>
          <screen>
    private void readObject(java.io.ObjectInputStream in) throws java.io.IO\
Exception, ClassNotFoundException;
          </screen>
</para>
      </blockquote>
      <para>See the <literal>Serializable</literal> interface in the standard JavaDoc to learn more.</para>
      <para></para>
      <para>
  </para>
    </sect1>
  
</chapter>
