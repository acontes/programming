<?xml version="1.0" encoding="UTF-8"?>
<chapter id="conformance"><title>Conformance to the Fractal model and extensions</title>
<!--  File: /home/irosenbe/PA_new_doc/docbook-tuto/components/conformance.html  -->
  
    <para> <anchor id="conformance_html_conformance_to_fractal"/></para>
    <sect1 remap="h2">
      <title><anchor id="conformance_html_Model"/>Model</title>
      <para>The conceptual model of Fractal is the base of our work, and as it is
 extensible, we have added a few concepts to fulfill our needs. The Fractal specification defines
 conformance levels for implementations of the API (section 7.1. of the Fractal 2 specification).
 The implementation for ProActive is conformant up to level 3.2. . In other words, it is fully
 compliant with the API, except it does not consider the creation of components through template
 components.</para>
      <para>The implementation for ProActive currently defines 2 extensions to the base
 component model:</para>
      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Distributed deployment</emphasis>: components can be deployed onto
 distributed virtual machines, using the deployment facilities of ProActive.</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">Parallel components</emphasis>: this type of components is a specialization
 of the composite components. They encapsulate other components of the same type, and all
 incoming calls are forwarded to the corresponding internal interfaces of the enclosed
 components. This allows parallel processing while just manipulating one entity, the enclosing
 parallel component. As we use the typed groups API of ProActive, coupled with the concept of
 internal collective interfaces of Fractal, the communications to the enclosed components are
 either <emphasis>scattered</emphasis> or <emphasis>broadcasted</emphasis>. The following figure sums up the
 different kinds of components available. </para>
        </listitem>
</itemizedlist>
      <para>
        <figure>
         <title>The different kinds of components with the ProActive implementation. </title>
         <caption>Primitive components have customizable activities (primitive components are also active objects)</caption>
          <mediaobject>
            <imageobject>
              <imagedata  fileref="components/pics/kinds-of-components.png" format="PNG"/>           
             </imageobject>
          </mediaobject>
         </figure>
</para>
    </sect1>
    <sect1 remap="h2">
      <title><anchor id="conformance_html_Implementation_specific_API"/>Implementation specific API</title>
      <sect2 remap="h3">
        <title>fractal.provider</title>
        <para>The API is the same for any Fractal implementation, though some classes are
 implementation-specific:</para>
        <para>The fractal provider class, that corresponds to the <literal>fractal.provider</literal> parameters of
         the JVM, is <literal>org.objectweb.proactive.core.component.Fractive</literal>. The
         <literal>Fractive</literal> class
 acts as:</para>
        <itemizedlist>
          <listitem>
            <para> a bootstrap component</para>
          </listitem>
          <listitem>
            <para> a GenericFactory for instantiating new components</para>
          </listitem>
          <listitem>
            <para> a utility class providing static methods to create collective interfaces
 and retreive references to ComponentParametersController</para>
          </listitem>
</itemizedlist>
      </sect2>
      <sect2 remap="h3">
        <title>Content and controller descriptions</title>
        <para>The controller description and the content description of the components,
 as specified in the method <literal>public Component newFcInstance(Type type, Object controllerDesc,
 Object contentDesc) throws InstantiationException</literal> of the
<literal>org.objectweb.fractal.api.factory.Factory</literal> class, correspond in this implementation
 to the classes <literal>org.objectweb.proactive.core.component.ControllerDescription</literal> and
 <literal>org.proactive.core.component.ContentDescription</literal>.</para>
      </sect2>
      <sect2 remap="h3">
        <title>Collective bindings</title>
        <para>In composite or parallel components, collective bindings are performed
 automatically. For primitive component, the developer has to implement the bindings explicitely
 in the code. We provide a method in the <literal>org.objectweb.proactive.core.component.Fractal</literal> class 
 for creating collective bindings:</para>
<screen>
public static ProActiveInterface createCollectiveClientInterface(String itf\
Name, String itfSignature) throws ProActiveRuntimeException
</screen>
        <para>where <literal>itfName</literal> is the name of the interface, and <literal>itfSignature</literal> 
         is the signature of the interface.</para>
        <para>Suppose you have an attribute of the base class of the primitive component
 of type I, named i. The initialization of the binding would be:</para>
<screen> i= (I) Fractal.createCollectiveClientInterface('i',I.class.getName()); </screen>
        <para>Then the binding method (implementation of the BindingController interface)
 would be:</para>
<screen>
public void bindFc(String clientItfName, Object serverItf) {
 if (clientItfName.equals('i')) {
 ProActiveGroup.getGroup(i).add(serverItf);
 }
} </screen>
        <para>You will be able to see the collective interface as an object of type I,
 and therefore invoke methods defined by I. But you will also be able to see the collective
 interface as a <ulink url="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Collection.xml">collection</ulink>, 
 as a group can also be manipulated as a collection:</para>
<screen> Collection c = ProActiveGroup.getGroup(i); </screen>
      </sect2>
      <sect2 remap="h3">
        <title>Requirements</title>
        <para>As this implementation is based on ProActive, several 
         <ulink url="../ActiveObjectCreation.xml">conditions</ulink> are required:</para>
        <itemizedlist>
          <listitem>
            <para> the base class for the implementation of a primitive component has to
 provide an empty, no-args constructor.</para>
          </listitem>
          <listitem>
            <para> parameters types and return types of the methods provided by the
 interfaces of the components have to be reifiable.</para>
          </listitem>
</itemizedlist>
      </sect2>
    </sect1>
  
    
    <sect1 remap="h2" id="componentArchitecture">
     <title>Architecture and design</title>
     <para>The implementation of the Fractal model is achieved by reusing the
      extensible architecture of ProActive, notably the meta-object protocol and the management of the
      queue of requests. This way, components stay fully compatible with standard active objects and as
      such, inherit from the features active objects exhibit: mobility, security, deployment etc.</para>
     <para>A fundamental idea is to manage the non-functional properties at the
      meta-level: <emphasis role="bold">each component is actually an active object</emphasis> with 
      dedicated meta-objects in charge of the component aspects.</para>
     <sect2 remap="h3">
      <title>Meta-object protocol</title>
      <para>ProActive is based on a meta-object protocol (MOP), that allows the
       addition of many aspects on top of standard Java objects, such as asynchronism and mobility.
       Active objects are referenced indirectly through stubs: this allows transparent communications,
       would the active objects be local or remote.</para>
      <para>The following diagram explains this mechanism:</para>
      <para>
       Java objects 'b' and 'a' can be in different virtual machines (the network being
       represented here between the proxy and the body, though the invocation might be local). Object
       'b' has a reference on active object 'a' (of type <literal>A</literal>) through a stub
       (of type <literal>A</literal> because it is generated as a subclass of <literal>A</literal>) and a proxy.
       When 'b' invokes a method on '<literal>stub_A</literal>', the invocation is forwarded
       through the communication layer (possibly through a network) to the body of the active object. At
       this point, the call can be intercepted by meta-objects, possibly resulting in induced actions,
       and then the call is forwarded to the base object 'a'.</para>
      <para>
       <figure>
        <title>ProActive's Meta-Objects Protocol.</title>
        <mediaobject>
         <imageobject>
          <imagedata  fileref="components/pics/standard-mop.png" format="PNG"/>     
         </imageobject>
        </mediaobject>
       </figure>
      </para>
      
      <para>The same idea is used to manage components: we just add a set of
       meta-objects in charge of the component aspects.</para>
      <para>The following diagram shows what is changed:</para>
      <para>
       A new set of meta-objects, managing the component aspect (constituting the controller of the
       component, in the Fractal terminology), is added to the active object 'a'. The standard
       ProActive stub (that gives a representation of type A on the figure) is not used here, as we
       manipulate components. In Fractal, a reference on a component is of type <literal>Component</literal>,
       and references to interfaces are of type <literal>Interface</literal>. 'b' can now manipulate
       the component based on 'a' through a specific stub, called a <emphasis>component
        representative</emphasis>. This <emphasis>component representative</emphasis> is of type
       <literal>Component</literal>, and
       also offers references to control and functional interfaces, of type <literal>Interface</literal>. Note
       that classes representing functional interfaces of components are generated on the fly: they are
       specific to each component and can be unknown at compile-time.</para>
      <para>
       Method invocations on Fractal interfaces are reified and transmitted (possibly through a network)
       to the body of the active object corresponding to the component involved. All standard operations
       of the Fractal API are now accessible.</para>
      <para>
       <figure>
        <title>The ProActive MOP with component meta-objects and component representative</title>
        <mediaobject>
         <imageobject>
            <imagedata  fileref="components/pics/components-mop.png" format="PNG"  width="6in"/>
         </imageobject>
        </mediaobject>
       </figure>
      </para>
      
     </sect2>
     <sect2 remap="h3">
      <title>Components vs active objects</title>
      <para>In our implementation, because we make use of the MOP's facilities, all
       components are constituted of one active object (at least), are they composite or primitive
       components. If the component is a composite, and if it contains other components, then we can say
       it is constituted of several active objects. Also, if the component is primitive, but the
       programmer of this component has put some code within it for creating new active objects, the
       component is again constituted of several active objects.</para>
      <para>As a result, a composite component is an active object built on top of the
       <literal>CompositeComponent</literal> class, and a parallel component is built on top of the
       <literal>ParallelComponent</literal> class. These classes are empty classes, because for composite and
       parallel components, all the action takes place in the meta-level. But they are used as a base to
       build active objects, and their names help to identify them with the IC2D visual monitoring
       tool.</para>
     </sect2>
     <sect2 remap="h3">
      <title>Method invocations on components interfaces</title>
      <para>Invoking a method on an active object means invoking a method on the stub
       of this active object. What usually happens then is that the method call is reified as a
       <literal>Request</literal> object and transferred (possibly through a network) to the body of the
       active object. It is then redirected towards the queue of requests, and delegated to the base
       object according to a customizable serving policy (standard is FIFO).</para>
      <para>Component requests, on the other hand, are tagged so as to distinguish
       between functional requests and controller requests. A functional request targets a functional
       interface of the component, while a controller request targets a controller of the component.</para>
      <para>Like in the standard case (without components), requests are served from
       the request queue. The serving policy has to be FIFO to ensure coherency. <emphasis role="bold">This is 
        where the life cycle of the components is controlled</emphasis>: the dispatching of the request is 
       dependent upon the nature of the request, and corresponds to the following algorithm:</para>
      <para>
       <screen>
        loop
        if componentLifeCycle.isStarted()
        get next request
        // all requests are served
        else if componentLifeCycle.isStopped()
        get next controller request
        // only controller requests are served
        ;
        if gotten request is a component life cycle request
        if request is start --&gt; set component state to started ;
        if request is stop --&gt; set component state to stopped ;
        ;
        ; </screen>
      </para>
     </sect2>
     <sect2 remap="h3">
      <title>Collective interfaces and typed group communications</title>
      <para>One may specify the cardinality of the interfaces of Fractal components
       (section 6.1). The <emphasis>collection</emphasis> cardinality means that a given component may have several
       interfaces of a given type ; the name of each of these interfaces has to begin with the same
       name.</para>
      <para>This feature is provided in our implementation through the 
       <ulink url="../TypedGroupCommunication.xml">Groups API</ulink>, and slightly differs from the
       Julia implementation: instead of creating one new interface with an extended name for each
       member of the collection, we just use one interface, which is a group. Collective bindings are
       then performed transparently as if they were successive bindings on the same interface. Using a
       collective server interface implies using the Groups API formalism, including the possibility to
       choose between scattering and broadcasting of the calls. Note that unbinding operations on a
       collective interface result in the removal of all the bindings of the collection. Examples are
       provided in the 'component programming with ProActive' section.</para>
      <para>Because we target largely distributed and parallel applications, we
       introduced a new kind of component: parallel components (see image 'parallel
       component'). These components are composite components, as they encapsulate other
       components. But they are specialized: their external server interfaces have a specific behavior.
       These external server interfaces are connected through the ProActive groups mechanism (i.e.
       through a group proxy) to the server interfaces of the same type of the internal components. The
       requests are then processed in a parallel manner.</para>
      <para>Next diagram illustrates where group communications are involved.</para>
      <para>
       <figure>
        <title>Group communications allowing collective bindings and parallel   components.</title>
        <mediaobject>
         <imageobject>
          <imagedata  
                     fileref="components/pics/collective-interfaces.png" format="PNG"/>      
         </imageobject>
        </mediaobject>
       </figure>
      </para>
      
     </sect2>
    </sect1>
  
    
</chapter>
