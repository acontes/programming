<?xml version="1.0" encoding="UTF-8"?>
<chapter id="componentExamples">
  <title>Examples</title>

  <para>3 examples are presented: code snippets for visualizing the transition
  between active objects and components, the 'hello world', from the Fractal
  tutorial, and C3D component version. The programming model is Fractal, and
  one should refer to the Fractal documentation for detailed examples.</para>

  <sect1 remap="h2">
    <title><anchor
    id="examples_html_From_objects_to_active_objects_to_distributed_components" />From
    objects to active objects to distributed components</title>

    <para>In Java, objects are created by instantiation of classes. With
    ProActive, one can create active objects from Java classes, while
    components are created from component definitions. Let us first consider
    the 'A' interface:</para>

    <screen language="java">public interface A {
  public String foo(); // dummy method
} </screen>

    <para>'AImpl' is the class implementing this interface:</para>

    <screen>public class AImpl implements A {
 public AImpl() {}
 public String foo() {
 // do something
 }
}  </screen>

    <para>The class is then instantiated in a standard way:</para>

    <screen> A object = new AImpl(); </screen>

    <para>Active objects are instantiated using factory methods from the
    ProActive class (see the <ulink url="../HelloWorld.xml">ProActive Hello
    World example</ulink> ). It is also possible to specify the activity of
    the active object, the location (node or virtual node), or a factory for
    meta-objects, using the appropriate factory method.</para>

    <screen>A active_object = (A)ProActive.newActive(
 AImpl, // signature of the base class
 new Object[] {}, // Object[]
 aNode, // location, could also be a virtual node
);</screen>

    <para>As components are also active objects in this implementation, they
    benefit from the same features, and are configurable in a similar way.
    Constructor parameters, nodes, activity, or factories, that can be
    specified for active objects, are also specifiable for components. The
    definition of a component requires 3 sub-definitions: the type, the
    description of the content, and the description of the controller.</para>

    <sect2 remap="h3">
      <title>Type</title>

      <para>The type of the component (i.e. the functional interfaces provided
      and required) is specified in a standard way: (as taken from the Fractal
      tutorial)</para>

      <para>We begin by creating objects that represent the types of the
      components of the application. In order to do this, we must first get a
      bootstrap component. The standard way to do this is the following one
      (this method creates an instance of the class specified in the
      fractal.provider system property, and uses this instance to get the
      bootstrap component):</para>

      <screen> Component boot = Fractal.getBootstrapComponent(); </screen>

      <para>We then get the TypeFactory interface provided by this bootstrap
      component:</para>

      <screen> TypeFactory tf = (TypeFactory)boot.getFcInterface('type-factory'); </screen>

      <para>We can then create the type of the first component, which only
      provides a A server interface named 'a':</para>

      <screen>// type of the a component
ComponentType aType = tf.createFcType(new InterfaceType[] {
 tf.createFcItfType('a', 'A', false, false, false)
}); </screen>
    </sect2>

    <sect2 remap="h3">
      <title>Description of the content</title>

      <para>The second step in the definition of a component is the definition
      of its content. In this implementation, this is done through the
      ContentDescription class:</para>

      <screen language="java">ContentDescription contentDesc = new ContentDescription(
 AImpl, // signature of the base class
 new Object[] {}, // Object[]
 aNode, // location, could also be a virtual node
); </screen>
    </sect2>

    <sect2 remap="h3">
      <title>Description of the controller</title>

      <para>Properties relative to the controller can be specified in the
      ControllerDescription:</para>

      <screen language="java">ControllerDescription controllerDesc = new ControllerDescription(
 'myName', // name of the component
 Constants.PRIMITIVE // the hierarchical type of the component
 // it could be PRIMITIVE, COMPOSITE, or PARALLEL
); </screen>

      <para>Eventually, the component definition is instantiated using the
      standard Fractal API. This component can then be manipulated as any
      other Fractal component.</para>

      <screen language="java">Component component = componentFactory.newFcInstance(
 componentType, // type of the component (defining the client and server interfaces)
 controllerDesc, // implementation-specific description for the controller
 contentDesc // implementation-specific description for the content
); </screen>
    </sect2>

    <sect2 remap="h3">
      <title>From attributes to client interfaces</title>

      <para>There are 2 kinds of interfaces for a component: those that offer
      services, and those that require services. They are named respectively
      server and client interfaces.</para>

      <para>From a Java class, it is fairly natural to identify server
      interfaces: they (can) correspond to the Java interfaces implemented by
      the class. In the above example, 'a' is the name of an interface
      provided by the component, corresponding to the 'A' Java
      interface.</para>

      <para>On the other hand, client interfaces usually correspond to
      attributes of the class, in the case of a primitive component. If the
      component defined above requires a service from another component, say
      the one corresponding to the 'Service' Java interface, the AImpl class
      should be modified. As we use the <emphasis>inversion of
      control</emphasis> pattern, a BindingController is provided, and a
      binding operation on the 'requiredService' interface will actually set
      the value of the 'service' attribute, of type 'Service'.</para>

      <para>First, the type of the component is changed:</para>

      <screen language="java">// type of the a component
ComponentType aType = tf.createFcType(new InterfaceType[] {
 tf.createFcItfType('a', 'A', false, false, false),
 tf.createFcItfType('requiredService', 'A', true, false, false)
}); </screen>

      <para>The Service interface is the following:</para>

      <screen language="java">// The Service interface
public interface Service {
 public String bar();
} </screen>

      <para>And the AImpl class is:</para>

      <screen language="java">// The modified AImpl class
public class AImpl implements A, BindingController {
 Service service; // attribute corresponding to a client interface
 public AImpl() {}
 // implementation of the A interface
 public String foo() {
   return s.bar(); // for example
 }
 // implementation of BindingController
 public Object lookupFc (final String cItf) {
   if (cItf.equals('requiredService')) {
     return service;
   }
   return null;
 }
 // implementation of BindingController
 public void bindFc (final String cItf, final Object sItf) {
   if (cItf.equals('requiredService')) {
     service = (Service)sItf;
   }
 }
 // implementation of BindingController
 public void unbindFc (final String cItf) {
   if (cItf.equals('requiredService')) {
     service = null;
   }
 }
} </screen>
    </sect2>
  </sect1>

  <sect1 id="helloworldExample" remap="h2">
    <title>The HelloWorld example</title>

    <para>The mandatory helloworld example (from the Fractal tutorial) shows
    the different ways of creating a component system (programmatically and
    using the ADL), and it can easily be implemented using ProActive.</para>

    <sect2 remap="h3">
      <title>Set-up</title>

      <para>You can find the code for this example in the package
      org.objectweb.proactive.examples.components.helloworld of the ProActive
      distribution.</para>

      <para>The code is almost identical to the <ulink
      url="http://fractal.objectweb.org/tutorials/fractal/index.xml">Fractal
      tutorial's example</ulink>.</para>

      <para>The differences are the following:</para>

      <itemizedlist>
        <listitem>
          <para>The reference example is provided for level 3.3.
          implementation, whereas this current implementation is compliant up
          to level 3.2: templates are not provided. Thus you will have to skip
          the specific code for templates.</para>
        </listitem>

        <listitem>
          <para>The <literal>newFcInstance</literal> method of the
          <literal>GenericFactory</literal> interface, used for directly
          creating components, takes 2 implementation-specific parameters. So
          you should use the
          <literal>org.objectweb.proactive.component.ControllerDescription</literal>
          and
          <literal>org.objectweb.proactive.component.ContentDescription</literal>
          classes to define ProActive components. (It is possible to use the
          same parameters than in Julia, but that hinders you from using some
          functionalities specific to ProActive, such as distributed
          deployment or definition of the activity).</para>
        </listitem>

        <listitem>
          <para>Collective interfaces could be implemented the same way than
          suggested, but using the
          <literal>Fractive.createCollectiveClientInterface</literal> method
          will prove useful with this implementation: you are then able to use
          the functionalities provided by the typed groups API.</para>
        </listitem>

        <listitem>
          <para>Components can be distributed</para>
        </listitem>

        <listitem>
          <para>the ClientImpl provides an empty no-args constructor.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 remap="h3">
      <title>Architecture</title>

      <para>The helloworld example is a simple client-server application,
      where the client (c) and the server (s) are components, and they are
      both contained in the same root component (root).</para>

      <para>Another configuration is also possible, where client and server
      are wrapped around composite components (C and S). The goal was
      initially to show the interception shortcut mechanism in Julia. In the
      current ProActive implementation, there are no such shortcuts, as the
      different components can be distributed, and all invocations are
      intercepted. The exercise is still of interest, as it involves composite
      components.</para>

      <para><figure>
          <title>Client and Server wrapped in composite components (C and
          S)</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="components/pics/model.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2 remap="h3">
      <title>Distributed deployment</title>

      <para>This section is specific to the ProActive implementation, as it
      uses the deployment framework of this library.</para>

      <para>If the application is started with (only) the parameter
      'distributed', the ADL used is 'helloworld-distributed.fractal', where
      virtualNode of the client and server components are exported as VN1 and
      VN2. Exported virtual node names from the ADL match those defined in the
      deployment descriptor 'deployment.xml'.</para>

      <para>One can of course customize the deployment descriptor and deploy
      components onto virtually any computer, provided it is connectable by
      supported protocols. Supported protocols include LAN, clusters and Grid
      protocols (see <ulink url="../Descriptor.xml">deployment descriptors
      documentation</ulink>).</para>

      <para>Have a look at the ADL files 'helloworld-distributed.fractal' and
      'helloworld-distributed-wrappers.fractal'. In a nutshell, they say: 'the
      primitive components of the application (client and server) will run on
      given exported virtual nodes, whereas the other components (wrappers,
      root component) will run on the current JVM.</para>

      <para>Therefore, we have the two following configurations:</para>

      <para><figure>
          <title>Without wrappers, the primitive components are
          distributed.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="components/pics/distributed-components-no-wrappers.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para><figure>
          <title>2. With wrappers, where again, only the primitive components
          are distributed.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="components/pics/distributed-components-wrappers.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Currently, bindings are not optimized. For example, in the
      configuration with wrappers, there is an indirection that can be costly,
      between the client and the server. We are currently working on
      optimizations that would allow to shortcut communications, while still
      allowing coherent dynamic reconfiguration. It is the same idea than in
      Julia, but we are dealing here with distributed components. It could
      imply compromises between dynamicity and performance issues.</para>
    </sect2>

    <sect2 remap="h3">
      <title>Execution</title>

      <para>You can either compile and run the code yourself, or follow the
      instructions for preparing the examples and use the script
      helloworld_fractal.sh (or .bat). If you choose the first solution, do
      not forget to set the fractal.provider system property.</para>

      <para>If you run the program with no arguments (i.e. not using the
      parser, no wrapper composite components, and local deployment) , you
      should get something like this:</para>

      <screen>01 --&gt; This ClassFileServer is reading resources from classpath
02 Jini enabled
03 Ibis enabled
04 Created a new registry on port 1099
05 //crusoe.inria.fr/Node363257273 successfully bound in registry at //crusoe.inria.fr/Node363257273
06 Generating class: pa.stub.org.objectweb.proactive.core.component.type.Stub_Composite
07 Generating class: pa.stub.org.objectweb.proactive.examples.components.helloworld.Stub_ClientImpl
08 Generating class: pa.stub.org.objectweb.proactive.examples.components.helloworld.Stub_ServerImpl </screen>

      <para>You can see:</para>

      <itemizedlist>
        <listitem>
          <para>line 01: the creation of the class file server which handles
          the on-the-fly generation and distribution of ProActive stubs and
          component functional interfaces</para>
        </listitem>

        <listitem>
          <para>line 04: the creation of a rmi registry</para>
        </listitem>

        <listitem>
          <para>line 05: the registration of the default runtime node</para>
        </listitem>

        <listitem>
          <para>line 06 to 08: the on-the-fly generation of ProActive stubs
          (the generation of component functional interfaces is silent)</para>
        </listitem>
      </itemizedlist>

      <para>Then you have (the exception that pops out is actually the
      expected result, and is intended to show the execution path):</para>

      <screen>01 Server: print method called
02 at org.objectweb.proactive.examples.components.helloworld.ServerImpl.print(ServerImpl.java:37)
03 at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
04 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
05 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
06 at java.lang.reflect.Method.invoke(Method.java:324)
07 at org.objectweb.proactive.core.mop.MethodCall.execute(MethodCall.java:373)
08 at org.objectweb.proactive.core.component.request.ComponentRequestImpl.serveInternal(ComponentRequestImpl.java:163)
09 at org.objectweb.proactive.core.body.request.RequestImpl.serve(RequestImpl.java:108)
10 at org.objectweb.proactive.core.body.BodyImpl$ActiveLocalBodyStrategy.serve(BodyImpl.java:297)
11 at org.objectweb.proactive.core.body.AbstractBody.serve(AbstractBody.java:799)
12 at org.objectweb.proactive.core.body.ActiveBody$FIFORunActive.runActivity(ActiveBody.java:230)
13 at org.objectweb.proactive.core.body.ActiveBody.run(ActiveBody.java:145)
14 at java.lang.Thread.run(Thread.java:534)
15 Server: begin printing...
16 --------&gt; hello world
17 Server: print done.</screen>

      <para>What can be seen is very different from the output you would get
      with the Julia implementation. Here is what happens (from bottom to top
      of the stack):</para>

      <itemizedlist>
        <listitem>
          <para>line 14: The active object runs its activity in its own
          Thread</para>
        </listitem>

        <listitem>
          <para>line 12: The default activity is to serve incoming request in
          a FIFO order</para>
        </listitem>

        <listitem>
          <para>line 08: Requests (reified method calls) are encapsulated in
          ComponentRequestImpl objects</para>
        </listitem>

        <listitem>
          <para>line 06: A request is served using reflection</para>
        </listitem>

        <listitem>
          <para>line 02: The method invoked is the print method of an instance
          of ServerImpl</para>
        </listitem>
      </itemizedlist>

      <para>Now let us have a look at the distributed deployment: execute the
      program with the parameters 'distributed parser'. You should get
      something similar to the following:</para>

      <screen>01 --&gt; This ClassFileServer is reading resources from classpath
02 Jini enabled
03 Ibis enabled
04 Created a new registry on port 1099
05 ************* Reading deployment descriptor: file:/0/user/mmorel/ProActive/classes/org/objectweb/proactive/examplescomponents/helloworld/deployment\
.xml ********************
06 created VirtualNode name=VN1
07 created VirtualNode name=VN2
08 created VirtualNode name=VN3
09 **** Starting jvm on crusoe.inria.fr
10 --&gt; This ClassFileServer is reading resources from classpath
11 Jini enabled
12 Ibis enabled
13 Detected an existing RMI Registry on port 1099
14 //crusoe.inria.fr/VN1462549848 successfully bound in registry at //crusoe.inria.fr/VN1462549848
15 **** Mapping VirtualNode VN1 with Node: //crusoe.inria.fr/VN1462549848 done
16 Generating class: pa.stub.org.objectweb.proactive.examples.components.helloworld.Stub_ClientImpl
17 **** Starting jvm on crusoe.inria.fr
18 --&gt; This ClassFileServer is reading resources from classpath
19 Jini enabled
20 Ibis enabled
21 Detected an existing RMI Registry on port 1099
22 //crusoe.inria.fr/VN21334775605 successfully bound in registry at //crusoe.inria.fr/VN21334775605
23 **** Mapping VirtualNode VN2 with Node: //crusoe.inria.fr/VN21334775605 done
24 Generating class: pa.stub.org.objectweb.proactive.examples.components.helloworld.Stub_ServerImpl
25 //crusoe.inria.fr/Node1145479146 successfully bound in registry at //crusoe.inria.fr/Node1145479146
26 Generating class: pa.stub.org.objectweb.proactive.core.component.type.Stub_Composite
27 MOPClassLoader: class not found, trying to generate it
28 ClassServer sent class Generated_java_lang_Runnable_r_representative successfully
39 MOPClassLoader: class not found, trying to generate it
30 ClassServer sent class Generated_java_lang_Runnable_r_representative successfully
31 MOPClassLoader: class not found, trying to generate it
32 ClassServer sent class Generated_org_objectweb_proactive_examples_components_helloworld_Service_s_representative successfully
33 MOPClassLoader: class not found, trying to generate it
34 ClassServer sent class Generated_org_objectweb_proactive_examples_components_helloworld_ServiceAttributes_attribute_controller_representative succe\
ssfully
35 ClassServer sent class pa.stub.org.objectweb.proactive.examples.components.helloworld.Stub_ServerImpl successfully
</screen>

      <para>What is new is:</para>

      <itemizedlist>
        <listitem>
          <para>line 05 the parsing of the deployment descriptor</para>
        </listitem>

        <listitem>
          <para>line 09 and 17: the creation of 2 virtual machines on the host
          'crusoe.inria.fr'</para>
        </listitem>

        <listitem>
          <para>line 15 and 24: the mapping of virtual nodes VN1 and VN2 to
          the nodes specified in the deployment descriptor</para>
        </listitem>

        <listitem>
          <para>line 35: the dynamic downloading of the stub class for
          ServerImpl: the stub class loader does not find the classes of the
          stubs in the current VM, and fetches the classes from the
          ClassServer</para>
        </listitem>

        <listitem>
          <para>line 28, 30, 32, 34: the dynamic downloading of the classes
          corresponding to the components functional interfaces (they were
          silently generated)</para>
        </listitem>
      </itemizedlist>

      <para>Then we get the same output than for a local deployment, the
      activity of active objects is independent from its location.</para>

      <screen>01 Server: print method called
02 at org.objectweb.proactive.examples.components.helloworld.ServerImpl.print(ServerImpl.java:37)
03 at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
04 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
05 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
06 at java.lang.reflect.Method.invoke(Method.java:324)
07 at org.objectweb.proactive.core.mop.MethodCall.execute(MethodCall.java:373)
08 at org.objectweb.proactive.core.component.request.ComponentRequestImpl.serveInternal(ComponentRequestImpl.java:163)
09 at org.objectweb.proactive.core.body.request.RequestImpl.serve(RequestImpl.java:108)
10 at org.objectweb.proactive.core.body.BodyImpl$ActiveLocalBodyStrategy.serve(BodyImpl.java:297)
11 at org.objectweb.proactive.core.body.AbstractBody.serve(AbstractBody.java:799)
12 at org.objectweb.proactive.core.body.ActiveBody$FIFORunActive.runActivity(ActiveBody.java:230)
13 at org.objectweb.proactive.core.body.ActiveBody.run(ActiveBody.java:145)
14 at java.lang.Thread.run(Thread.java:534)
15 Server: begin printing...
16 -&gt;hello world
17 Server: print done.</screen>
    </sect2>

    <sect2 id="HelloWorldADLFiles" remap="h3">
      <title>The HelloWorld ADL files</title>

      <para><anchor id="distributed-wrappers-fractal" />
      org.objectweb.proactive.examples.components.helloworld.helloworld-distributed-wrappers.fractal</para>

      <screen> 1:&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
 2:&lt;!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN"
 3:            "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd"&gt;
 4:
 5:&lt;definition name="org.objectweb.proactive.examples.components.helloworld.helloworld-distributed-wrappers"&gt;
 6:  &lt;interface name="r" role="server" signature="java.lang.Runnable"/&gt;
 7:    &lt;exportedVirtualNodes&gt;
 8:        &lt;exportedVirtualNode name="VN1"&gt;
 9:            &lt;composedFrom&gt;
 10:               &lt;composingVirtualNode component="client" name="client-node"/&gt;
 11:            &lt;/composedFrom&gt;
 12:        &lt;/exportedVirtualNode&gt;
 13:        &lt;exportedVirtualNode name="VN2"&gt;
 14:            &lt;composedFrom&gt;
 15:                &lt;composingVirtualNode component="server" name="server-node"/&gt;
 16:            &lt;/composedFrom&gt;
 17:        &lt;/exportedVirtualNode&gt;
 18:    &lt;/exportedVirtualNodes&gt;
 19:  &lt;component name="client-wrapper"
 20:              definition="org.objectweb.proactive.examples.components.helloworld.ClientType"&gt;
 21:      &lt;component name="client"
 22:                 definition="org.objectweb.proactive.examples.components.helloworld.ClientImpl"/&gt;
 23:      &lt;binding client="this.r" server="client.r"/&gt;
 24:      &lt;binding client="client.s" server="this.s"/&gt;
 25:      &lt;controller desc="composite"/&gt;
 26:  &lt;/component&gt;
 27:  &lt;component name="server-wrapper"
 28:             definition="org.objectweb.proactive.examples.components.helloworld.ServerType"&gt;    
 29:      &lt;component name="server"
 30:                 definition="org.objectweb.proactive.examples.components.helloworld.ServerImpl"/&gt;
 31:      &lt;binding client="this.s" server="server.s"/&gt;
 32:      &lt;controller desc="composite"/&gt;
 33:  &lt;/component&gt;
 34:  &lt;binding client="this.r" server="client-wrapper.r"/&gt;
 35:  &lt;binding client="client-wrapper.s" server="server-wrapper.s"/&gt;
 36:&lt;/definition&gt;
</screen>

      <para><anchor id="ClientType-fractal" />
      org.objectweb.proactive.examples.components.helloworld.ClientType.fractal</para>

      <screen> 1:&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
 2:&lt;!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN"
 3:            "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd"&gt;
 4:
 5:&lt;definition name="org.objectweb.proactive.examples.components.helloworld.ClientType"
 6:              extends="org.objectweb.proactive.examples.components.helloworld.RootType"&gt;
 7:    &lt;interface name="r" role="server" signature="java.lang.Runnable"/&gt;
 8:    &lt;interface name="s" role="client"
 9:                 signature="org.objectweb.proactive.examples.components.helloworld.Service"/&gt;
 10:&lt;/definition&gt;
</screen>

      <para><anchor id="ClientImpl-fractal" />
      org.objectweb.proactive.examples.components.helloworld.ClientImpl.fractal</para>

      <screen>  1:&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
  2:&lt;!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN"
  3:            "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd"&gt;
  4:
  5:&lt;definition name="org.objectweb.proactive.examples.components.helloworld.ClientImpl"
  6:              extends="org.objectweb.proactive.examples.components.helloworld.ClientType"&gt;
  7:    &lt;exportedVirtualNodes&gt;
  8:        &lt;exportedVirtualNode name="client-node"&gt;
  9:            &lt;composedFrom&gt;
  10:                &lt;composingVirtualNode component="this" name="client-node"/&gt;
  11:            &lt;/composedFrom&gt;
  12:        &lt;/exportedVirtualNode&gt;
  13:    &lt;/exportedVirtualNodes&gt;
  14:    &lt;content class="org.objectweb.proactive.examples.components.helloworld.ClientImpl"/&gt;
  15:    &lt;virtual-node name="client-node" cardinality="single"/&gt;
  16:&lt;/definition&gt;</screen>

      <para><anchor id="ServerType-fractal" />
      org.objectweb.proactive.examples.components.ServerType</para>

      <screen>1:&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
2:&lt;!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN"
3:            "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd"&gt;
4:
5:&lt;definition name="org.objectweb.proactive.examples.components.helloworld.ServerType"&gt;
6:  &lt;interface name="s" role="server"
7:          signature="org.objectweb.proactive.examples.components.helloworld.Service"/&gt;
8:&lt;/definition&gt;</screen>

      <para><anchor id="ServerImpl-fractal" />
      org.objectweb.proactive.examples.components.helloworld.ServerImpl</para>

      <screen>1:&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
2:&lt;!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN"
3:        "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd"&gt;
4:
5:&lt;definition name="org.objectweb.proactive.examples.components.helloworld.ServerImpl"
6:       extends="org.objectweb.proactive.examples.components.helloworld.ServerType"&gt;
7:    &lt;exportedVirtualNodes&gt;
8:        &lt;exportedVirtualNode name="server-node"&gt;
9:            &lt;composedFrom&gt;
10:                &lt;composingVirtualNode component="this" name="server-node"/&gt;
11:            &lt;/composedFrom&gt;
12:        &lt;/exportedVirtualNode&gt;
13:    &lt;/exportedVirtualNodes&gt;
14:  &lt;content class="org.objectweb.proactive.examples.components.helloworld.ServerImpl"/&gt;
15:  &lt;attributes signature="org.objectweb.proactive.examples.components.helloworld.ServiceAttributes"&gt;
16:    &lt;attribute name="header" value="-&gt;"/&gt;
17:    &lt;attribute name="count" value="1"/&gt;
18:  &lt;/attributes&gt;
19:  &lt;controller desc="primitive"/&gt;
20:  &lt;virtual-node name="server-node" cardinality="single"/&gt;
21:&lt;/definition&gt;</screen>
    </sect2>
  </sect1>

  <sect1 remap="h2">
    <title><anchor id="examples_html_The_Comanche_example" />The Comanche
    example</title>

    <para><ulink url="http://fractal.objectweb.org/tutorial/index.xml">The
    Comanche example</ulink> is a nice introduction to component based
    development with Fractal. It explains how to design applications using
    components, and how to implement these applications using the Fractal
    API.</para>

    <para>You will notice that the example presented in this tutorial is based
    on Comanche, a simplistic http server. However, this example extensively
    uses reference passing through components. For example
    <literal>Request</literal> objects are passed by reference. This is
    incompatible with the ProActive programming model, where, to avoid shared
    passive objects, all passive objects passed to active objects are actually
    <emphasis role="bold">passed by copy</emphasis>(see <ulink
    url="http://www-sop.inria.fr/oasis/proactive/doc/api/org/objectweb/proactive/ProActiveBasis.xml">
    ProActive basis</ulink>). As active objects are themselves passed by
    reference, one could argue that we could turn some passive object into
    active objects. This would allow remote referencing through stubs.
    Unfortunately, for reasons specific to the Sockets and Streams
    implementations, (Socket streams implementations do not provide empty
    no-arg constructors), it is not easily possible to encapsulate some of the
    needed resource classes into active objects.</para>
  </sect1>

  <sect1 remap="h2">
    <title><anchor
    id="examples_html_The_C3D_example_turning_Active_Objects_into_Components" />C3D
    - from Active Objects to Components</title>

    <sect2 remap="h3">
      <title>Reason for this example</title>

      <para>This is an example of an application that is refactored to fit the
      components dogma. The standard C3D example has been taken as a basis,
      and component wrappers have been created. This way, one can see what is
      needed to transform an application into component-oriented code.</para>

      <para>You may find the code in the <ulink
      url="../doc/ProActive_src_html/org.objectweb.proactive.examples.components.c3d.index.xml">examples/components/c3d</ulink>
      directory of the proactive source.</para>
    </sect2>

    <sect2 remap="h3">
      <title>Using working C3D code with components</title>

      <para><figure>
          <title>Informal description of the C3D Components hierarchy</title>

          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100"
                         fileref="components/pics/C3D-Components-UML.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>We consider the working C3D application. It's nice, and has a
      sleak GUI, but we now want to add component power to it! What we do is
      shown on the image: add wrappers around the original object classes
      (C3D*) and instead of linking the classes together by setting fields
      through the initial methods, do that in the binding methods. In other
      words, we have to spot exactly where C3DRenderingEngine, C3DUser and
      C3DDispatcher are used by a class other than itself, and turn these
      references into component bindings. Of course, we also have to expose
      the interfaces that we are going to use, hence the Dispatcher, Engine
      and User interface that have to be implemented.</para>
    </sect2>

    <sect2 remap="h3">
      <title>How the application is written</title>

      <para>First of all, have a look at the doc on <ulink
      url="c3d.xml">C3D</ulink> to remember how this application is written.
      Most important is the class diagram, showing C3DUser, C3DDispatcher and
      C3DRederingEngine. We decided that the only objects worth wrapping in
      components were those three. The rest is too small to be worth the
      hassle.</para>

      <sect3 remap="h4">
        <title>Creating the interfaces</title>

        <para>What we need to do is to extract the interfaces of the Objects,
        ie the which methods are going to be called on the components. This
        means find out what methods are called from outside the Active Object.
        You can do that by searching in the classes where the calls are made
        on active objects. For this, <emphasis role="bold">you have to know in
        detail which classes are going to be turned into component</emphasis>.
        If you have a code base which closely follows Object Oriented
        Programming rules, the interfaces are already there. Indeed, when a
        class is written, it should always go with one or more interfaces,
        which present to the world what the class abilities are. In C3D
        (Active Object version), these interfaces already exist: they are
        called <literal>User</literal>, <literal>Engine</literal> and
        <literal>Dispatcher</literal>.</para>

        <note>
          <para><emphasis role="bold">Tricky part:</emphasis> whatever way you
          look at components, you'll have to modify the initial code if these
          interfaces were not created at first go. You have to replace all the
          class references by their interface, when you use them in other
          files. For example, if we had not already used interfaces in the C3D
          Object code, we would have had to replace all occurrences of
          C3DDispatcher by occurrences of Dispatcher.</para>
        </note>

        <para>Why do we have to do that, replacing classes by interfaces?
        That's due to the way components work. When the components are going
        to be bound, you're not binding the classes themselves, but proxies to
        these classes. And these proxies implement the interfaces, and do not
        extend the classes.</para>
      </sect3>

      <sect3 remap="h4">
        <title>Creating the Component Wrappers</title>

        <para>You now have to create a class that englobes the previous Active
        Objects, and which is a component representing the same functionality.
        How do you do that? Pretty simple. All you need to do is extend the
        Active Object class, and add to it the non-functional interfaces which
        go with the component. You have the binding interfaces to create,
        which basically say how to put together two Components, tell who is
        already attached, and how to separate them. These are the
        <literal>lookupFc</literal>, <literal>bindFc</literal>,
        <literal>unbindFc</literal>, and <literal>listFc</literal>
        methods.</para>

        <para>This has been done in the <literal>*Impl</literal> files. Let's
        consider, for example, the UserImpl class (it is shown below).What you
        have here are those component methods. Be even more careful with this
        <literal>bindFc</literal> method. In fact, it really binds the
        protected <literal>Dispatcher</literal> variable
        <literal>c3ddispatcher</literal>. This way, the
        <literal>C3DUser</literal> code can now use this variable as if it was
        addressing the real Active Object. Just to be precise, we have to
        point out that you're going through proxies before reaching the
        Component, then the Active Object. But this is hidden by the ProActive
        layer, all you should know is you're addressing a
        <literal>Dispatcher</literal>, and you're fine! The
        <literal>findDispatcher</literal> method has only been added because
        component lookup doesn't work like standard Active Object lookup.
        <example>
            <title>The UserImpl class, a component wrapper</title>

            <programlisting language="java"><textobject>
                <textdata fileref="../examples/components/c3d/UserImpl.java" />
              </textobject></programlisting>
          </example></para>
      </sect3>

      <sect3 remap="h4">
        <title>Discarding direct reference acknowledgment</title>

        <para>If you're out of luck, the code contains instructions to retain
        references to objects that call methods on the current Object. These
        methods have a signature ressembling <literal>method(..., ActiveObject
        ao, ...)</literal>. This is called, in ProActive, with a
        <literal>ProActive.getStubOnThis()</literal> (if you don't, and
        instead use 'this', the code won't work correctly on remote hosts!).
        If the local object uses this
        <literal>ProActive.getStubOnThis()</literal>, you're going to have
        trouble with components. The problem is that this design does not fit
        the component paradigm: you should be using declared interfaces bound
        with the bind methods, not be passing along references to self. So you
        have to remove these from the code, and make it component-oriented.
        But remember, <emphasis role="bold">you should be using bind methods
        to attach other components</emphasis>.</para>

        <note>
          <para>If you really have to keep these references
          <literal>ProActive.getStubOnThis()</literal> these, you may do it,
          because components, (or at least their internals) really are Active
          Objects. But you should be extra careful. This "Active Object
          reference passing" should not happen between components, as they are
          meant to interact through their component interfaces only.</para>
        </note>
      </sect3>
    </sect2>

    <sect2 remap="h3">
      <title>ADL</title>

      <para>You may be wanting to see how we have bound the components
      together, now. Since the design is pretty simple, there is not much to
      it. We have used the fractal ADL, to avoid hard-coding bindings. So all
      of the information here is in the
      <literal>examples/components/c3d/adl/</literal> directory. There are the
      components, called '<literal>...Impl</literal>' (you can see there which
      interfaces they propose), and a
      '<literal>userAndComposite.fractal</literal>' file, which is where the
      bindings are made. It includes the use of a Composite component, just
      for the fun. Specifically, it links one user to a composite made of a
      dispatcher and two renderers. You may want to explore these files with
      the Fractal GUI provided with IC2D, it's easier to understand
      graphically. Here's the code, nevertheless, for you curiosity:</para>

      <para><example>
          <title>userAndComposite.fractal, a component ADL file</title>

          <programlisting language=""><textobject>
              <textdata fileref="../examples/components/c3d/adl/userAndComposite.fractal" />
            </textobject></programlisting>
        </example></para>

      <para>Here's what it looks like when you explore it through the IC2D
      Component explorer <figure>
          <title>IC2D component explorer with the C3D example</title>

          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100"
                         fileref="components/pics/c3d_components.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Advanced component highlights</title>

      <sect3>
        <title>Renaming Virtual Nodes</title>

        <para>One feature given by the component architecture is the
        possiblity to rename <literal>Virtual Nodes</literal>. Let's see how
        this can be used:</para>

        <para>Suppose you are only dealing with packaged software. That means
        you may not modify the source code of some part of your application,
        for instance because it is kindly given to you by some other company,
        which wants to keep parts of its codebase secret. Let's say that the
        deployment descriptor you're using does not reference the proper
        <literal>Virtual Nodes</literal>. How can you still deploy your
        application in this case? Well, you have to
        <emphasis>rename</emphasis> those Nodes into the names that are
        fitting to your application. Here's an example of how to do
        that:</para>

        <para><example>
            <title>How to rename Virtual Nodes in ADL files</title>

            <para>In the main ADL file<screen>  &lt;interface signature="java.lang.Runnable" role="server" name="r"/&gt;

&lt;!-- mapping the node names in the descriptor file to others referenced in the component's adl files. --&gt;
 &lt;exportedVirtualNodes&gt;
   &lt;exportedVirtualNode name="UserVirtualNode"&gt;
     &lt;composedFrom&gt;
       &lt;composingVirtualNode component="user" name="User"/&gt;
     &lt;/composedFrom&gt;
   &lt;/exportedVirtualNode&gt;
 &lt;/exportedVirtualNodes&gt;

&lt;!-- Creating one user component --&gt;</screen>In the User ADL file</para>

            <para><screen>&lt;content class="org.objectweb.proactive.examples.components.c3d.UserImpl"/&gt;

&lt;!-- Recalling a renamed Virtual Node --&gt;
&lt;exportedVirtualNodes&gt;
  &lt;exportedVirtualNode name="User"&gt;
    &lt;composedFrom&gt;
      &lt;composingVirtualNode component="this" name="User"/&gt;
    &lt;/composedFrom&gt;
  &lt;/exportedVirtualNode&gt;
&lt;/exportedVirtualNodes&gt;

&lt;controller desc="primitive"/&gt;</screen>If you add this code into the
            adl, you are saying that the <literal>VirtualNode</literal> called
            <literal>UserVirtualNode</literal> (found in the deployment
            descriptor file the application is using) should be recognized by
            the application as if it was called
            <literal>User</literal>.</para>
          </example></para>

        <para><note>
            <para>Above has been described the way to rename a
            <literal>VirtualNode</literal>; this can be used on packaged
            software, when the <literal>VirtualNodes</literal> provided do not
            fit the <literal>VirtualNodes</literal> needed by your
            application.</para>
          </note></para>
      </sect3>

      <sect3>
        <title>Component lookup and registration</title>

        <para>When running the User Component alone, you are prompted for an
        address on which to lookup a Dispatcher Component. Then the two
        components are bound through a lookup mechanism. This is very simple
        to use. Here's the code to do that: </para>

        <example>
          <title>Component Lookup and Register</title>

          <para>The component Registration</para>

          <para><programlisting language="java">Fractive.register(Fractive.getComponentRepresentativeOnThis(),
              UrlBuilder.buildUrlFromProperties("localhost", "Dispatcher"));   </programlisting></para>

          <para>The Component lookup</para>

          <para><programlisting language="java">ProActiveComponentRepresentative a = Fractive.lookup(
       UrlBuilder.buildUrl(this.hostName, "Dispatcher", protocol, this.portNumber));
this.c3dDispatcher = (Dispatcher) a.getFcInterface("user2dispatcher");</programlisting></para>
        </example>

        <para>For the registeration, you only need a reference on the
        component you want to register, and build a url containing the name of
        the host, containing an alias for the Component. </para>

        <para>The <literal>Fractive.lookup</literal> method uses a Url to find
        the host which holds the component. This Url contains the machine name
        of the host, communication protocl and portNumber, but also the lookup
        name under which the desired Component has been registered under ,
        here "Dispatcher". The last operation consists only in retreiving the
        correct interface to which to connect to. If the interface is not
        known at compile-time, it can be discovered at run-time with the
        <literal>getFcInterfaces()</literal> method, which lists all the
        interfaces available. </para>
      </sect3>
    </sect2>

    <sect2>
      <title>How to run this example</title>

      <para>There is only one access point for this example in the scripts
      directory: <screen>scripts/unix/components$ ./c3d.sh
       --- Fractal C3D example ---------------------------------------------
       Parameters : [fractal_ADL_file] descriptor_file
       the first file describes your components layout.
       Default is org.objectweb.proactive.examples.components.c3d.adl.userAndComposite
       the second file describes your deployment of computing nodes.
       You may want to try ../../../descriptors/components/C3D_all.xml
       ---------------------------------------------------------</screen></para>

      <para>You have there the way to start this example. If you only want to
      start the Composite (Dispatcher + Renderer), try this: <screen>scripts/unix/components$ ./c3d.sh org.objectweb.proactive.examples.components.c3d.adl.compositeOfDispRend \
       ../../../descriptors/components/C3D_all.xml</screen></para>

      <para>If you want to start only a User, you will be asked for the
      address of a Dispatcher to which to connect to: <screen>scripts/unix/components$ ./c3d.sh org.objectweb.proactive.examples.components.c3d.adl.UserImpl \
       ../../../descriptors/components/C3D_all.xml</screen></para>
    </sect2>

    <sect2>
      <title>Source Code</title>

      <para>You may find the source code of this application at the following
      locations :</para>

      <itemizedlist>
        <listitem>
          <para><ulink
          url="../doc/ProActive_src_html/org.objectweb.proactive.examples.c3d.index.xml">Active
          Object version</ulink> ( examples/c3d )</para>
        </listitem>

        <listitem>
          <para><ulink
          url="../doc/ProActive_src_html/org.objectweb.proactive.examples.components.c3d.index.xml">Component
          version</ulink> ( examples/components/c3d )</para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>