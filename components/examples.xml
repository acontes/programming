<?xml version="1.0" encoding="UTF-8"?>
<chapter id="componentExamples"><title>Examples</title>
<!--  File: /home/irosenbe/PA_new_doc/docbook-tuto/components/examples.html  -->
  
    <para> <anchor id="examples_html_examples"/></para>
    <para>3 examples are presented : code snippets for visualizing the transition between active objects
 and components, the &quot;hello world&quot;, from the Fractal tutorial, and C3D component
 version. The programming model is Fractal, and one should refer to the Fractal documentation for
 detailed examples.</para>
    <sect1 remap="h2">
      <title><anchor id="examples_html_From_objects_to_active_objects_to_distributed_components"/>From objects to active objects to
 distributed components</title>
      <para>In Java, objects are created by instantiation of classes. With ProActive, one can create
 active objects from Java classes, while components are created from component definitions. Let us
 first consider the &quot;A&quot; interface :</para>
<screen>
public interface A {
  public String foo(); // dummy method
} </screen>
      <para>&quot;AImpl&quot; is the class implementing this interface :</para>
<screen>
public class AImpl implements A {
 public AImpl() {}
 public String foo() {
 // do something
 }
}  </screen>
      <para>The class is then instantiated in a standard way :</para>
<screen> A object = new AImpl(); </screen>
      <para>Active objects are instantiated using factory methods from the ProActive class (see the <ulink url="../HelloWorld.xml">ProActive Hello World example</ulink> ). It is also possible to specify
 the activity of the active object, the location (node or virtual node), or a factory for
 meta-objects, using the appropriate factory method.</para>
<screen>
A active_object = (A)ProActive.newActive(
 AImpl, // signature of the base class
 new Object[] {}, // Object[]
 aNode, // location, could also be a virtual node
);
</screen>
      <para>As components are also active objects in this implementation, they benefit from the same
 features, and are configurable in a similar way. Constructor parameters, nodes, activity, or
 factories, that can be specified for active objects, are also specifiable for components. The
 definition of a component requires 3 sub-definitions : the type, the description of the content,
 and the description of the controller.</para>
      <sect2 remap="h3">
        <title>Type</title>
        <para>The type of the component (i.e. the functional interfaces provided and required) is specified
 in a standard way : (as taken from the Fractal tutorial)</para>
        <para>We begin by creating objects that represent the types of the components of the application. In
 order to do this, we must first get a bootstrap component. The standard way to do this is the
 following one (this method creates an instance of the class specified in the fractal.provider
 system property, and uses this instance to get the bootstrap component):</para>
<screen> Component boot = Fractal.getBootstrapComponent(); </screen>
        <para>We then get the TypeFactory interface provided by this bootstrap component:</para>
<screen> TypeFactory tf = (TypeFactory)boot.getFcInterface(&quot;type-factory&quot;); </screen>
        <para>We can then create the type of the first component, which only provides a A server interface
 named &quot;a&quot;:</para>
<screen>
// type of the a component
ComponentType aType = tf.createFcType(new InterfaceType[] {
 tf.createFcItfType(&quot;a&quot;, &quot;A&quot;, false, false, false)
}); </screen>
      </sect2>
      <sect2 remap="h3">
        <title>Description of the content</title>
        <para>The second step in the definition of a component is the definition of its content. In this
 implementation, this is done through the ContentDescription class :</para>
<screen>
ContentDescription contentDesc = new ContentDescription(
 AImpl, // signature of the base class
 new Object[] {}, // Object[]
 aNode, // location, could also be a virtual node
); </screen>
      </sect2>
      <sect2 remap="h3">
        <title>Description of the controller</title>
        <para>Properties relative to the controller can be specified in the ControllerDescription :</para>
<screen>
ControllerDescription controllerDesc = new ControllerDescription(
 &quot;myName&quot;, // name of the component
 Constants.PRIMITIVE // the hierarchical type of the component
 // it could be PRIMITIVE, COMPOSITE, or PARALLEL
); </screen>
        <para>Eventually, the component definition is instantiated using the standard Fractal API. This
 component can then be manipulated as any other Fractal component.</para>
<screen>
Component component = componentFactory.newFcInstance(
 componentType, // type of the component (defining the client and server in\
terfaces)
 controllerDesc, // implementation-specific description for the controller
 contentDesc // implementation-specific description for the content
); </screen>
      </sect2>
      <sect2 remap="h3">
        <title>From attributes to client interfaces</title>
        <para>There are 2 kinds of interfaces for a component : those that offer services, and those that
 require services. They are named respectively server and client interfaces.</para>
        <para>From a Java class, it is fairly natural to identify server interfaces : they (can) correspond
 to the Java interfaces implemented by the class. In the above example, &quot;a&quot; is the name
 of an interface provided by the component, corresponding to the &quot;A&quot; Java interface.</para>
        <para>On the other hand, client interfaces usually correspond to attributes of the class, in the
 case of a primitive component. If the component defined above requires a service from another
 component, say the one corresponding to the &quot;Service&quot; Java interface, the AImpl class
 should be modified. As we use the <emphasis>inversion of control</emphasis> pattern, a BindingController is
 provided, and a binding operation on the &quot;requiredService&quot; interface will actually set
 the value of the &quot;service&quot; attribute, of type &quot;Service&quot;.</para>
        <para>First, the type of the component is changed :</para>
<screen>
// type of the a component
ComponentType aType = tf.createFcType(new InterfaceType[] {
 tf.createFcItfType(&quot;a&quot;, &quot;A&quot;, false, false, false),
 tf.createFcItfType(&quot;requiredService&quot;, &quot;A&quot;, true, false, false)
}); </screen>
        <para>The Service interface is the following :</para>
<screen>
// The Service interface
public interface Service {
 public String bar();
} </screen>
        <para>And the AImpl class is :</para>
<screen>
// The modified AImpl class
public class AImpl implements A, BindingController {
 Service service; // attribute corresponding to a client interface
 public AImpl() {}
 // implementation of the A interface
 public String foo() {
   return s.bar(); // for example
 }
 // implementation of BindingController
 public Object lookupFc (final String cItf) {
   if (cItf.equals(&quot;requiredService&quot;)) {
     return service;
   }
   return null;
 }
 // implementation of BindingController
 public void bindFc (final String cItf, final Object sItf) {
   if (cItf.equals(&quot;requiredService&quot;)) {
     service = (Service)sItf;
   }
 }
 // implementation of BindingController
 public void unbindFc (final String cItf) {
   if (cItf.equals(&quot;requiredService&quot;)) {
     service = null;
   }
 }
} </screen>
      </sect2>
    </sect1>
    <sect1 remap="h2" id="helloworldExample">
     <title>The HelloWorld example</title>
      <para>The mandatory helloworld example (from the Fractal tutorial) shows the
 different ways of creating a component system (programmatically and using the ADL), and it can
 easily be implemented using ProActive.</para>
      <sect2 remap="h3">
        <title>Set-up</title>
        <para>You can find the code for this example in the package
 org.objectweb.proactive.examples.components.helloworld of the ProActive distribution.</para>
        <para> The code is almost identical to the 
 <ulink url="http://fractal.objectweb.org/tutorials/fractal/index.xml">Fractal tutorial's example</ulink>.
</para>
        <para>The differences are the following :</para>
        <itemizedlist>
          <listitem>
            <para> The reference example is provided for level 3.3. implementation, whereas
 this current implementation is compliant up to level 3.2 : templates are not provided. Thus you
 will have to skip the specific code for templates.</para>
          </listitem>
          <listitem>
            <para> The <literal>newFcInstance</literal> method of the <literal>GenericFactory</literal>
 interface, used for directly creating components, takes 2 implementation-specific parameters.
 So you should use the <literal>org.objectweb.proactive.component.ControllerDescription</literal> and <literal>org.objectweb.proactive.component.ContentDescription</literal> classes to define ProActive
 components. (It is possible to use the same parameters than in Julia, but that hinders you from
 using some functionalities specific to ProActive, such as distributed deployment or definition
 of the activity).</para>
          </listitem>
          <listitem>
            <para> Collective interfaces could be implemented the same way than suggested,
 but using the <literal>Fractive.createCollectiveClientInterface</literal> method will prove useful
 with this implementation : you are then able to use the functionalities provided by the typed
 groups API.</para>
          </listitem>
          <listitem>
            <para> Components can be distributed</para>
          </listitem>
          <listitem>
            <para> the ClientImpl provides an empty no-args constructor.</para>
          </listitem>
</itemizedlist>
      </sect2>
      <sect2 remap="h3">
        <title>Architecture</title>
        <para>The helloworld example is a simple client-server application, where the
 client (c) and the server (s) are components, and they are both contained in the same root
 component (root).</para>
        <para>Another configuration is also possible, where client and server are wrapped
 around composite components (C and S). The goal was initially to show the interception shortcut
 mechanism in Julia. In the current ProActive implementation, there are no such shortcuts, as the
 different components can be distributed, and all invocations are intercepted. The exercise is
 still of interest, as it involves composite components.</para>
        <para>
          <informalfigure>
            <mediaobject>
              <imageobject>
                <imagedata width="6in" fileref="components/pics/model.png" format="PNG"/>              </imageobject>
            </mediaobject>
          </informalfigure>
</para>
      </sect2>
      <sect2 remap="h3">
        <title>Distributed deployment</title>
        <para>This section is specific to the ProActive implementation, as it uses the
 deployment framework of this library.</para>
        <para>If the application is started with (only) the parameter
 &quot;distributed&quot;, the ADL used is &quot;helloworld-distributed.fractal&quot;, where
 virtualNode of the client and server components are exported as VN1 and VN2. Exported virtual
 node names from the ADL match those defined in the deployment descriptor
 &quot;deployment.xml&quot;.</para>
        <para>One can of course customize the deployment descriptor and deploy components
 onto virtually any computer, provided it is connectable by supported protocols. Supported
 protocols include LAN, clusters and Grid protocols (see <ulink url="../Descriptor.xml">deployment
 descriptors documentation</ulink>).</para>
        <para>Have a look at the ADL files &quot;helloworld-distributed.fractal&quot; and
 &quot;helloworld-distributed-wrappers.fractal&quot;. In a nutshell, they say : &quot;the
 primitive components of the application (client and server) will run on given exported virtual
 nodes, whereas the other components (wrappers, root component) will run on the current JVM.</para>
        <para>&#160;</para>
        <para>Therefore, we have the two following configurations :</para>
        <para>1. The one without wrappers, where the primitive components are
 distributed.</para>
        <para>
          <informalfigure>
            <mediaobject>
              <imageobject>
                <imagedata width="6in" fileref="components/pics/distributed-components-no-wrappers.png" format="PNG"/>              </imageobject>
            </mediaobject>
          </informalfigure>
</para>
        <para>&#160;</para>
        <para>2. The one with wrappers, where again, only the primitive components are
 distributed.</para>
        <para>
          <informalfigure>
            <mediaobject>
              <imageobject>
                <imagedata width="6in" fileref="components/pics/distributed-components-wrappers.png" format="PNG"/>              </imageobject>
            </mediaobject>
          </informalfigure>
</para>
        <para>&#160;</para>
        <para>Currently, bindings are not optimized. For example, in the configuration
 with wrappers, there is an indirection that can be costly, between the client and the server. We
 are currently working on optimizations that would allow to shortcut communications, while still
 allowing coherent dynamic reconfiguration. It is the same idea than in Julia, but we are dealing
 here with distributed components. It could imply compromises between dynamicity and performance
 issues.</para>
      </sect2>
      <sect2 remap="h3">
        <title>Execution</title>
        <para>You can either compile and run the code yourself, or follow the instructions for preparing the
 examples and use the script helloworld_fractal.sh (or .bat). If you choose the first solution, do
 not forget to set the fractal.provider system property.</para>
        <para>If you run the program with no arguments (i.e. not using the parser, no wrapper composite
 components, and local deployment) , you should get something like this:</para>
<screen>
01 --&gt; This ClassFileServer is reading resources from classpath
02 Jini enabled
03 Ibis enabled
04 Created a new registry on port 1099
05 //crusoe.inria.fr/Node363257273 successfully bound in registry at //crus\
oe.inria.fr/Node363257273
06 Generating class : pa.stub.org.objectweb.proactive.core.component.type.S\
tub_Composite
07 Generating class : pa.stub.org.objectweb.proactive.examples.components.h\
elloworld.Stub_ClientImpl
08 Generating class : pa.stub.org.objectweb.proactive.examples.components.h\
elloworld.Stub_ServerImpl </screen>
        <para>You can see :</para>
        <itemizedlist>
          <listitem>
            <para> line 01 : the creation of the class file server which handles the on-the-fly generation and
 distribution of ProActive stubs and component functional interfaces</para>
          </listitem>
          <listitem>
            <para> line 04 : the creation of a rmi registry</para>
          </listitem>
          <listitem>
            <para> line 05 : the registration of the default runtime node</para>
          </listitem>
          <listitem>
            <para> line 06 to 08 : the on-the-fly generation of ProActive stubs (the generation of component
 functional interfaces is silent)</para>
          </listitem>
</itemizedlist>
        <para>Then you have (the exception that pops out is actually the expected result, and is intended to
 show the execution path) :</para>
<screen>
01 Server: print method called
02 at org.objectweb.proactive.examples.components.helloworld.ServerImpl.pri\
nt(ServerImpl.java:37)
03 at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
04 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.\
java:39)
05 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces\
sorImpl.java:25)
06 at java.lang.reflect.Method.invoke(Method.java:324)
07 at org.objectweb.proactive.core.mop.MethodCall.execute(MethodCall.java:3\
73)
08 at org.objectweb.proactive.core.component.request.ComponentRequestImpl.s\
erveInternal(ComponentRequestImpl.java:163)
09 at org.objectweb.proactive.core.body.request.RequestImpl.serve(RequestIm\
pl.java:108)
10 at org.objectweb.proactive.core.body.BodyImpl$ActiveLocalBodyStrategy.se\
rve(BodyImpl.java:297)
11 at org.objectweb.proactive.core.body.AbstractBody.serve(AbstractBody.jav\
a:799)
12 at org.objectweb.proactive.core.body.ActiveBody$FIFORunActive.runActivit\
y(ActiveBody.java:230)
13 at org.objectweb.proactive.core.body.ActiveBody.run(ActiveBody.java:145)
14 at java.lang.Thread.run(Thread.java:534)
15 Server: begin printing...
16 --------&gt; hello world
17 Server: print done.
</screen>
        <para>What can be seen is very different from the output you would get with the Julia
 implementation. Here is what happens (from bottom to top of the stack):</para>
        <itemizedlist>
          <listitem>
            <para> line 14 : The active object runs its activity in its own Thread</para>
          </listitem>
          <listitem>
            <para> line 12 : The default activity is to serve incoming request in a FIFO order</para>
          </listitem>
          <listitem>
            <para> line 08 : Requests (reified method calls) are encapsulated in ComponentRequestImpl
 objects</para>
          </listitem>
          <listitem>
            <para> line 06 : A request is served using reflection</para>
          </listitem>
          <listitem>
            <para> line 02 : The method invoked is the print method of an instance of ServerImpl</para>
          </listitem>
</itemizedlist>
        <para>Now let us have a look at the distributed deployment : execute the program with the parameters
 &quot;distributed parser&quot;. You should get something similar to the following :</para>
<screen>
01 --&gt; This ClassFileServer is reading resources from classpath
02 Jini enabled
03 Ibis enabled
04 Created a new registry on port 1099
05 ************* Reading deployment descriptor: file:/0/user/mmorel/ProActi\
ve/classes/org/objectweb/proactive/examplescomponents/helloworld/deployment\
.xml ********************
06 created VirtualNode name=VN1
07 created VirtualNode name=VN2
08 created VirtualNode name=VN3
09 **** Starting jvm on crusoe.inria.fr
10 --&gt; This ClassFileServer is reading resources from classpath
11 Jini enabled
12 Ibis enabled
13 Detected an existing RMI Registry on port 1099
14 //crusoe.inria.fr/VN1462549848 successfully bound in registry at //cruso\
e.inria.fr/VN1462549848
15 **** Mapping VirtualNode VN1 with Node: //crusoe.inria.fr/VN1462549848 d\
one
16 Generating class : pa.stub.org.objectweb.proactive.examples.components.h\
elloworld.Stub_ClientImpl
17 **** Starting jvm on crusoe.inria.fr
18 --&gt; This ClassFileServer is reading resources from classpath
19 Jini enabled
20 Ibis enabled
21 Detected an existing RMI Registry on port 1099
22 //crusoe.inria.fr/VN21334775605 successfully bound in registry at //crus\
oe.inria.fr/VN21334775605
23 **** Mapping VirtualNode VN2 with Node: //crusoe.inria.fr/VN21334775605 \
done
24 Generating class : pa.stub.org.objectweb.proactive.examples.components.h\
elloworld.Stub_ServerImpl
25 //crusoe.inria.fr/Node1145479146 successfully bound in registry at //cru\
soe.inria.fr/Node1145479146
26 Generating class : pa.stub.org.objectweb.proactive.core.component.type.S\
tub_Composite
27 MOPClassLoader: class not found, trying to generate it
28 ClassServer sent class Generated_java_lang_Runnable_r_representative suc\
cessfully
39 MOPClassLoader: class not found, trying to generate it
30 ClassServer sent class Generated_java_lang_Runnable_r_representative suc\
cessfully
31 MOPClassLoader: class not found, trying to generate it
32 ClassServer sent class Generated_org_objectweb_proactive_examples_compon\
ents_helloworld_Service_s_representative successfully
33 MOPClassLoader: class not found, trying to generate it
34 ClassServer sent class Generated_org_objectweb_proactive_examples_compon\
ents_helloworld_ServiceAttributes_attribute_controller_representative succe\
ssfully
35 ClassServer sent class pa.stub.org.objectweb.proactive.examples.componen\
ts.helloworld.Stub_ServerImpl successfully
</screen>
        <para>What is new is :</para>
        <itemizedlist>
          <listitem>
            <para> line 05 the parsing of the deployment descriptor</para>
          </listitem>
          <listitem>
            <para> line 09 and 17 : the creation of 2 virtual machines on the host
 &quot;crusoe.inria.fr&quot;</para>
          </listitem>
          <listitem>
            <para> line 15 and 24 : the mapping of virtual nodes VN1 and VN2 to the nodes specified in the
 deployment descriptor</para>
          </listitem>
          <listitem>
            <para> line 35 : the dynamic downloading of the stub class for ServerImpl: the stub class loader
 does not find the classes of the stubs in the current VM, and fetches the classes from the
 ClassServer</para>
          </listitem>
          <listitem>
            <para> line 28, 30, 32, 34 : the dynamic downloading of the classes corresponding to the
 components functional interfaces (they were silently generated)</para>
          </listitem>
</itemizedlist>
        <para>Then we get the same output than for a local deployment, the activity of active objects is
 independent from its location.</para>
<screen>
01 Server: print method called
02 at org.objectweb.proactive.examples.components.helloworld.ServerImpl.pri\
nt(ServerImpl.java:37)
03 at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
04 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.\
java:39)
05 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces\
sorImpl.java:25)
06 at java.lang.reflect.Method.invoke(Method.java:324)
07 at org.objectweb.proactive.core.mop.MethodCall.execute(MethodCall.java:3\
73)
08 at org.objectweb.proactive.core.component.request.ComponentRequestImpl.s\
erveInternal(ComponentRequestImpl.java:163)
09 at org.objectweb.proactive.core.body.request.RequestImpl.serve(RequestIm\
pl.java:108)
10 at org.objectweb.proactive.core.body.BodyImpl$ActiveLocalBodyStrategy.se\
rve(BodyImpl.java:297)
11 at org.objectweb.proactive.core.body.AbstractBody.serve(AbstractBody.jav\
a:799)
12 at org.objectweb.proactive.core.body.ActiveBody$FIFORunActive.runActivit\
y(ActiveBody.java:230)
13 at org.objectweb.proactive.core.body.ActiveBody.run(ActiveBody.java:145)
14 at java.lang.Thread.run(Thread.java:534)
15 Server: begin printing...
16 -&gt;hello world
17 Server: print done.
</screen>
      </sect2>
      <sect2 remap="h3" id="HelloWorldADLFiles">
       <title>The HelloWorld ADL files</title>
      
       <para>
 <anchor id="distributed-wrappers-fractal" />
org.objectweb.proactive.examples.components.helloworld.helloworld-distributed-wrappers.fractal
</para>
<screen>
 1:&lt;?xml version="1.0" encoding="ISO-8859-1" ?>
 2:&lt;!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN"
 3:            "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd">
 4:
 5:&lt;definition name="org.objectweb.proactive.examples.components.helloworld.helloworld-distributed-wrappers">
 6:  &lt;interface name="r" role="server" signature="java.lang.Runnable"/>
 7:    &lt;exportedVirtualNodes>
 8:        &lt;exportedVirtualNode name="VN1">
 9:            &lt;composedFrom>
 10:               &lt;composingVirtualNode component="client" name="client-node"/>
 11:            &lt;/composedFrom>
 12:        &lt;/exportedVirtualNode>
 13:        &lt;exportedVirtualNode name="VN2">
 14:            &lt;composedFrom>
 15:                &lt;composingVirtualNode component="server" name="server-node"/>
 16:            &lt;/composedFrom>
 17:        &lt;/exportedVirtualNode>
 18:    &lt;/exportedVirtualNodes>
 19:  &lt;component name="client-wrapper"
 20:              definition="org.objectweb.proactive.examples.components.helloworld.ClientType">
 21:      &lt;component name="client"
 22:                 definition="org.objectweb.proactive.examples.components.helloworld.ClientImpl"/>
 23:      &lt;binding client="this.r" server="client.r"/>
 24:      &lt;binding client="client.s" server="this.s"/>
 25:      &lt;controller desc="composite"/>
 26:  &lt;/component>
 27:  &lt;component name="server-wrapper"
 28:             definition="org.objectweb.proactive.examples.components.helloworld.ServerType">    
 29:      &lt;component name="server"
 30:                 definition="org.objectweb.proactive.examples.components.helloworld.ServerImpl"/>
 31:      &lt;binding client="this.s" server="server.s"/>
 32:      &lt;controller desc="composite"/>
 33:  &lt;/component>
 34:  &lt;binding client="this.r" server="client-wrapper.r"/>
 35:  &lt;binding client="client-wrapper.s" server="server-wrapper.s"/>
 36:&lt;/definition>
</screen >

<para>
 <anchor id="ClientType-fractal" />
 org.objectweb.proactive.examples.components.helloworld.ClientType.fractal
</para>
<screen>
 1:&lt;?xml version="1.0" encoding="ISO-8859-1" ?>
 2:&lt;!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN"
 3:            "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd">
 4:
 5:&lt;definition name="org.objectweb.proactive.examples.components.helloworld.ClientType"
 6:              extends="org.objectweb.proactive.examples.components.helloworld.RootType">
 7:    &lt;interface name="r" role="server" signature="java.lang.Runnable"/>
 8:    &lt;interface name="s" role="client"
 9:                 signature="org.objectweb.proactive.examples.components.helloworld.Service"/>
 10:&lt;/definition>
</screen>

<para>
 <anchor id="ClientImpl-fractal" />
  org.objectweb.proactive.examples.components.helloworld.ClientImpl.fractal
 </para>
<screen>
  1:&lt;?xml version="1.0" encoding="ISO-8859-1" ?>
  2:&lt;!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN"
  3:            "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd">
  4:
  5:&lt;definition name="org.objectweb.proactive.examples.components.helloworld.ClientImpl"
  6:              extends="org.objectweb.proactive.examples.components.helloworld.ClientType">
  7:    &lt;exportedVirtualNodes>
  8:        &lt;exportedVirtualNode name="client-node">
  9:            &lt;composedFrom>
  10:                &lt;composingVirtualNode component="this" name="client-node"/>
  11:            &lt;/composedFrom>
  12:        &lt;/exportedVirtualNode>
  13:    &lt;/exportedVirtualNodes>
  14:    &lt;content class="org.objectweb.proactive.examples.components.helloworld.ClientImpl"/>
  15:    &lt;virtual-node name="client-node" cardinality="single"/>
  16:&lt;/definition>
</screen>
 
<para>
 <anchor id="ServerType-fractal" />
 org.objectweb.proactive.examples.components.ServerType
</para>
<screen> 
1:&lt;?xml version="1.0" encoding="ISO-8859-1" ?>
2:&lt;!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN"
3:            "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd">
4:
5:&lt;definition name="org.objectweb.proactive.examples.components.helloworld.ServerType">
6:  &lt;interface name="s" role="server"
7:          signature="org.objectweb.proactive.examples.components.helloworld.Service"/>
8:&lt;/definition>
</screen>
  
 
 <para>
  <anchor id="ServerImpl-fractal" />
 org.objectweb.proactive.examples.components.helloworld.ServerImpl
</para>
<screen>
1:&lt;?xml version="1.0" encoding="ISO-8859-1" ?>
2:&lt;!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN"
3:        "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd">
4:
5:&lt;definition name="org.objectweb.proactive.examples.components.helloworld.ServerImpl"
6:       extends="org.objectweb.proactive.examples.components.helloworld.ServerType">
7:    &lt;exportedVirtualNodes>
8:        &lt;exportedVirtualNode name="server-node">
9:            &lt;composedFrom>
10:                &lt;composingVirtualNode component="this" name="server-node"/>
11:            &lt;/composedFrom>
12:        &lt;/exportedVirtualNode>
13:    &lt;/exportedVirtualNodes>
14:  &lt;content class="org.objectweb.proactive.examples.components.helloworld.ServerImpl"/>
15:  &lt;attributes signature="org.objectweb.proactive.examples.components.helloworld.ServiceAttributes">
16:    &lt;attribute name="header" value="->"/>
17:    &lt;attribute name="count" value="1"/>
18:  &lt;/attributes>
19:  &lt;controller desc="primitive"/>
20:  &lt;virtual-node name="server-node" cardinality="single"/>
21:&lt;/definition>
</screen>
      </sect2>
     </sect1>
    <sect1 remap="h2">
      <title><anchor id="examples_html_The_Comanche_example"/>The Comanche
 example</title>
      <para><ulink url="http://fractal.objectweb.org/tutorial/index.xml">The Comanche
 example</ulink> is a nice introduction to component based development with Fractal. It explains how
 to design applications using components, and how to implement these applications using the
 Fractal API.</para>
      <para>You will notice that the example presented in this tutorial is based on
 Comanche, a simplistic http server. However, this example extensively uses reference passing
 through components. For example <literal>Request</literal> objects are passed by reference. This is
 incompatible with the ProActive programming model, where, to avoid shared passive objects, all
 passive objects passed to active objects are actually <emphasis role="bold">passed by copy</emphasis>(see <ulink url="http://www-sop.inria.fr/oasis/proactive/doc/api/org/objectweb/proactive/ProActiveBasis.xml">
 ProActive basis</ulink>). As active objects are themselves passed by reference, one could argue that
 we could turn some passive object into active objects. This would allow remote referencing
 through stubs. Unfortunately, for reasons specific to the Sockets and Streams implementations,
 (Socket streams implementations do not provide empty no-arg constructors), it is not easily
 possible to encapsulate some of the needed resource classes into active objects.</para>
    </sect1>
    <sect1 remap="h2">
      <title><anchor id="examples_html_The_C3D_example_turning_Active_Objects_into_Components"/>C3D - from Active Objects to
 Components</title>
      <sect2 remap="h3">
        <title>Reason for this example</title>
        <para>This is an example of an application that is refactored to fit the
 components dogma. The standard C3D example has been taken as a basis, and component wrappers have
 been created. This way, one can see what is needed to transform an application into
 component-oriented code.</para>
        <para>You may find the code in the <ulink url="../doc/ProActive_src_html/org.objectweb.proactive.examples.components.c3d.index.xml">examples/components/c3d</ulink>
 directory of the proactive source.</para>
      </sect2>
      <sect2 remap="h3">
        <title>Using working C3D code with components</title>
        <para>
          <informalfigure>
            <mediaobject>
              <imageobject>
                <imagedata width="6in" fileref="components/pics/C3D-Components-UML.png" format="PNG"/>              </imageobject>
              <imageobject>
                <imagedata width="6in" fileref="components/pics/C3D-Components-UML.svg" format="SVG"/>              </imageobject>
            </mediaobject>
          </informalfigure>
</para>
        <para>We consider the working C3D application. It&#39;s nice, and has a sleak GUI, but we now want
 to add component power to it! What we do is shown on the image to the right: add wrappers around
 the original object classes (C3D*) and instead of linking the classes together by setting fields
 through the initial methods, do that in the binding methods. In other words, we have to spot
 exactly where C3DRenderingEngine, C3DUser and C3DDispatcher are used by a class other than
 itself, and make theses references component bindings. Of course, we also have to expose the
 interfaces that we are goining to use, hence the Dispatcher, Engine and User interface that have
 to be implemented.</para>
        
      </sect2>
      <sect2 remap="h3">
        <title>How the application is written</title>
        <para>First of all, have a look at the doc on <ulink url="c3d.xml">C3D</ulink> to remember how this
 application is written. Most important is the class diagram, showing C3DUser, C3DDispatcher and
 C3DRederingEngine. We decided that the only objects worth wrapping in components were those
 three. The rest is too small to be worth the hassle.</para>
        <sect3 remap="h4">
          <title>Creating the interfaces</title>
          <para>What we need to do is to extract the interfaces of the Objects, ie the which methods are going
 to be called on the components. This means find out what methods are called from outside the
 Active Object. You can do that by searching in the classes where the calls are made on active
 objects. For this, <emphasis role="bold">you have to know in detail which classes are going to be turned into
 component</emphasis>. We have done that, and those exposed methods are put in the interfaces User,
 Engine and Dispatcher.</para>
          <para><emphasis role="bold">Tricky part:</emphasis> whatever way you look at components, you&#39;ll have to modify the initial
 code if these interfaces were not created at first go. You have to replace all the classes by
 their interface, when you use them in other files. If we had not already used interfaces in the
 C3D Objecct code, we would have had to replace all occurrences of C3DDispatcher by occurrences of
 Dispatcher.</para>
          <para>Why do we have to do that, replacing classes by interfaces? That&#39;s due to the way
 components work. When the components are going to be bound, you&#39;re not binding the class
 themselves, but proxies to these classes. And these proxies implement the interfaces, and do not
 extend the classes.</para>
</sect3>
        <sect3 remap="h4">
          <title>Creating the Component Wrappers</title>
          <para>You now have to create a class that englobes the previous Active Objects, and which is a
 composent representing the same functionality. How do you do that? Pretty simple. All you need to
 do is extend the Active Object class, and add to it the non-functional interfaces which go with
 the component. You have the binding interfaces to create, which basically say how to put together
 two Components, tell who is already attached, and how to separate them. These are the <literal>lookupFc</literal>, <literal>bindFc</literal>, <literal>unbindFc</literal>, and <literal>listFc</literal>
 methods.</para>
          <para>This has been done in the *Impl files. Have a peek, for example, at <ulink url="../doc/ProActive_src_html/org.objectweb.proactive.examples.c3d.UserImpl.xml">UserImpl.java</ulink>.
 What you have here are those component methods. Be even more careful with this <literal>bindFc</literal> method. In fact, it really binds the protected Dispatcher variable <literal>c3ddispatcher</literal>. This way, the C3DUser code can now use this varaible as if it was
 addressing the real Active Object. Just to be precise, we have to point out that you&#39;re going
 through proxies before reaching the Component, then the Active Object. But this is hidden by the
 ProActive layer, all you should know is you&#39;re addressing a Dispatcher, and you&#39;re
 fine!</para>
</sect3>
        <sect3 remap="h4">
          <title>Discarding direct reference acknowledgment</title>
          <para>If you&#39;re out of luck, the code contains instructions to retain references to objects that
 call methods on the current Object. These methods have a signature ressembling <literal>method(...,
 ActiveObject ao, ...)</literal>. This is called, in ProActive, with a <literal>ProActive.getStubOnThis()</literal> (if you don&#39;t, and instead use &#39;this&#39;, the
 code won&#39;t work correctly on remote hosts!). If the local object uses this <literal>ProActive.getStubOnThis()</literal>, you&#39;re going to have trouble with components. The
 problem is that this design does not fit the component paradigm : you should be using declared
 interfaces bound with the bind methods, not be passing along references to self. So you have to
 remove these from the code, and make it component-oriented. But remember, <emphasis role="bold">you should be using
 bind methods to attach other components</emphasis>.</para>
</sect3>
      </sect2>
      <sect2 remap="h3">
        <title>ADL</title>
        <para>You may be wanting to see how we have bound the components together, now. Since the design is
 pretty simple, there is not much to it. We have used the fractal ADL, to avoid hard-coding
 bindings. So all of the information here is in the <literal>components/c3d/fractal/</literal>
 directory. There are the components (which interfaces they propose), and a
 &quot;distributed.fractal&quot; file, which is where the bindings are made. It includes the
 creation of a Composite component, just for the fun. You may want to explore it with the Fractal
 GUI provided with IC2D, it&#39;s easier to understand graphically. Here&#39;s the code,
 nevertheless, for you curiosity :</para>
<screen>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;
&lt;!DOCTYPE definition PUBLIC &quot;-//objectweb.org//DTD Fractal ADL 2.0//EN&quot; 
     &quot;classpath://org/objectweb/proactive/core/component/adl/xml/proactive.d\
td&quot;&gt;
&lt;definition name=&quot;org.objectweb.proactive.examples.components.c3d.fractal.dis\
tributed&quot;&gt;
  &lt;interface signature=&quot;java.lang.Runnable&quot; role=&quot;server&quot; name=&quot;r&quot;/&gt;
  &lt;component definition=&quot;org.objectweb.proactive.examples.components.c3d.frac\
tal.UserImpl&quot; name=&quot;user&quot; /&gt;
  &lt;component name=&quot;Composite&quot;&gt;
    &lt;interface signature=&quot;org.objectweb.proactive.examples.c3d.Dispatcher&quot; rol\
e=&quot;server&quot; name=&quot;dispatch&quot;/&gt;
    &lt;component definition=&quot;org.objectweb.proactive.examples.components.c3d.fr\
actal.EngineImpl&quot; name=&quot;engine2&quot;/&gt;
    &lt;component definition=&quot;org.objectweb.proactive.examples.components.c3d.fr\
actal.EngineImpl&quot; name=&quot;engine1&quot;/&gt;
    &lt;component definition=&quot;org.objectweb.proactive.examples.components.c3d.fr\
actal.DispatcherImpl&quot; name=&quot;disp&quot;/&gt;
    &lt;binding client=&quot;this.dispatch&quot; server=&quot;disp.user2dispatcher&quot;/&gt;
    &lt;binding client=&quot;disp.dispatcher2engine00&quot; server=&quot;engine1.dispatcher2engin\
e&quot;/&gt;
    &lt;binding client=&quot;disp.dispatcher2engine01&quot; server=&quot;engine2.dispatcher2engin\
e&quot;/&gt;
  &lt;/component&gt;
  &lt;binding client=&quot;this.r&quot; server=&quot;user.r&quot;/&gt;
  &lt;binding client=&quot;user.user2dispatcher&quot; server=&quot;Composite.dispatch&quot;/&gt;
  &lt;controller desc=&quot;composite&quot;/&gt;
  &lt;coordinates color=&quot;-73&quot; y0=&quot;0.11&quot; x1=&quot;0.30&quot; y1=&quot;0.33&quot; name=&quot;user&quot; x0=&quot;0.03&quot;/&gt;
  &lt;coordinates color=&quot;-73&quot; y0=&quot;0.18&quot; x1=&quot;0.99&quot; y1=&quot;0.98&quot; name=&quot;Composite&quot; x0=&quot;0.32&quot;&gt;
    &lt;coordinates color=&quot;-73&quot; y0=&quot;0.60&quot; x1=&quot;0.84&quot; y1=&quot;0.89&quot; name=&quot;engine2&quot; x0=&quot;0.23&quot;/&gt;
    &lt;coordinates color=&quot;-73&quot; y0=&quot;0.15&quot; x1=&quot;0.99&quot; y1=&quot;0.53&quot; name=&quot;engine1&quot; x0=&quot;0.72&quot;/&gt;
    &lt;coordinates color=&quot;-73&quot; y0=&quot;0.12&quot; x1=&quot;0.67&quot; y1=&quot;0.42&quot; name=&quot;disp&quot; x0=&quot;0.09&quot;/&gt;
  &lt;/coordinates&gt;
&lt;/definition&gt;
</screen>
        <para>Here&#39;s what it looks like when you explore it through the IC2D Component
 explorer 
          <informalfigure>
            <mediaobject>
              <imageobject>
                <imagedata width="6in" fileref="components/pics/c3d_components.png" format="PNG"/>              </imageobject>
              <imageobject>
                <imagedata width="6in" fileref="components/pics/c3d_components.svg" format="SVG"/>              </imageobject>
            </mediaobject>
          </informalfigure>
</para>
      </sect2>
      <sect2 remap="h3">
        <title>Source Code</title>
        <para>You may find the source code of this application at the following locations
 :</para>
        <itemizedlist>
          <listitem>
            <para><ulink url="../doc/ProActive_src_html/org.objectweb.proactive.examples.c3d.index.xml">Active
 Object version</ulink>  ( examples/c3d )</para>
          </listitem>
          <listitem>
            <para><ulink url="../doc/ProActive_src_html/org.objectweb.proactive.examples.components.c3d.index.xml">Component
 version</ulink>  ( examples/components/c3d )</para>
          </listitem>
</itemizedlist>
      </sect2>
    </sect1>
  
</chapter>
