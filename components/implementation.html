<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Component programming with ProActive - perspectives</title>
<link rel="stylesheet" href="../ProActive.css">
</head>
<body style="background-color: white;">
<!--
Header : start
~~~ -->
<table width="100%">
	<tbody>
		<tr>
			<td align="left" valign="middle">
			<table border="1" cellpadding="2" cellspacing="0">
				<tbody>
					<tr>
						<td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1"
							href="../../../../overview-summary.html">back to API</a>&nbsp;&nbsp;</td>
						<td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="../index.html">back to index</a>&nbsp;&nbsp;</td>
						<td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="intro.html">prev</a>&nbsp;&nbsp;</td>
						<td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="conformance.html">next</a>&nbsp;&nbsp;</td>
					</tr>
				</tbody>
			</table>
			</td>
			<td align="right" valign="top"><img src="../ProActiveLogo200x34.gif" alt=""></td>
		</tr>
	</tbody>
</table>
<hr>
<!-- Link to index : end -->

<h1><a name="implementation_of_fractal_with_proactive"></a>An implementation of the Fractal
component model with ProActive</h1>
<p class="textNormal">Fractal defines a general conceptual model, along with a programming
application interface (API) in Java. According to the official documentation, the Fractal component
model is "<i>a modular and extensible component model that can be used with various programming
languages to design, implement, deploy and reconfigure various systems and applications, from
operating systems to middleware platforms and to graphical user interfaces</i>".</p>
<p class="textNormal">There is a reference implementation, called Julia.</p>
<p class="textNormal">We first tried to use Julia to manipulate active objects (the fundamental
entities in ProActive), but we wouldn't have been able to reuse the features of the Proactive
library, because of the architectures of the libraries.<br>
Julia manipulates a base class by modifying the bytecode or adding interception objects to it. On
the other hand, ProActive is based on a meta-object protocol and provides a reference to an active
object through a typed stub. If we wanted to use active objects with Julia, the Julia runtime would
try to manipulate the stub, and not the active object itself. And if trying to force Julia to work
on the same base object than ProActive, the control flow could not traverse both ProActive and
Julia.<br>
Eventually, re-implementing ProActive using Julia could be a solution (a starting point could be the
"protoactive" example of Julia), but this would imply a full refactoring of the library, and
therefore quite a few resources...<br>
More generally speaking, Julia is designed to work with standard objects, but not with the active
objects of ProActive. Some features (see next section) would not be reusable using Julia with
ProActive active objects.<br>
Therefore, we had to go for our own implementation.</p>
<p class="textNormal">This implementation is different from Julia both in its objectives and in the
programming technniques. As previously stated, we target Grid and P2P environments. The programming
techniques and the architecture of the implementation is described in a following section.</p>
<h2><a name="Specific_features_of_this_implementation"></a>Specific features of this implementation</h2>
<p class="textNormal">The combination of the Fractal model with the ProActive library leverages the
capabilities of both of them.</p>
<h3>Distribution</h3>
<p>Distribution is achieved in a transparent manner over the Java RMI protocol thanks to the use of
a stub/proxy pattern. Components are manipulated indifferently of their location (local or on a
remote JVM).</p>
<h3>Deployment framework</h3>
<p>ProActive provides a deployment framework for creating a distributed component system. Using a
configuration file and the concept of virtual nodes, this framework :</p>
<ol>
	<li>connects to remote hosts using supported protocols, such as rsh, rlogin, ssh, globus, lsf
	etc...</li>
	<li>creates JVMs on these hosts</li>
	<li>instantiates components on these newly created JVMs</li>
</ol>
<h3>Activities</h3>
<p>A fundamental concept of the ProActive library is this of <a href="../ProActiveBasis.html">active
objects</a>, where activities can actually be <a href="../ActiveObjectCreation.html">redefined </a>so
as to customize their <b>behavior</b>.</p>
<h3>Asynchronous method calls with futures</h3>
<p><a href="../FutureObjectCreation.htmlAsynchronous">Asynchronous method calls with transparent
futures </a>is a core feature of ProActive, and it allows concurrent processing. Indeed, suppose a
caller invokes a method on a callee. This method returns a result on a component. With synchronous
method calls, the flow of execution of the caller is blocked until the result of the method called
is received. In the case of intensive computations, this can be relatively long. With asynchronous
method calls, the caller gets a future object and will continue its tasks until it really uses the
result of the method call. The process is then blocked (it is called wait-by-necessity) until the
result has effectively been calculated.</p>
<!--<LI class="textNormal">typed group communications</LI> -->

<p class="textSmall"><i> </i></p>
<!--
Footer : start
~~~ -->
<br>
<hr>
<div class="textSmall" align="right">Copyright &Acirc;&copy; April 2005 INRIA All Rights Reserved.
<p class="textNormal"></p>
<!-- Footer : end --></div>
</body>
</html>
