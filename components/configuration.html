<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Component programming with ProActive - perspectives</title>
<link rel="stylesheet" href="../ProActive.css">
</head>
<body style="background-color: white;">
<!--
Header : start
~~~ -->
<table width="100%">
	<tbody>
		<tr>
			<td align="left" valign="middle">
			<table border="1" cellpadding="2" cellspacing="0">
				<tbody>
					<tr>
						<td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1"
							href="../../../../overview-summary.html">back to API</a>&nbsp;&nbsp;</td>
						<td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="../index.html">back to index</a>&nbsp;&nbsp;</td>
						<td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="conformance.html">prev</a>&nbsp;&nbsp;</td>
						<td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="adl.html">next</a>&nbsp;&nbsp;</td>
					</tr>
				</tbody>
			</table>
			</td>
			<td align="right" valign="top"><img src="../ProActiveLogo200x34.gif" alt=""></td>
		</tr>
	</tbody>
</table>
<hr>
<!-- Link to index : end -->

<h1><a name="Configuration"></a>Configuration<br>
</h1>
<h2><a name="Controllers_and_interceptors"></a>Controllers and interceptors</h2>
<p>This section explains how to customize the membranes of component through the configuration,
composition and creation of controllers and interceptors.</p>
<h3>Configuration of controllers</h3>
<p>It is possible to customize controllers, by specifying a control interface and an implementation.</p>
<p>Controllers are configured in a simple XML configuration file, which has the following structure
:</p>
<pre class="snippet"><span class="alignleftsnippet">&lt;componentConfiguration&gt;<br> &lt;controllers&gt;<br>   &lt;controller&gt;<br>	&lt;interface&gt;ControllerInterface&lt;/interface&gt;<br>	&lt;implementation&gt;ControllerImplementation&lt;/implementation&gt;<br>   &lt;/controller&gt;<br>...<br></span></pre>
<p>Unless they some controllers are also interceptors (see later on), the controllers do not have to
be ordered.</p>
<p>A default configuration file is provided,&nbsp;it defines the default controllers available for
every ProActive component (super, binding, content, naming, lifecycle and component parameters
controllers).</p>
<p>A custom configuration file can be specified (in this example with "thePathToMyConfigFile") for
any component in the controller description parameter of the <span class="alignleftsnippet">newFcInstance</span>
method from the Fractal API :<br>
</p>
<pre class="snippet"> componentInstance = componentFactory.newFcInstance(<br>   myComponentType,<br>   new ControllerDescription(<br>     "name",<br>     myHierarchicalType,<br>     thePathToMyControllerConfigFile),<br>   myContentDescription);<span
	class="snippet"></span></pre>
<h3>Writing a custom controller</h3>
<p>The controller interface is a standard interface which defines which methods are available.</p>
<p>When a new implementation is defined for a given controller interface, it has to conform to the
following rules :</p>
<ol>
	<li>The controller implementation must extend the AbstractProActiveController class, which is the
	base class for component controllers in ProActive, and which defines the constructor <span
		class="alignleftsnippet">AbstractProActiveController(Component owner).</span></li>
	<li>The controller implementation must override this constructor&nbsp;:</li>
</ol>
<pre class="snippet">public ControllerImplementation(Component owner) {<br> super(owner);<br>}</pre>
<ol start="3">
	<li>The controller implementation must also override the abstract method <span
		class="alignleftsnippet">setControllerItfType()</span>, which sets the type of the controller
	interface :</li>
</ol>
<pre class="alignleftsnippet snippet">protected void setControllerItfType() {<br> try {<br>   setItfType(ProActiveTypeFactory.instance().createFcItfType(<br>     "Name of the controller",<br>     TypeFactory.SINGLE));<br>   } catch (InstantiationException e) {<br>     throw new ProActiveRuntimeException("cannot create controller type : " +<br>       this.getClass().getName());<br>   }<br> }<br></pre>
<ol start="4">
	<li>The controller interface and its implementation have to be declared in the component
	configuration file.</li>
</ol>
<h3>Configuration of interceptors</h3>
<p>Controllers can also act as interceptors : they can intercept incoming invocations and outgoing
invocations. For each invocation, pre and post processings are defined in the methods <span
	class="alignleftsnippet">beforeInputMethodInvocation</span>, <span class="alignleftsnippet">afterInputMethodInvocation</span>,
<span class="alignleftsnippet">beforeOutputMethodInvocation</span>, and <span
	class="alignleftsnippet">afterOutputMethodInvocation</span>. These methods are defined in the
interfaces InputInterceptor and OutputInterceptor, and take a MethodCall object as an argument.
MethodCall objects are reified representations of method invocations, and they contain Method
objects, along with the parameters of the invocation.</p>
<p>Interceptors are configured in the controllers XML configuration file, by simply adding <span
	class="alignleftsnippet">input-interceptor="true"</span> or/and <span class="alignleftsnippet">output-interceptor="true"</span>
as&nbsp;attributes of the controller element in the definition of a controller (provided of course
the specified interceptor is an input or/and output interceptor). For example a controller that
would be an input interceptor and an output interceptor would be defined as follows :</p>
<pre class="snippet">&lt;componentConfiguration&gt;<br> &lt;controllers&gt;<br>	....<br>   &lt;controller <span
	style="color: rgb(255, 0, 0);">input-interceptor="true" output-interceptor="true"</span>&gt;<br>     &lt;interface&gt;InterceptorControllerInterface&lt;/interface&gt;<br>     &lt;implementation&gt;ControllerImplementation&lt;/implementation&gt;<br>   &lt;/controller&gt;<br>...<br></pre>
<p>Interceptors can be composed in a basic manner : sequentially.&nbsp;</p>
<p>For input interceptors, the <span class="alignleftsnippet">beforeInputMethodInvocation</span>&nbsp;
method is called sequentially for each controller in the order they are defined in the controllers
configuration file. The <span class="alignleftsnippet">afterInputMethodInvocation</span> method is
called sequentially&nbsp;for each controller in the <span style="font-weight: bold;">reverse order</span>
they are defined in the controllers configuration file.</p>
<p>If in the controller config file, the list of input interceptors is in this order (the order in
the controller config file is from top to bottom) :<br>
</p>
<pre class="snippet">InputInterceptor1<br>InputInterceptor2<br></pre>
<p>This means that an invocation on a server interface will follow this path :<br>
</p>
<pre class="snippet">--&gt; caller<br>--&gt; InputInterceptor1.beforeInputMethodInvocation<br>--&gt; InputInterceptor2.beforeInputMethodInvocation<br>--&gt; callee.invocation<br>--&gt; InputInterceptor2.afterInputMethodInvocation<br>--&gt; InputInterceptor1.afterInputMethodInvocation<br></pre>
<p>For output interceptors, the&nbsp;beforeOutputMethodInvocation method is called sequentially for
each controller in the order they are defined in the controllers configuration file.
The&nbsp;afterOutputMethodInvocationmethod is called sequentially for each controller in the <span
	style="font-weight: bold;">reverse order</span> they are defined in the<br>
controllers configuration file.</p>
<p>If in the controller config file, the list of input interceptors is in this order (the order in
the controller config file is from top to bottom) :&nbsp;</p>
<pre class="snippet">OutputInterceptor1<br>OutputInterceptor2&nbsp;</pre>
<p>This means that an invocation on a server interface will follow this path&nbsp;<br>
</p>
<pre class="textNormal snippet">--&gt; currentComponent&nbsp;<br>--&gt; OutputInterceptor1.beforeOutputMethodInvocation <br>--&gt; OutputInterceptor2.beforeOutputMethodInvocation <br>--&gt; callee.invocation<br>--&gt; OutputInterceptor2.afterOutputMethodInvocation<br>--&gt; OutputInterceptor1.afterOutputMethodInvocation<br></pre>
<h3>Writing a custom interceptor</h3>
<p>An interceptor being a controller, it must follow the rules explained above for the creation of a
custom controller.</p>
<p>Input interceptors and output interceptors must implement respectively the interfaces <span
	class="alignleftsnippet">InputInterceptor</span> and <span class="alignleftsnippet">OutputInterceptor</span>,
which declare interception methods (pre/post interception) that have to be implemented.</p>
<p>Here is a simple example of an input interceptor :</p>
<pre class="textNormal snippet">public class MyInputInterceptor extends AbstractProActiveController<br> implements InputInterceptor, MyController {<br><br>  public MyInputInterceptor(Component owner) {<br>    super(owner);<br>  }<br>  <br>  protected void setControllerItfType() {<br>    try {<br>      setItfType(ProActiveTypeFactory.instance().createFcItfType("my controller",<br>        MyController.class.getName(), TypeFactory.SERVER,<br>        TypeFactory.MANDATORY, TypeFactory.SINGLE));<br>    } catch (InstantiationException e) {<br>      throw new ProActiveRuntimeException("cannot create controller " +<br>        this.getClass().getName());<br>    }<br>  }<br><br>  // foo is defined in the MyController interface<br>  public void foo() {<br>    // foo implementation<br>  }<br><br>  public void afterInputMethodInvocation(MethodCall methodCall) {<br>    System.out.println("post processing an intercepted an incoming functional invocation");<br>    // interception code<br>  }<br><br>  public void beforeInputMethodInvocation(MethodCall methodCall) {<br>    System.out.println("pre processing an intercepted an incoming functional invocation");<br>    // interception code<br>&nbsp;}<br>}<br></pre>
<p>The configuration file would state :</p>
<pre class="snippet">&lt;componentConfiguration&gt;<br> &lt;controllers&gt;<br>	....<br>   &lt;controller <span
	style="color: rgb(255, 0, 0);">input-interceptor="true"</span>&gt;<br>     &lt;interface&gt;<span
	style="color: rgb(255, 0, 0);">MyController</span>&lt;/interface&gt;<br>     &lt;implementation&gt;<span
	style="color: rgb(255, 0, 0);">MyInputInterceptor</span>&lt;/implementation&gt;<br>   &lt;/controller&gt;<br>   ...<br></pre>
<h2><a name="Lifecycle_:_encapsulation_of_functional_activity_in_component_lifecycle"></a>Lifecycle
: encapsulation of functional activity in component lifecycle</h2>
<p>In this implementation of the Fractal component model, Fractal components are active
objects.&nbsp;Therefore it is possible to redefine their&nbsp;activity. In this context of component
based programming, we call an activity&nbsp;redefined by a user a functional activity.&nbsp;</p>
<p>When a component is instantiated, its lifecycle is in the STOPPED state, and the functional
activity that a user may have redefined is not started yet. Internally, there is a default activity
which handles controller requests in a FIFO order.</p>
<p>When the component is started, its lifecycle goes to the STARTED state, and then the functional
activity is started : this activity is initialized (as defined in InitActive), and run (as defined
in RunActive).</p>
<p>2 conditions are required for a smooth integration between custom management of functional
activities and lifecycle of the component :</p>
<ol>
	<li>the control of the request queue must use the org.objectweb.proactive.Service class</li>
	<li>the functional activity must loop on the body.isActive() condition (this is not compulsory, but
	it allows to automatically end the functional activity when the lifecycle of the component is
	stopped. It may also be managed with a custom filter).</li>
</ol>
<p>Control invocations to stop the component will automatically set the isActive() return value to
false, which implies that when the functional activity loops on the body.isActive() condition, it
will end when the lifecycle of the component is set to STOPPED.</p>
<h2><a name="Shortcuts"></a>Shortcuts</h2>
<h3>Principles</h3>
<p>Communications between&nbsp;components in a hierarchical model may involve the crossing of
several membranes, and therefore paying the cost of several indirections. If the invocations are not
intercepted in the membranes, then it is possible to optimize the communication path by shortcutting
: communicating directly from a caller component to a callee component by avoiding indirections in
the membranes.&nbsp;</p>
<p>In the Julia implementation, a shortcut mechanism is provided for components in the same JVM, and
the implementation of this mechanism relies on code generation techniques.</p>
<p>We provide a shortcut mechanism for distributed components, and the implementation of this
mechanism relies on a "tensioning" technique : the first invocation determines the shortcut path,
then the following invocations will use this shortcut path.&nbsp;</p>
<p>For example, in the following pictures, the first invocation from the only client interface of
component in node2&nbsp;follows the standard communication path, as defined during the binding
process, and the invocation eventually reaches the server interface of the component in node 3. If
no interception takes place during the transfer of the invocation, then a shortcut is possible, and
further invocations from the client interface of component in node2 will go directly to the server
interface of the component in node 3.</p>
<p></p>
<table style="text-align: left; width: 420px; height: 210px;" border="0" cellpadding="2"
	cellspacing="2">
	<tbody>
		<tr>
			<td style="text-align: center;">
			<p><img style="width: 400px; height: 186px;" alt="configuration without shortcuts"
				src="pics/remote-components-no-shortcuts.png"></p>
			</td>
			<td><img style="width: 400px; height: 186px;" alt="configuration with shortcut"
				src="pics/remote-components-with-shortcuts.png"></td>
		</tr>
		<tr>
			<td style="text-align: center;"><span class="legend">a configuration without shorctut</span></td>
			<td style="text-align: center;"><span class="legend">a configuration with shorctut between the
			components in node2 and node3</span></td>
		</tr>
	</tbody>
</table>
<h3>Configuration</h3>
<p>Shortcuts are available when composite components are synchronous components (this does not break
the ProActive&nbsp;model, as composite components are structural components). Components can be
specified as synchronous in the ControllerDescription object that is passed to the component factory
:</p>
<p><span class="snippet">ControllerDescription controllerDescription =&nbsp;<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; new ControllerDescription("name",
Constants.COMPOSITE, <span style="color: rgb(255, 0, 0);">Constants.SYNCHRONOUS</span>);</span></p>
<p>When the system property <span class="alignleftsnippet">proactive.components.use_shortcuts</span>
is set to <span class="alignleftsnippet">true</span>, the component system will automatically
establish shortcuts between components whenever possible.</p>
<p></p>

<p class="textSmall"><i> </i></p>
<!--
Footer : start
~~~ -->
<br>
<hr>
<div class="textSmall" align="right">Copyright &Acirc;&copy; April 2005 INRIA All Rights Reserved.
<p class="textNormal"></p>
<!-- Footer : end --></div>
</body>
</html>
