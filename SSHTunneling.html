<!-- saved from url=(0022)http://internet.e-mail -->
<html>
<head>
<title>Using SSH Tunneling for RMI or HTTP communications</title>
<link rel="stylesheet" href="ProActive.css">
</head>
<body bgcolor="white">

<!--
 Header : start 
~~~ -->
<table width="100%">
<tr>
<td align="left" valign="middle">
    <table cellpadding="2" cellspacing="0" border="1">
    <tr>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="../../../../overview-summary.html">back to API</a>&nbsp;&nbsp;</td>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="index.html">back to index</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="Descriptor.html">prev</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="AC.html">next</a>&nbsp;&nbsp;</td>
    </tr>
    </table>
</td>
<td  align="right" valign="top">
<img src="ProActiveLogo200x34.gif"/>
</td>
</tr>
</table>
<hr>
<!-- Link to index : end -->

<h1>Using SSH tunneling for RMI or HTTP communications</h1>


<h2>Overview</h2>
<p class="textNormal">
 ProActive allows users to <b>tunnel</b> all of their RMI or HTTP communications over <b>SSH</b>: it is possible to specify in ProActive deployment descriptors which JVMs
should <b>export</b> their RMI objects through a SSH tunnel.</p>
<p class="textNormal">
This kind of feature is useful for two reasons:
<ul class="listWithSpace">
	<li class="textNormal">it might be necessary to encrypt the RMI communications to improve
     the RMI security model.</li>
     <li class="textNormal"> the configuration of the network in which a given ProActive application
     is deployed might contain firewalls which reject or drop direct 
     TCP connections to the machines which host RMI objects. If these machines
     are allowed to received ssh conections over their port 22 (or another port
     number), it is possible to multiplex and demultiplex all RMI connections
     to that host through its ssh port.</li>
</ul>
</p>
 <p class="textNormal">To successfully use this feature with reasonable performance, it is <b>mandatory</b>
to understand:
<ul class="listWithSpace">
	<li class="textNormal">the configuration of the underlying network: <b>location and configuration
   of the firewalls</b>, aso.</li>
     <li class="textNormal">the communication patterns of the underlying ProActive runtime: <b>which
   JVM makes requests to which JVMs.</b></li>
   <li class="textNormal">the communication patterns of your ProActive objects: <b>which object makes 
   requests to which object</b>. For example: A -> B, B -> C, A ->C</li>
</ul>
</p>
<h2>Configuration of the network</h2>
<p class="textNormal">No two networks are alike. The only thing they share is the fact that they 
are all different. Usually, what you must look for is:
<ul class="listWithSpace">
	<li class="textNormal">is A <b>allowed</b> to open a connection to B ?</li>
     <li class="textNormal"> is B <b>allowed</b> to open a connection to A ? (networks are rarely symetric)</li>
</ul>

</p>
<p class="textNormal">
If you use a TCP or a UDP-based communication protocol (ie: RMI is based on 
TCP), these questions can be translated into "what <b>ports</b> on B is A <b>allowed</b> 
to open a connection to ?". Once you have answered this question for all the
hosts used by your application, write down a small diagram which outlines
what kind of connection is possible. For example:
<pre>
  Firewall                         Firewall
     |   *                        *    |
     | ---->     Internet       <----  |
A    | <----                    ---->  |    B
     |   22                       22   |
</pre>
</p>
<p class="textNormal">
This diagram summarizes the fact that host A is protected by a firewall which 
allows outgoing connections without control but allows only incoming connections
on port 22. Host B is also protected by a similar firewall.
</p>
<h2>ProActive runtime communication patterns</h2>
<p class="textNormal">
To execute a ProActive application, you need to <b>"deploy"</b> it. Deployment 
is performed by the ProActive runtime and is configured by the ProActive
deployment descriptor of the initial host. During deployment, each newly-
created ProActive runtime performs a request to the initial ProActive
runtime. The initial runtime also performs at least one request on each
of these distant runtime.
</p>
<p class="textNormal">
This 2-way communication handshake makes it necessary to <b>configure correctly
the network</b> to make sure that the filtering described above does not 
interfere with the normal operation of the ProActive runtimes.
</p>
<h2>ProActive application communication patterns.</h2>
<p class="textNormal">
Once an application is properly deployed, the application objects deployed
by the ProActive runtime start making requests to each other. It is important
to properly identify what object connects to what object to identify
the influence of the network configuration on these communication patterms.
</p>
<h2>ProActive communication protocols</h2>

<p class="textNormal">
Whenever a request is made to a non-local ProActive object, this
request is performed with the communication protocol specified by the 
destination JVM. Namely, each JVM is characterized by a a unique property
named <b>proactive.communication.protocol</b> which is set to one of:
<ul class="listWithSpace">
	<li class="textNormal">rmi</li>
     <li class="textNormal"> http</li>
      <li class="textNormal"> rmissh</li>
      <li class="textNormal">ibis</li>
     <li class="textNormal"> jini</li>
</ul>
</p>
<p class="textNormal">
This property uniquely identifies the protocol which is used
by each client of the JVM to send data to this JVM. To use different
protocols for different JVMs, two solutions exist:
<ul class="listWithSpace">
	<li class="textNormal">one is to edit the <b>ProActive
deployment descriptors</b> and to pass the property as a command-line 
option to the JVM:</li> 
<b><pre>
&lt;jvmParameters&gt;
    &lt;parameter value="-Dproactive.communication.protocol=rmissh"/&gt;
&lt;/jvmParameters&gt;
</pre>
</b>
<li class="textNormal">the other one is to set in the <b>ProActive Configuration file</b>(introduced in a previous chapter) on the remote host the property proactive.communication.protocol to the desired protocol
<b><pre>&lt;prop <b>key</b>="proactive.communication.protocol" <b>value</b>="rmissh"/&gt;</pre></b>
</li> 
</ul>
</p>

<p class="textNormal">
Finally, if you want to set this property on the <b>initial</b> deployment 
JVM (the JVM that starts the application), you will need to specify the -Dproactive.communication.protocol=rmissh
argument yourself on the JVM command line. 
</p>
<h2>The rmissh communication protocol.</h2>
<p class="textNormal">
This protocol is a bit special because it keeps a lot of compatibility
with the rmi protocol and a lot of options are available to <b>"optimize"</b>
it.
</p>
<p class="textNormal">
This protocol can be used to automatically <b>tunnel</b> all RMI communications
through SSH tunnels. Whenever a client wishes to access a distant rmissh
server, rather than connecting directly to the distant server, it first
creates a SSH tunnel (so-called port-forwarding) from a random port 
locally to the distant server on the distant host/port. Then, all it
has to do to connect to this server is to pretend this server is listening
on the local random port choosen by the ssh tunnel. The ssh daemon
running on the server host receives the data for this tunnel, decapsulates
it and forwards it to the real server.
</p>
<p class="textNormal">
Thus, whenever you request that a JVM be accessed only through rmissh
(namely, whenever you set its <b>proactive.communication.protocol to rmissh</b>),
you need to make sure that an ssh daemon is running on its host. ProActive
uses the <b>jsch</b> client ssh library to connect to this daemon.
</p>
<p class="textNormal">
The properties you can set to configure the behavior of the ssh tunneling 
code are listed below. All these properties are client-side properties:
<ul class="listWithSpace">
	<li class="textNormal"><b>proactive.ssh.port</b>: the port number on which all the ssh daemons to
    which this JVM must connect to are expected to listen. If this property 
    is not set, the default is 22.</li>
     <li class="textNormal"><b>proactive.ssh.username</b>: the username which will be used during
    authentication with all the ssh daemons to which this JVM will need to
    connect to. If this property is not set, the default is the user.name 
    java property.</li>
     <li class="textNormal"><b>proactive.ssh.known_hosts</b>: a filename which identifies the file
    which contains the traditional ssh known_hosts list. This list of hosts
    is used during authentication with each ssh daemon to which this JVM
    will need to connect to. If the host key does not match the one stored
    in this file, the authentication will fail. If this property is not
    set, the default is System.getProperty ("user.home") + "/.ssh/known_hosts"</li>
     <li class="textNormal"><b>proactive.ssh.key_directory</b>: a directory which is expected to contain
    the pairs of public/private keys used during authentication. the private
    keys must not be encrypted. The public keys filenames must match "*.pub".
    Private keys are ignored if their associated public key is not present.
    If this property is not set, the default is 
    System.getProperty ("user.home") + "/.ssh/"</li>
     <li class="textNormal"><b>proactive.tunneling.try_normal_first</b>: if this property is set to "yes",
    the tunneling code always attempts to make a direct rmi connection to
    the remote object before tunneling. If this property is not set, the 
    default is not to make these direct-connection attempts.
    This property is especially useful if you want to deploy a number of 
    objects on a LAN where only one of the hosts needs to run with the rmissh
    protocol to allow hosts outside the LAN to connect to this frontend host.
    The other hosts located on the LAN can use the try_normal_first property
    to avoid using tunneling to make requests to the LAN frontend.</li>
     <li class="textNormal"><b>proactive.tunneling.connect_timeout</b>: this property specifies how long
    the tunneling code will wait while trying to establish a connection to a
    remote host before declaring that the connection failed. If this property
    is not set, the default value is 2000ms.</li>
     <li class="textNormal"><b>proactive.tunneling.use_gc</b>: if this property is set to "yes", the client
    JVM does not destroy the ssh tunnels are soon as they are not used anymore.
    They are queued into a list of unused tunnels which can be reused. If this
    property is not set or is set to another value, the tunnels are destroyed
    as soon as they are not needed anymore by the JVM.</li>
     <li class="textNormal"><b>proactive.tunneling.gc_period</b>: this property specifies how long the
    tunnel garbage collector will wait before destroying a unused tunnel. If
    a tunnel is older than this value, it is automatically destroyed. If this
    property is not set, the default value is 10000ms.</li>    
</ul>
</p>
<p class="textNormal">
Note that the use of SSH tunneling over RMI still allows dynamic classloading through HTTP. For the dynamic classloading our protocol creates an SSH tunnel over HTTP, in order to get missing classes.
It is also important to notice that all you have to do in order to use SSH tunneling is to set the <b>proactive.communiaction.protocol</b> property  to <b>rmissh</b> and to use the related properties if needed(in major cases default behavior is sufficient), ProActive takes care of everything else. 
</p>
<!--
 Footer : start 
~~~ -->
<br><hr><div align="right" class="textSmall">Copyright &#169; April 2005 INRIA All Rights Reserved.</p>
<!-- Footer : end -->
</body>
</html>
