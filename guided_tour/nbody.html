<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>ProActive guided tour</title>
  <link href="../ProActive.css" rel="stylesheet">
</head>
<body style="background-color: rgb(255, 255, 255);">
<!--
 Header : start
~~~ -->
<table width="100%">
  <tbody>
    <tr>
      <td align="left" valign="middle">
      <table border="1" cellpadding="2" cellspacing="0">
        <tbody>
          <tr>
            <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1"
 href="../../../../../overview-summary.html">back
to API</a>&nbsp;&nbsp;</td>
            <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1"
 href="../index.html">back
to index</a>&nbsp;&nbsp;</td>
            <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1"
 href="index.html">back
to guided tour index</a>&nbsp;&nbsp;</td>
            <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2"
 href="OOSPMDJacobiexample.html">prev</a>&nbsp;&nbsp;</td>
            <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2"
 href="conclusion.html">next</a>&nbsp;&nbsp;</td>
          </tr>
        </tbody>
      </table>
      </td>
      <td align="right" valign="top"> <a
 href="http://www-sop.inria.fr/oasis/ProActive/"><img
 src="../ProActiveLogo200x34.gif" border="0" height="34" width="200"></a>
      </td>
    </tr>
  </tbody>
</table>
<hr>
<h1>4.0. The nbody example<br>
</h1>




<h2>Using facilities provided by
ProActive on a complete example</h2>
<h3 class="textNormal">1
Rationale<br>
</h3>
<p>This section of the guided tour goes through the different steps that could
take you to writing an application with ProActive, from a simple design, to a
more complicated structure. This is meant to help you get familiar with the
Group facilities offered by ProActive. Please take note that this page tries
to take you through the progression, step by step. You may find some <a
href="http://www-sop.inria.fr/oasis/proactive/apps/nbody.html">more
information</a>, mainly on the design, on the web page of the <a
href="http://www-sop.inria.fr/oasis/proactive/apps/">
applications/examples</a><a> of proactive. This is a snapshot of the ProActive
nbody example running on 3 hosts with 8 bodies:<BR><BR>

<div align="center">
      <img src="./pics/nbody/gui.jpg">
</div>


</a></p>
<p>
<a>n-body is a classic problem. It
consists in working out the position of
bodies in space, which depend only on the gravitational forces that
apply to them. A good introduction to the problem is given </a><a
 href="http://www.cs.berkeley.edu/%7Esouravc/cs267/nbody.htm">here</a>.
You may find a detailled explanation of the underlying mathematics <a
 href="http://members.fortunecity.com/kokhuitan/nbody.html">here</a>.
Different ways of finding numerical solutions are given <a
 href="http://www.amara.com/papers/nbody.html">here</a>.
</p>
<p>
In short, one considers several bodies (sometimes called particles) in
space, where the only force is due to gravity. When only two bodies are
at hand, this is expressed as </p>
<div style="text-align: center;">
<table style="text-align: left; width: 100%; height: 456px;" border="0"
 cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td>
      <div style="text-align: center;"><img
 style="width: 230px; height: 51px;" alt=""
 src="pics/nbody/forces_simple.gif"><br>
      </div>
      <p> <span style="font-style: italic;">F</span><sub
 style="font-style: italic;">p-&gt;b</sub>
is the force that <span style="font-style: italic;">p</span>
applies on <span style="font-style: italic;">b</span>, <span
 style="font-style: italic;">G</span>
is the gravitational constant,<span style="font-style: italic;"> m</span><sub
 style="font-style: italic;">p</sub><span style="font-style: italic;">
m</span><sub style="font-style: italic;">b</sub>
describe the mass of the bodies, <span style="font-style: italic;">r</span>
is the distance between <span style="font-style: italic;">p</span>
and <span style="font-style: italic;">b</span>,
and<span style="font-style: italic;">
u</span> is a unit vector in the
direction going from <span style="font-style: italic;">p</span>
to <span style="font-style: italic;">b</span>.
When we consider all the forces that apply to one given body, we have
to sum
up the contribution of all the other bodies : </p>
      <div style="text-align: center;"><img
 style="width: 183px; height: 54px;" alt=""
 src="pics/nbody/forces_sum.gif"> <br>
      </div>
      <p>This
should be read as : the total force on the body <span
 style="font-style: italic;">p</span>
is the sum of all the forces between <span style="font-style: italic;">b</span>
and all the other bodies in the system.<br>
This
is the force that has to be computed for every body in the system. With
this
force, using the the usual physics formulae, <br>
      </p>
      <div style="text-align: center;"><img
 style="width: 88px; height: 32px;" alt="" src="pics/nbody/acc.gif"><br>
      </div>
      <p class="textNormal">one
may now compute the movement of a particle for a given time step
(<span style="font-style: italic;">a</span>
the acceleration, <span style="font-style: italic;">v</span>
the velocity, <span style="font-style: italic;">x</span>
the position, <span style="font-style: italic;">t</span>
the time):<br>
      </p>
      <div style="text-align: center;"><img
 style="width: 237px; height: 70px;" alt=""
 src="pics/nbody/movement_equations.gif"><br>
      </div>
      </td>
      <td><img style="width: 150px; height: 300px;" alt=""
 src="pics/nbody/interactions.gif"><br>
      </td>
    </tr>
  </tbody>
</table>
</div>
<h3 class="textNormal">2
Source files: ProActive/src/org/objectweb/proactive/examples/nbody</h3>
<p>
This guided tour is based on the files you may find in the directory
ProActive/src/org/objectweb/proactive/examples/nbody. You'll find the
following tree: </p>
<img style="width: 130px; height: 120px;" alt=""
 src="pics/nbody/directory.jpg"><br>
<br>
<p>The common directory contains
files reused through the different
version. 'simple' is the simplest example, groupcom is the first
example with Group communication, and 'groupdistrib' and 'groupoospmd'
are two enhancement based on different synchronization schemes.
'barneshut' is a bit special, in that it contains a different algorithm
to solve the nbody problem. <br>
</p>
<h3 class="textNormal">3
common</h3>
<p>The
files contained in 'common'
are those that are reused throughout
the different versions.&nbsp; Let's see what they do:<br>
</p>
<ul>
  <li>First of all there are the
two files
called Displayer.java and NBodyFrame.java. These handle the graphical
output of the bodies, as they move about in space. They are not
specially of interest, as GUI is not the point of this tutorial.
Nonetheless, please note that the important method here is
    <p class="textNormal"> <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
public
void drawBody(int x, int y, int vx, int vy, int weight, int d,
int id) ;</code></p>
Taking position, velocity, diameter and unique identifier of a body, it
updates the display window. </li>
  <br>
  <li>Then, we have the files
Force.java and Planet.java. They are used to compute the interaction
between two distant bodies in the universe. Since they are in the
common
directory, they can be modified to include other forces (for example,
collision) in a simple manner, which would be spread to all the
examples. A Planet is no more than a point in
space, with velocity and mass - the diameter expresses the size to use
for the display:
    <p class="textNormal"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
public
class Planet <span style="color: rgb(0, 121, 0);">implements
Serializable</span>{<br>
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
public
double mass;<br>
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
public
double x,y,vx,vy;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
position and velocity<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
public
double diameter;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //
diameter of the body,
used by the Displayer <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...</code></p>
Please take note that it implements Serializable because it will be
sent as parameter to method calls on Active Objects, but it is good
practice to have <span style="font-weight: bold;">all</span>
your ProActive classes implement Serializable. For example, migration
requires everything to implement it, fault-tolerance also....
    <p>The Force class is just the
implementation of what a physical force
really is. It is the implementation of a 2D vector, with the
method add following the physics rule <br>
    </p>
    <div style="text-align: center;"><img
 style="width: 230px; height: 51px;" alt=""
 src="pics/nbody/forces_simple.gif"><span style="color: rgb(255, 0, 0);">
    </span><br>
    </div>
  </li>
  <li>Point2D.java and
Rectangle.java are helper files. They simply implement what a point in
space looks like, and what a rectangle is. They were created to avoid
the trouble of using the standard java java.awt.geom.Point2D and
java.awt.geom.Rectangle2D, which carry a bit too much overhead, and
also to have them Serializable. <span style="color: rgb(255, 0, 0);"></span></li>
  <li>And finally, the Start.java
acts as the wrapper for the main() method. There is a part which reads
command line parameters,&nbsp; counting bodies and iterations,
and&nbsp; constructing the optional Displayer. Before choosing
which example to run, it creates the nodes required by the simulation :
    <br>
    <p class="textNormal"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Construct deployment-related variables: pad &amp; nodes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
staticPad = null;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
VirtualNode vnode;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
try { staticPad = ProActive.getProactiveDescriptor(xmlFileName); }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
catch (ProActiveException e) { abort(e); }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
staticPad.activateMappings();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
vnode = staticPad.getVirtualNode("Workers");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Node[] nodes = null;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
try { <span style="color: rgb(0, 121, 0);">nodes
= vnode.getNodes();</span> }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
catch
(NodeException e) { abort(e); }<br>
    </code></p>
the <code>Node [] nodes</code>
are the different JVMs that were created on possibly different
machines. They are used for Active Object creation. They were specified
in the descriptor used to deploy the application. You may find more
information on these <a
 href="http://www-sop.inria.fr/oasis/proactive/doc/api/org/objectweb/proactive/doc-files/Descriptor.html">
descriptors here</a>, while Active
Object creation is explained in <a
 href="http://www-sop.inria.fr/oasis/proactive/doc/api/org/objectweb/proactive/doc-files/ActiveObjectCreation.html">
this page</a>.
Just as an example, in the
simple package, the Maestro is created on the first of theses JVMs, and
takes three parameters, a <code>Domain
[]</code>, an <code>Integer</code>,
and a <code>Start</code>
(it will be detailed later)
: <br>
    <p class="textNormal"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object [] constructorParams ; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
constructorParams = {domainArray, new Integer(maxIter),
killsupport} ; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
maestro
= (Maestro) ProActive.newActive ( Maestro.class.getName(),
constructorParams , nodes[0] ) ;</code></p>
  </li>
</ul>
<p>The files contained in the
other directories, 'simple', 'groupcom',
'groupdistrib' , 'groupoospmd' , detail steps of increasing complexity,
making the application use different concepts. 'barneshut' contains the
final implementation, featuring the Barnes-Hut algorithm. But let's not
go too fast. Let's have a look at the insides of the simplest
implementation of the n-body problem. <br>
</p>
<h3 class="textNormal">4
simple<br>
</h3>
<p>This is the implementation of
the simplest example of nbody. We defined
the <code>Planet</code>
to be a passive object, and it does nothing. It
is a container for position, velocity and mass, as we've seen in the
description given higher up. The real actors are the <code>Domains</code>,
they do
all the work. To every
<code>Planet</code>
in the universe, is associated a
<code>Domain</code>,
which is an
<code>Active Object</code>.
This&nbsp;
<code>Domain</code>
contains the code to manage the communication of the possitions of the <code>Planets</code>
during the simulation. They are created in the Start.java file : </p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Rectangle
universe = new Rectangle
(-100,-100,100,100);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Domain
[] domainArray = new
Domain
[totalNbBodies];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int&nbsp; i = 0 ; i &lt; totalNbBodies ; i++) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object [] <span style="color: rgb(0, 121, 0);">constructorParams</span>
= new Object [] {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new Integer(i), <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new Planet (universe)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; };<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
try {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Create all the Domains used in the simulation <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
domainArray[i] = (Domain) <span style="color: rgb(0, 121, 0);">ProActive.newActive</span>(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Domain.class.getName(), <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
constructorParams, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nodes[(i+1) % nodes.length]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
catch (ActiveObjectCreationException e) { killsupport.abort(e); } <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
catch
(NodeException e) { killsupport.abort(e);
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</code></p>
<p>See how the call to <code>
ProActive.newActive</code> creates
one new <code>Active Object</code>,
a <code> Domain</code>,
at each iteration of the loop. The parameter <code>nodes</code>
contains all the nodes on which an Active Object may be deployed. The
<code>constructorParams</code>
are the parameters that are to be passed to the constructor of
<code>Domain</code>,
and since it's an <code>Object []</code>
, the parameters may only be <code>Objects</code>
(don't try to build constructors using ints in their
constructor - this explains the use of the class <code>Integer</code>).
The <code>Domains</code>,
once created, are initialized, and then they are
synchronized by all pinging the maestro, with the notifyFinished
call.&nbsp; <br>
<code></code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
init workers<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int i=0 ; i &lt; totalNbBodies ; i ++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
domainArray[i].init(domainArray, displayer, maestro);</code></p>
<p><code><br>
</code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
public
void init(Domain [] domainArray, Displayer dp, Maestro
master) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
.....<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
maestro.notifyFinished();
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // say we're ready to start<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
</code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code><code>public
void notifyFinished() { <br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;</code><code>&nbsp;
this.nbFinished ++ ; <br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;</code><code>&nbsp;
if (this.nbFinished == this.domainArray.length) { <br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;</code><code>&nbsp;&nbsp;&nbsp;&nbsp;
this.iter ++; <br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code><code>if
(this.iter ==this.maxIter) <br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;</code><code>
this.killsupport.quit(); <br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code><code>this.nbFinished
= 0 ; <br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code><code>for
(int i= 0 ; i &lt; domainArray.length ; i++) <br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code><code>this.domainArray[i].sendValueToNeighbours();
<br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code><code>&nbsp;&nbsp;&nbsp;
</code><code>}<br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</code><code>}
</code></p>
<p>The synchronization is done by
the <code>Maestro</code>,
which counts the number of <code>Domains</code> that have finished,
and then asks
them to go on to the next iteration. While in their execution, the <code>Domains</code>
gather information concerning the position of all
the other bodies, which need to be known to move the local <code>Planet</code>,
at every time step. This is done using a push schema : instead of
explicitly asking for information, this information is automatically
issued : <br>
<code></code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
public void sendValueToNeighbours()
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int i = 0 ; i &lt; this.neighbours.length ; i ++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;
if (i != this.identification) // don't notify self!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; &nbsp;
this.neighbours[i].<span style="color: rgb(0, 121, 0);">setValue</span>(this.info,
this.identification);<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; .....&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <br>
&nbsp;
&nbsp; &nbsp;&nbsp; public
void setValue(Planet
inf, int id) {<br>
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;
&nbsp; this.values [id] = inf;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;
this.nbReceived
++ ;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;
if (this.nbReceived &gt; this.nbvalues)&nbsp; // This is a bad
sign!<br>
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.err.println("Domain " + identification + " received too many
answers");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
if (this.nbReceived == this.nbvalues) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span style="color: rgb(0, 121, 0);">this.maestro.notifyFinished()</span>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
moveBody();<br>
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}&nbsp;&nbsp; </code>
</p>
<p>This means that each <code>Domain</code>
sends its
information to all the other <code>Domains</code>,
and then waits until it has received all the positions it is waiting
for. The other <code>Domains</code>
are stored as an array. You may find another view of
this example on this <a
 href="http://www-sop.inria.fr/oasis/proactive/apps/nbody-simple.html">web
page</a><a>.</a></p>
<h3 class="textNormal"><a>5
groupcom</a></h3>
<p><a>This
is a simple improvement,
which allows to have faster
communication. You may have noticed the Group capabilities of
ProActive. They give us the ability to call an operation on an object
which is&nbsp; a Group, and have it sent to all the members of the
Group. We can use them in this framework : first, create a Group
(instead of having independant <code>Active
Objects</code>) : <br>
</a></p>
<p><code><a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object
[][] params = ... <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Domain&nbsp; domainGroup = null; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
try {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Create all the Domains as part of a Group<br>
&nbsp; &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
domainGroup = (Domain) ProActiveGroup.newGroup (
Domain.class.getName(), params, nodes);<br>
&nbsp;&nbsp; &nbsp; &nbsp;
&nbsp;&nbsp;&nbsp;
} <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp;
catch ....</a></code></p>
<p><a>The
double array params stores
the parameters passed to the
constructors of the <code>Domains</code>
we're creating. <code>Domain 0</code>
will have
<code>params[0][]</code>
passed as arguments, <code>Domain
1 params[1][]</code>, and so on. The
nodes are the Nodes on which to display these Active Objects. Do notice
the <code>try... catch</code>
construction, which is needed, like around any
creation of <code>Active Objects</code>, because it may raise
exceptions. In this
previous bit of&nbsp; code, a <code>Group</code>
containing new <code>Active
Objects</code>
has been created, and all these Objects belong to the group .&nbsp;
You may have noticed that the type of the <code>Group</code>
is Domain. It's a bit
strange at first, and you may think this reference points to only one
Active Object at once, but
that's not true. We're accesssing all the objects in the group, and to
be able to continue using the methods of the Domain class, the group is
typed as <code>Domain</code>,
and that's the reason why it's called a typed Group. <br>
<code></code></a></p>
<p><a>Then,
this group is passed as
parameter to all the members of the Group, in just one call:</a></p>
<p><code><a>&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
domainGroup.init(domainGroup, displayer, maestro);
</a></code></p>
<p><a>This
method sets the local
field as a copy of the passed parameter, and as such is unique, and we
can
play around with it without affecting the others. So let's remove the
local <code>Domain<code>
from the Group, to avoid having calls on self:<br>
</code></code></a></p>
<p>
</p>
<p><code><a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
public
void init(Domain domainGroup,
Displayer dp, Maestro master) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this.neighbours = domainGroup;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Group g = ProActiveGroup.getGroup(neighbours);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
g.remove(ProActive.getStubOnThis()); &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; // no need to send information to self<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp; .....</a></code><a><br>
</a></p>
<p><a>Remember
that in the previous
example, the neighbours where stocked in an
array, and each was accessed in turn:<br>
<code></code></a></p>
<p><code><a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for
(int i = 0 ; i &lt; this.neighbours.length ; i ++)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;
if (i != this.identification) // don't notify self!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; &nbsp;
this.neighbours[i].<span style="color: rgb(0, 121, 0);">setValue</span>(this.info,
this.identification);</a></code><a><br>
</a></p>
<p><a>Well,
that's BAAAAD! Replace
this by the following code, because it works faster :</a></p>
<p><code><a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this.neighbours.setValue<span style="color: rgb(0, 121, 0);"></span>(this.info,
this.identification);<br>
</a></code></p>
<p>This
has the following meaning
: call the method setValue, with the given parameters, to all the
members of the Group neighbours.<br>
You
may find another view of this example on this <a
 href="http://www-sop.inria.fr/oasis/proactive/apps/nbody-groupcom.html">web
page</a>.</p>
<h3 class="textNormal"><a>6
groupdistrib</a></h3>
<p><a>Now,
do like the idea that the
synchronization is centralized on one
entity? I don't and it's the bottleneck of the application anyway :
once a <code>Domain</code>
has finished, it sends the notifyFinshed, and then sits
idle. Well, a way of making this better is to remove it completly! This
is done by using an odd-even scheme : if a Domain sends information too
early, this information is stored, and will get used at the next
iteration. In the meantime, the local Domain does not change its
iteration, because it is still waiting for more results.<br>
<code></code></a></p>
<p><code>&nbsp;&nbsp;&nbsp;
public
void setValue(Planet inf, int
receivedIter) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span style="color: rgb(0, 121, 0);">if (this.iter == receivedIter) {</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span style="color: rgb(0, 121, 0);">this.currentForce.add(info,
inf);</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this.nbReceived ++ ;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (this.nbReceived &gt; this.nbvalues)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.err.println(identification +&nbsp; " : Too many answers " +
this.nbReceived + "/" + this.nbvalues);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (this.nbReceived == this.nbvalues) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
moveBody();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span style="color: rgb(0, 121, 0);">else { </span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (this.iter &gt; receivedIter)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this.killsupport.abort( new NullPointerException("Value arrives too
late!"));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span style="color: rgb(0, 121, 0);">this.prematureValues.add</span>(new
Carrier (inf, receivedIter));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }</code></p>
<p>Also notice how the computation
is done when the result is received (<code>this.currentForce.add(info,
inf);</code>), instead of when <span style="font-weight: bold;">all</span>
the results have arrived. This allows for less time spent
idle. Indeed, waiting for all the results before
computing might leave idle time
between setValue requests. And then, just before computing the new
position of the body, the sum of all the forces has to be computed.
It's better to have this sum ready when needed.<span
 style="color: rgb(255, 0, 0);"></span>
<br>
The <code>prematureValues </code>Vector
is the place where we put the values that arrive out of sync. When
a value is early, it is queued there, and dequeued as soon as this
<code>Domain</code>
changes iteration.</p>
<p><code>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code>public
void sendValueToNeighbours() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>
reset();<br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this.iter++;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>
if (this.iter &lt; this.maxIter) {&nbsp;&nbsp;&nbsp;
&nbsp; <br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
neighbours.setValue(this.info, this.iter);<br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>&nbsp;&nbsp;&nbsp;&nbsp;
<span style="color: rgb(0, 121, 0);">treatPremature();</span><br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...<br>
</code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>
&nbsp;&nbsp; }</code><code><br>
</code></p>
<p>That
treatPremature() method
simply treats the values
that were early
as if they had just arrived, by calling the setValue method with the
parameters stored.<br>
You
may find another view of this example on this <a
 href="http://www-sop.inria.fr/oasis/proactive/apps/nbody-groupdistrib.html">web
page</a><a>.</a></p>
<h3 class="textNormal"><a>7
groupoospmd</a></h3>
<p>This is another way to improve
the groupcom example. It also removes
the master, but this time by inserting oospmd barriers, that can be
thought as behaving like the maestro
class, but faster. To create functional OOspmd Groups, there is a
special instruction,
which takes the same parameters as a newGroup instruction : <br>
<a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<code>Object [][] params = <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Domain domainGroup = null; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
try {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; domainGroup =
(Domain) ProSPMD.newSPMDGroup( Domain.class.getName(), params, nodes);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
catch ...<br>
</code>
</a></p>
<p>Now, to use this OOspmd group
properly, we want to use the barrier() methods. We put these in the
Domains code, to do the synchronization. What happens is that each
Domain hits the
barrier call, and then waits for all the others to have reached it,
before reading its request queue again. </p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
public
void sendValueToNeighbours() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this.neighbours.setValue(this.info,
this.identification);<br>
<span style="color: rgb(0, 121, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ProSPMD.barrier("barrier" + this.iter);</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this.iter++;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this.asyncRefToSelf.moveBody();&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
....<br>
</code>Beware, the stop-and-wait is
not just after the barrier call, but instead blocks the request queue.
So if there is code after that barrier, it <span
 style="font-weight: bold;">will </span>get
executed. In fact, the barrier should be seen as a prioritary request
on the queue. This explains why we had to put the code after the
barrier as a method placed on an asynchronous refernce to self. If we
hadn't done it that way, but just appended the code of
that method just after the barrier, the call to <code>moveBody()</code>
would be executed <span style="font-weight: bold;">before</span>
the barrier execution, which is exactly what we don't want! <br>
<a>You
may find another view of this example on this </a><a
 href="http://www-sop.inria.fr/oasis/proactive/apps/nbody-groupoospmd.html">web
page</a><a>.</a></p>
<h3 class="textNormal"><a>8
Barnes-Hut</a></h3>
<p class="textNormal"><a>This
way to construct the nbody simulation is based on a very different
algorithm. This is inserted to show how one can express this algorithm
in ProActive, but breaks off from the previous track, having such a
different approach to solving the problem. Here's how it works: <br>
</a></p>
<p class="textNormal"><a>To
avoid broadcasting to every active object the new position of every
particle, a tree implementation can simplify the problem by
agglomerating sets of particles as a single particle, with a mass equal
to the sum of masses of the all the particles:. This is the core of the
Barnes-Hut algorithm. References on this can be found for example </a><a
 href="http://physics.gmu.edu/%7Elarge/lr_forces/desc/bh/bhdesc.html">here</a>,
and <a
 href="http://www.cita.utoronto.ca/%7Edubinski/treecode/node2.html">here</a>.
This method allows us to have a complexity brought down to <span
 style="font-style: italic;">O(N log N)</span>.<br>
</p>
<p class="textNormal">In
our parallel implementation, we have defined an <code>Active
Object</code> called
<code>Domain</code>,
which represents a volume in space, and which contains <code>Planets</code>.
It is either subdivided into smaller <code>Domains</code>,
or is a leaf of the total tree, and then only contains <code>Planets</code>.
A Planet is still an Object with mass, velocity and position, but is no
longer on a one-to-one connection with a <code>Domain</code>.
We have cut down communications to the biggest <code>Domains</code>
possible : when
a <code>Planet</code>
is distant enough, its interactions are not computed, but it is grouped
with its local neighbours to a bigger particle. Here is an example of
the <code>Domains</code>
which would be known by the <code>Domain</code>
drawn in red :<br>
</p>
<p style="text-align: center;" class="textNormal">&nbsp;&nbsp;&nbsp; </p>
<table
 style="width: 70%; text-align: left; margin-left: auto; margin-right: auto;"
 border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="text-align: right;"><img
 style="width: 200px; height: 200px;" alt=""
 src="pics/nbody/Domain_subdivision.gif"></td>
      <td style="width: 10%;"><br>
      </td>
      <td style="text-align: left;">
      <p class="textNormal"><img style="width: 240px; height: 200px;"
 alt="" src="pics/nbody/tree.gif"></p>
      </td>
    </tr>
  </tbody>
</table>
<p style="text-align: left;" class="textNormal">The Domain in the lower
left
hand-corner, drawn in blue, is also divided into sub-Domains, but this
needs not be known by the Domain in red : it assumes all the particles
in the blue Domain are only one big one, centered at the center of mass
of all the particles within the blue.</p>
<p>In this version, the
<code>Domains</code>
communicate with a reduced set of other <code>Domains</code>,
spanning on volumes of
different sizes. Synchronization is achieved by sending explicitely
iteration numbers, and returning when needed older positions. You may
notice that some <code>Domains</code>
seem desynchronized with other ones, having
several iterations inbetween. That is no problem because if they then
need to be synchronized and send each other information, a mechanism
saving the older positions permits to
send them when needed.</p>
<p>You may find another view of
this example on this <a
 href="http://www-sop.inria.fr/oasis/proactive/apps/nbody-simple.html">web
page</a><a>.</a></p>
<h3 class="textNormal"><a>9
Conclusion</a></h3>
<p><a>In
this guided tour, we tried
to show different facilities provided by
ProActive, based on a real problem (nbody). We first saw how to deploy
the application, then tuned it by adding Group communication, then
removed a bottleneck ( due to the hard synchronization ) . Finally,
given is the code associated to a different algorithm, which
cumbersomely shows how to get Active Objects deployed along a tree
structure to communicate. Remember that there is
</a><a href="http://www-sop.inria.fr/oasis/proactive/apps/nbody.html">another
explaination</a> of all this on the
web.<br>
<br>
</p>
<br>
<br>
</body>
</html>
