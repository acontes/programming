<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Hello world ! example</title>
  <link rel="stylesheet" href="../../ProActive.css">
</head>
<body bgcolor="white">
<!--
 Header : start 
~~~ -->
<table width="100%">
  <tbody>
    <tr>
      <td align="left" valign="middle">
      <table cellpadding="2" cellspacing="0" border="1">
        <tbody> 
        <tr> 
          <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="../../../../../../overview-summary.html">back to API</a>&nbsp;&nbsp;</td>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="../../index.html">back to index</a>&nbsp;&nbsp;</td>
          <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="../index.html">back 
to guided tour index</a>&nbsp;&nbsp;</td>
          <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2"
 href="../hands_on_programming.html">prev</a>&nbsp;&nbsp;</td>
          <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2"
 href="initializedhello.html">next</a>&nbsp;&nbsp;</td>
        </tr>
        </tbody> 
      </table>
      </td>
      <td align="right" valign="top"> <img
 src="../../ProActiveLogo200x34.gif"> </td>
    </tr>
  </tbody>
</table>
<hr><!-- Link to index : end -->
<h1>1.1. The client - server example</h1>
<p> This example implements a very simple
client-server application. You will find it <a href="../../HelloWorld.html">here</a>, as it is the HelloWorld example earlier mentionned in this manual. A client object displays a <code>String</code>
gotten from a remote server.</p>
<p>The corresponding class diagram is the following :</p>

<img src="../pics/hello/clientserver.gif"> 
<!--
 Footer : start 
~~~ --> <br>
<hr>
<div align="right" class="textSmall">Copyright &copy; June 2002 INRIA
All Rights Reserved.
<p></p>
<!-- Footer : end --> </div>
</body>
</html>
>
</ul>
<p> Here is a possible implementation for the <code>Hello</code>
class: </p>
<br>
<table align="center" width="96%" border="1" cellpadding="5"
 cellspacing="0">
  <tbody>
    <tr>
      <th align="center" bgcolor="#ccccff">Hello.java</th>
    </tr>
    <tr>
      <td>
 <pre> <code> /** This class represents an object, with its functionnal properties and
* behaviors.

*/
public class Hello {
    private String name;

    // ProActive requires a constructor with no parameter
    // in the class of the active object. That implies the presence
    // of a constructor with no parameter in the mother class

    /** constructor with no parameter, required by the ProActive model
    */
    public Hello() {
    }

    /** constructor
    * @param name the name of the agent
    *
    */
    public Hello(String name) {
        this.name = name;
    }

    /** a functionnal behavior of the object
    * @return what the agent has to say
    */
    public void sayHello() {
        //System.out.println("\nHELLO!");
        System.out.println("\n---------------------\nhello,from : " + getLocalHostName());
    }

    public void toto() {
    }

    /** locator method
    *
    * @return the name of the host currently containing the object
    */
    protected String getLocalHostName() {
        try {
            return InetAddress.getLocalHost().toString();
        } catch (UnknownHostException uhe) {
            uhe.printStackTrace();
            return "! localhost resolution failed";
        }
    }

    /**
     * Returns the name.
     * @return String
     */
    public String getName() {
        return name;
    }
</code></pre>
      </td>
    </tr>
  </tbody>
</table>
<br>
<h4>Implement the required functionalities</h4>
<p> Implementing any remotely-accessible
functionality is simply done through normal Java methods in a normal
Java class, in exactly the same manner it would have been done in a
non-distributed version of the same class. This has to be contrasted
with the RMI approach, where several more steps are needed: </p>
<ul class="listWithSpace">
  <li class="textNormal">Define a remote interface for declaring the
remotely-accessible methods.</li>
  <li class="textNormal">Rewrite the class so that it inherits from <code>java.rmi.server.UnicastRemoteObject</code>,
which is the root class of all remote objects.</li>
  <li class="textNormal">Add remote exceptions handling to the code.</li>
</ul>
<p></p>
<h4>Why an empty no-arg constructor ?</h4>
<p> You may have noticed that class <code>Hello</code>
has a constructor with no parameters and an empty implementation. The
presence of this empty no-arg constructor is imposed by ProActive and
is actually a side-effect of ProActive's transparent implementation 
active remote objects (as a matter of fact, this side-effect is
caused by ProActive being implemented on top of a 100% Java metaobject
protocol). If no such constructor is provided, active objects cannot
be created. <br>
If no constructor at all is provided, active objects can still be
created because, in this specific case, all Java compilers provide a
default no-arg empty constructor. If a no-arg constructor is provided
but its implementation is not empty, unwanted behavior may appear
because the no-arg constructor is always called when an active object
is created, whatever code the user can write. </p>
<h4>Create the remote <code>Hello</code> object</h4>
<p> Now that we know how to write the class that
implements the required server-side functionalities, let us see how to
create the server object. In ProActive, there is actually no difference
between a server and a client object as both are remote objects.Creating
the active object is done through <i>instantiation-based creation</i>.
We want this active object to be created on the current node, which is why we use  <code>newActive</code> with only two parameters.
In order for the client to obtain an initial referenceonto this remote
object, we need to register it in the registry (which is actually the
well-known <code>rmiregistry</code>) with a valid RMI URL. </p>
<h3>The <code>ClientServerMain</code> Class</h3>
The responsibility of this class is first to locate the remote server
object, then to invoke a method on it in order to retrieve a message,
and finally display that message. <br>
<table align="center" width="97%" border="1" cellpadding="5"
 cellspacing="0">
  <tbody>
    <tr>
      <th align="center" bgcolor="#ccccff">ClientServerMain.java</th>
    </tr>
    <tr>
      <td>

      <pre>	<code>public static void main(String[] args) {
		Hello myServer;
		try {
			// checks for the server's URL
			if (args.length == 0) {
				// There is no url to the server, so create an active server within this VM
				myServer =
					(Hello) org.objectweb.proactive.ProActive.newActive(
						Hello.class.getName(),
						new Object[] { "local" });
			} else {
				// Lookups the server object
				System.out.println("Using server located on " + args[0]);
				myServer = (Hello) org.objectweb.proactive.ProActive.lookupActive(
								     Hello.class.getName(), args[0]);
			}
			// Invokes a remote method on this object to get the message
			myServer.sayHello();
		} catch (Exception e) {
			System.err.println("Could not reach/create server object");
			e.printStackTrace();
			System.exit(1);
		}
	}</code></pre>

      </td>
    </tr>
  </tbody>
</table>
<br>
<h4>Looking up a remote object</h4>
<p>The operation of <i>lookup</i> simply means
obtaining a reference onto an object from the URL it is bound to. The
return type of method <code>Proactive.lookupActive()</code> is <code>Object</code>,
then we need to cast it down into the type of the variable that holds
the reference (<code>Hello</code> here). If no object is found at this
URL, the call to <code>Proactive.lookupActive()</code> returns <code>null</code>.</p>
<h4>Invoking a method on a remote object</h4>
<p> This is exactly like invoking a method on a local
object of the same type. The user does not have to deal with catching
distribution-related exceptions like, for example, when using RMI or
CORBA. Future versions of ProActive PDC will provide an exception
handler mechanism in order to process these exceptions in a separate
place than the functional code. As class <code>String</code> is <code>final</code>,
there cannot be any asynchronism here since the object returned from
the call cannot be replaced by a future object (this restriction on <code>final</code>
classes is imposed by ProActive's implementation). </p>
<h4>Printing out the message</h4>
<p> As already stated, the only modification brought
to the code by ProActive PDC is located at the place where active
objects are created. All the rest of the code remains the same, which
fosters software reuse. </p>
<h3>Hello World within the same VM</h3>
<p> In order to run both the client and server in the
same VM, the client creates an active object in the same VM if it
doesn't find the server's URL. The code snippet which instantiates the
Server in the same VM is the following: </p>
<pre>if (args.length == 0) {<br>  // There is no url to the server, so create an active server within this VM<br>  myServer = (Hello)org.objectweb.proactive.ProActive.newActive(Hello.class.getName(), new Object[]{"local"});<br>}<br></pre>
<p> To launch the Client and the Server, just type: </p>
<pre>&gt; java org.objectweb.proactive.examples.hello.Client &amp;<br></pre>
<h3>Hello World from another VM on the same host</h3>
<h4>Starting the server</h4>
Just start the <code>main</code> method in the <code>Hello</code>
class.
<pre>&gt; java org.objectweb.proactive.examples.hello.Hello &amp;<br></pre>
<h4>Launching the client</h4>
<pre>&gt; java org.objectweb.proactive.examples.hello.HelloClient //localhost/Hello<br></pre>
<h3>Hello World from abroad: another VM on a different host</h3>
<h4>Starting the server</h4>
Log on to the server's host, and launch the <code>Hello</code> class.
<pre>remoteHost&gt; java org.objectweb.proactive.examples.hello.Hello &amp;<br></pre>
<h4>Launching the client</h4>
Log on to the client Host, and launch the client
<pre>clientHost&gt; java org.objectweb.proactive.examples.hello.HelloClient //remoteHost/Hello<br></pre>
<!--
 Footer : start 
~~~ --> <br>
<hr>
<div align="right" class="textSmall">Copyright &copy; June 2002 INRIA
All Rights Reserved.
<p></p>
<!-- Footer : end --> </div>
</body>
</html>
