<?xml version="1.0" encoding="UTF-8"?>
<chapter id="nbody"><title>5. The nbody example</title>
<!--  File: /home/irosenbe/PA_new_doc/docbook-tuto/doc-files/guided_tour/nbody.html  -->
  
    <sect1 remap="h2">
      <title>Using facilities provided by ProActive on a complete example</title>
      <sect2 remap="h3">
        <title><anchor id="nbody_html_rationale"/>1 Rationale and overview
        </title>
        <para>This section of the guided tour goes through the different steps that could take you to
 writing an application with ProActive, from a simple design, to a more complicated structure.
 This is meant to help you get familiar with the Group facilities offered by ProActive. Please
 take note that this page tries to take you through the progression, step by step. You may find
 some <ulink url="http://www-sop.inria.fr/oasis/proactive/apps/nbody.xml">more information</ulink>,
 mainly on the design, on the web page of the <ulink url="http://www-sop.inria.fr/oasis/proactive/apps/">applications/examples</ulink> of proactive. This is a
 snapshot of the ProActive nbody example running on 3 hosts with 8 bodies:</para>
         
         
        <para>
          <informalfigure>
            <mediaobject>
              <imageobject>
                <imagedata fileref="doc-files/guided_tour/./pics/nbody/gui.png" format="PNG"/>              </imageobject>
            </mediaobject>
          </informalfigure>
</para>
        <para>n-body is a classic problem. It consists in working out the position of bodies in space, which
 depend only on the gravitational forces that apply to them. A good introduction to the problem is
 given <ulink url="http://www.cs.berkeley.edu/%7Esouravc/cs267/nbody.htm">here</ulink>. You may find a
 detailled explanation of the underlying mathematics <ulink url="http://members.fortunecity.com/kokhuitan/nbody.xml">here</ulink>. Different ways of finding
 numerical solutions are given <ulink url="http://www.amara.com/papers/nbody.xml">here</ulink>.</para>
        <para>In short, one considers several bodies (sometimes called particles) in space, where the only
 force is due to gravity. When only two bodies are at hand, this is expressed as</para>
        <para>
          <informaltable frame="none">
            <tgroup cols="2">
<!--              <colspec colname="c1" colwidth="50*"/>
              <colspec colname="c2" colwidth="50*"/>-->
              <tbody>
                <row>
                  <entry><para>
                      <informalfigure>
                        <mediaobject>
                         <imageobject>
                           <imagedata width="3in" fileref="doc-files/guided_tour/pics/nbody/forces_simple.png" format="PNG"/>   
                          </imageobject>
                        </mediaobject>
                      </informalfigure>
 F<subscript>p-&gt;b</subscript> is the force that p applies on b, G is the gravitational constant, m<subscript>p</subscript>m<subscript>b</subscript> describe the
 mass of the bodies, r is the distance between p and b, andu is a unit
 vector in the direction going from p to b. When we consider all the forces that apply
 to one given body, we have to sum up the contribution of all the other bodies :</para>                     
                    <para>
                      <informalfigure>
                        <mediaobject>
                          <imageobject>
                            <imagedata fileref="doc-files/guided_tour/pics/nbody/forces_sum.png" format="PNG"/>    
                           </imageobject>
                        </mediaobject>
                      </informalfigure>
</para>
                     
<para>This should be read as : the total force on the body b is the sum of all the forces applied to b, generated by all the other bodies in the system.</para>                    <para>
 This is the force that has to be computed for every body in the system. With this
 force, using the usual physics formulae, (Newton&#39;s second Law)</para>
                     
                    <para>
                      <informalfigure>
                        <mediaobject>
                          <imageobject>
                            <imagedata fileref="doc-files/guided_tour/pics/nbody/acc.png" format="PNG"/>                          </imageobject>
                        </mediaobject>
                      </informalfigure>
</para>
                     
<para>one may now compute the movement of a particle for a given time
 step (a the acceleration, v the velocity, x
 the position, t the time):</para>                     
                    <para>
                      <informalfigure>
                        <mediaobject>
                          <imageobject>
                            <imagedata fileref="doc-files/guided_tour/pics/nbody/movement_equations.png" format="PNG"/>                          </imageobject>
                        </mediaobject>
                      </informalfigure>
</para>
                     
</entry>
                  <entry><para>
                      <informalfigure>
                          <imageobject>
                            <imagedata fileref="doc-files/guided_tour/pics/nbody/interactions.png" format="PNG"/>     </imageobject>
                      </informalfigure>
</para>                     
</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
</para>
      </sect2>
      <sect2 remap="h3">
        <title><anchor id="nbody_html_sources"/>2 Source files:
 ProActive/src/org/objectweb/proactive/examples/nbody</title>
        <para>This guided tour is based on the files you may find in the directory
 ProActive/src/org/objectweb/proactive/examples/nbody. You&#39;ll find the following tree:</para>
        <para>
          <informalfigure>
            <mediaobject>
              <imageobject>
                <imagedata fileref="doc-files/guided_tour/pics/nbody/directory.png" format="PNG"/>              </imageobject>
            </mediaobject>
          </informalfigure>
</para>
         
         
        <para>The common directory contains files reused through the different version. &#39;simple&#39; is
 the simplest example, groupcom is the first example with Group communication, and
 &#39;groupdistrib&#39; and &#39;groupoospmd&#39; are two enhancement based on different
 synchronization schemes. &#39;barneshut&#39; is a bit special, in that it contains a different
 algorithm to solve the nbody problem.</para>
         
      </sect2>
      <sect2 remap="h3">
        <title><anchor id="nbody_html_common"/>3 Common files</title>
        <para>The files contained in &#39;common&#39; are those that are reused throughout the different
 versions.  Let&#39;s see what they do:</para>
         
        <itemizedlist>
          <listitem>
            <para> First of all there are the two files called Displayer.java and NBodyFrame.java. These
 handle the graphical output of the bodies, as they move about in space. They are not specially
 of interest, as GUI is not the point of this tutorial. Nonetheless, please note that the
 important method here is </para>
            <para><literal>        public void
 drawBody(int x, int y, int vx, int vy, int weight, int d, int id) ;</literal></para>
            <para>Taking
 position, velocity, diameter and unique identifier of a body, it updates the display window. </para>
          </listitem>
          <listitem>
            <para> Then, we have the files Force.java and Planet.java. They are used to compute the
 interaction between two distant bodies in the universe. Since they are in the common directory,
 they can be modified to include other forces (for example, collision) in a simple manner, which
 would be spread to all the examples. A Planet is no more than a point in space, with velocity
 and mass - the diameter expresses the size to use for the display: </para>
            <screen>
         public class Planet implements Serializable{
             public double mass;
             public double x,y,vx,vy;
                 // position and velocity
             public double diameter;
                   // diameter of the body, used by the Displayer
             ...</screen>
            <para>Please take
 note that it implements Serializable because it will be sent as parameter to method calls on
 Active Objects, but it is good practice to have all
 your ProActive classes implement Serializable. For example, migration requires everything to
 implement it, fault-tolerance also.... </para>
            <para>The Force class is just the implementation of what a physical force really is. It is the
 implementation of a 2D vector, with the method add following the physics rule</para>
             
            <para>
              <informalfigure>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="doc-files/guided_tour/pics/nbody/forces_simple.png" format="PNG"/>                  </imageobject>
                </mediaobject>
              </informalfigure>
</para>
             
          </listitem>
          <listitem>
            <para> Point2D.java and Rectangle.java are helper files. They simply implement what a point in
 space looks like, and what a rectangle is. They were created to avoid the trouble of using the
 standard java java.awt.geom.Point2D and java.awt.geom.Rectangle2D, which carry a bit too much
 overhead, and also to have them Serializable.</para>
          </listitem>
          <listitem>
            <para> And finally, the Start.java acts as the wrapper for the main() method. There is a part
 which reads command line parameters,  counting bodies and iterations, and 
 constructing the optional Displayer. Before choosing which example to run, it creates the nodes
 required by the simulation :</para>
            <screen>
         // Construct deployment-related variables: pad &amp; nodes
         descriptorPad = null;
         VirtualNode vnode;
         try { descriptorPad = ProActive.getProactiveDescriptor(xmlFileName); }
         catch (ProActiveException e) { abort(e); }
         descriptorPad.activateMappings();
         vnode = descriptorPad.getVirtualNode(&quot;Workers&quot;);
         Node[] nodes = null;
         try { nodes = vnode.getNodes(); }
         catch (NodeException e) { abort(e);
 }</screen>
            <para>the <literal>Node [] nodes</literal> are the different JVMs that were created on
 possibly different machines. They are used for Active Object creation. They were specified in
 the descriptor used to deploy the application. You may find more information on these <ulink url="http://www-sop.inria.fr/oasis/proactive/doc/api/org/objectweb/proactive/doc-files/Descriptor.xml">
 descriptors here</ulink>, while Active Object creation is explained in <ulink url="http://www-sop.inria.fr/oasis/proactive/doc/api/org/objectweb/proactive/doc-files/ActiveObjectCreation.xml">
 this page</ulink>. Just as an example, in the simple package, the Maestro is created on the first
 of theses JVMs, and takes three parameters, a <literal>Domain []</literal>, an <literal>Integer</literal>, and a <literal>Start</literal> (it will be detailed later) :</para>
            <screen>
         Object [] constructorParams ;
         constructorParams = {domainArray, new Integer(maxIter), killsupport} ;
         maestro = (Maestro) ProActive.newActive 
           ( Maestro.class.getName(), constructorParams , nodes[0] ) ;
          </screen>
          </listitem>
</itemizedlist>
        <para>The files contained in the other directories, &#39;simple&#39;, &#39;groupcom&#39;,
 &#39;groupdistrib&#39; , &#39;groupoospmd&#39; , detail steps of increasing complexity, making
 the application use different concepts. &#39;barneshut&#39; contains the final implementation,
 featuring the Barnes-Hut algorithm. But let&#39;s not go too fast. Let&#39;s have a look at the
 insides of the simplest implementation of the n-body problem.</para>
         
      </sect2>
      <sect2 remap="h3">
        <title><anchor id="nbody_html_simple"/>4 Simple Active Objects</title>
        <para>This is the implementation of the simplest example of nbody. We defined the <literal>Planet</literal> to be a passive object, and it does nothing. It is a container for position,
 velocity and mass, as we&#39;ve seen in the description given higher up. The real actors are the <literal>Domains</literal>, they do all the work. To every <literal>Planet</literal> in the universe, is
 associated a <literal>Domain</literal>, which is an <literal>Active Object</literal>. This  <literal>Domain</literal> contains the code to manage the communication of the possitions of the <literal>Planets</literal> during the simulation. They are created in the Start.java file :</para>
        <screen>
         Rectangle universe = new Rectangle (-100,-100,100,100);
         Domain [] domainArray = new Domain [totalNbBodies];
         for (int  i = 0 ; i &lt; totalNbBodies ; i++)  {
             Object [] constructorParams = new Object [] {
                      new Integer(i),
                      new Planet (universe)
                 };
             try {
                 // Create all the Domains used in the simulation
                 domainArray[i] = (Domain) ProActive.newActive(
                         Domain.class.getName(),
                         constructorParams,
                         nodes[(i+1) % nodes.length]
                 );
             }
             catch (ActiveObjectCreationException e) { killsupport.abort(e); }
             catch (NodeException e) {  killsupport.abort(e); }
         }
</screen>
        <para>See how the call to <literal>ProActive.newActive</literal> creates one new <literal>Active
 Object</literal>, a <literal>Domain</literal>, at each iteration of the loop. The array <literal>nodes</literal>
 contains all the nodes on which an Active Object may be deployed; at each iteration, one given
 node, ie one JVM, is selected. The <literal>constructorParams</literal> are the parameters that are to
 be passed to the constructor of <literal>Domain</literal>, and since it&#39;s an <literal>Object []</literal>
 , the parameters may only be <literal>Objects</literal> (don&#39;t try to build constructors using ints
 in their constructor - this explains the use of the class <literal>Integer</literal>).</para>
        <para>The <literal>Domains</literal>, once created, are initialized, and then they synchronize themselves
 by all pinging the maestro, with the notifyFinished call:</para>
        <screen>
         // init workers, from the Start class
         for (int i=0 ; i &lt; totalNbBodies ; i ++)
             domainArray[i].init(domainArray, displayer, maestro);
          // init method, defined within each worker
</screen>

<screen>
          public void init(Domain [] domainArray, Displayer dp, Maestro master) {
                   this.neighbours = domainArray;
                   .....
                   maestro.notifyFinished();  // say we&#39;re ready to start
            }</screen>
           
           <screen>
         public void notifyFinished() {
             this.nbFinished ++;
             if (this.nbFinished == this.domainArray.length) {
                 this.iter ++; 
                 if (this.iter==this.maxIter)
                      this.killsupport.quit();
                 this.nbFinished = 0 ;
                   for (int i= 0 ; i &lt; domainArray.length ; i++)
                       this.domainArray[i].sendValueToNeighbours();
           }
 }</screen>
        <para>Notice how domainArray is passed to all the <literal>Domains</literal>, when calling <literal>init</literal>. 
         This is the value assigned to the local field <literal>neighbours</literal>, which
 later on serves to communicate with all the other <literal>Domains</literal> of the simulation.</para>
        <para>The synchronization is done by the <literal>Maestro</literal>, which counts the number of <literal>Domains</literal> that have finished, and then asks them to go on to the next iteration. While
 in their execution, the <literal>Domains</literal> gather information concerning the position of all
 the other bodies, which need to be known to move the local <literal>Planet</literal>, at every time
 step. This is done using a push schema : instead of explicitly asking for information, this
 information is automatically issued :</para>
        <screen>        
       public void sendValueToNeighbours() {
            for (int i = 0 ; i &lt; this.neighbours.length ; i ++)
               if (i != this.identification) // don&#39;t notify self!
                   this.neighbours[i].setValue(this.info, this.identification);
             .....  
            }
       
        public void setValue(Planet inf, int id) {
           this.values [id] = inf;
           this.nbReceived ++ ;
           if (this.nbReceived &gt; this.nbvalues)  // This is a bad sign!
               System.err.println(&quot;Domain &quot; + identification + &quot; received too many answers&quot;);
           if (this.nbReceived == this.nbvalues) {
               this.maestro.notifyFinished();
               moveBody();
           }
       }  </screen>
        <para>This means that each <literal>Domain</literal> sends its information to all the other <literal>Domains</literal>, and then waits until it has received all the positions it is waiting for.
 The other <literal>Domains</literal> are stored as an array, which is called <literal>neighbours</literal>.
 You may find another view of this example on this <ulink url="http://www-sop.inria.fr/oasis/proactive/apps/nbody-simple.xml">web page</ulink>.</para>
      </sect2>
      <sect2 remap="h3">
        <title><anchor id="nbody_html_groups"/>5 Groups of Active objects</title>
        <para>This is a simple improvement, which allows to have faster communication. You may have noticed
 the Group capabilities of ProActive. They give us the ability to call an operation on an object
 which is  a Group, and have it sent to all the members of the Group. We can use them in this
 framework : first, create a Group (instead of having independant <literal>Active Objects</literal>)
 :</para>
        
        <screen>           // in the Start class
            Object [][] params = ...
            Domain  domainGroup = null;
            try {
                // Create all the Domains as part of a Group
                domainGroup = (Domain) ProActiveGroup.newGroup ( Domain.class.getName(), params, nodes);
            }
            catch ....&gt;</screen>
        <para>The double array params stores the parameters passed to the constructors of the <literal>Domains</literal> we&#39;re creating. <literal>Domain 0</literal> will have <literal>params[0][]</literal>
 passed as arguments, <literal>Domain 1 params[1][]</literal>, and so on. The nodes are the Nodes on
 which to create these Active Objects. Do notice the <literal>try... catch</literal> construction, which
 is needed, like around any creation of <literal>Active Objects</literal>, because it may raise
 exceptions. In this previous bit of  code, a <literal>Group</literal> containing new <literal>Active
 Objects</literal> has been created, and all these Objects belong to the group .  You may have
 noticed that the type of the <literal>Group</literal> is Domain. It&#39;s a bit strange at first, and
 you may think this reference points to only one Active Object at once, but that&#39;s not true.
 We&#39;re accesssing all the objects in the group, and to be able to continue using the methods
 of the Domain class, the group is <emphasis role="bold">typed</emphasis> as <literal>Domain</literal>, and that&#39;s the reason
 why it&#39;s called a <emphasis role="bold">typed Group</emphasis>.</para>
        <para>Then, this group is passed as parameter to all the members of the Group, in just one call:</para>
        <screen>           
         // Still in the Start class
            domainGroup.init(domainGroup, displayer, maestro);
         </screen>
        <para>This method sets the local field as a copy of the passed parameter, and as such is unique, and
 we can play around with it without affecting the others. So let&#39;s remove the local <literal>Domain</literal> from the Group, to avoid having calls on self:</para>
        <screen>
               public void init(Domain domainGroup, Displayer dp, Maestro master) {
                 this.neighbours = domainGroup;
                 Group g = ProActiveGroup.getGroup(neighbours);
                 g.remove(ProActive.getStubOnThis()); // no need to send information to self
               .....
</screen>
        <para>Remember that in the previous example, the neighbours where stocked in an array, and each was
 accessed in turn:</para>
        
        <screen>           
         for (int i = 0 ; i &lt; this.neighbours.length ; i ++)
               if (i != this.identification) // don&#39;t notify self!
                  this.neighbours[i].setValue(this.info, this.identification);</screen>
        <para>Well, that&#39;s BAAAAD, or at least inefficient! Replace this by the following code, because
 it works faster :</para>
        <para><literal>          
 this.neighbours.setValue(this.info, this.identification);</literal></para>
        <para>This has the following meaning : call the method setValue, with the given parameters, on all
 the members of the Group <literal>neighbours</literal>. In one line of code, the method <literal>setValue</literal> is called on all the Active Objects in the group.</para>
        <para>
 You may find another view of this example on this <ulink url="http://www-sop.inria.fr/oasis/proactive/apps/nbody-groupcom.xml">web page</ulink>.</para>
      </sect2>
      <sect2 remap="h3">
        <title><anchor id="nbody_html_distrib"/>6 groupdistrib</title>
        <para>Now, do like the idea that the synchronization is centralized on one entity, the <literal>Maestro</literal>? I don&#39;t and it&#39;s the bottleneck of the application anyway : once a <literal>Domain</literal> has finished, it sends the notifyFinshed, and then sits idle. Well, a way of
 making this better is to remove this bottleneck completely! This is done by using an odd-even
 scheme : if a Domain receives information from a distant <literal>Domain</literal> too early (ie in the
 wrong iteration), this information is stored, and will get used at the next iteration. In the
 meantime, the local Domain does not change its iteration, because it is still waiting for more
 results, in the current iteration.</para>
        
        <screen>    
         public void setValue(Planet inf, int receivedIter) {
           if (this.iter == receivedIter) {
             this.currentForce.add(info, inf);
             this.nbReceived ++ ;
             if (this.nbReceived == this.nbvalues)
                 moveBody();
         }
         else {
             this.prematureValues.add(new Carrier (inf, receivedIter));
         }
     }</screen>
        <para>Also notice how the computation is done incrementally when the result is received
 (<literal>this.currentForce.add(info, inf);</literal>), instead of when all the results have arrived. This allows for less time spent idle.
 Indeed, waiting for all the results before computing might leave idle time between setValue
 requests. And then, just before computing the new position of the body, the sum of all the forces
 has to be computed. It&#39;s better to have this sum ready when needed.</para>
        <para>
 The <literal>prematureValues</literal> Vector is the place where we put the values that arrive out of
 sync. When a value is early, it is queued there, and dequeued as soon as this <literal>Domain</literal>
 changes iteration.</para>
        <screen>
         public void sendValueToNeighbours()  {
                   reset();                  
                   this.iter++;
                   if (this.iter &lt; this.maxIter) {                           
                       neighbours.setValue(this.info, this.iter);                      
                       ... // display related code
                       treatPremature();                  
                       }                  
                    ... // JVM destruction related code             
             }   
</screen>
        <para>That treatPremature() method simply treats the values that were early as if they had just
 arrived, by calling the setValue method with the parameters stored.</para>
        <para>
 You may find another view of this example on this <ulink url="http://www-sop.inria.fr/oasis/proactive/apps/nbody-groupdistrib.xml">web page</ulink>.</para>
      </sect2>
      <sect2 remap="h3">
        <title><anchor id="nbody_html_oospmd"/>7 Object Oriented SPMD Groups</title>
        <para>This is another way to improve the groupcom example. It also removes the master, but this time
 by inserting oospmd barriers, that can be thought as behaving like the maestro class, but faster.
 To create functional OOspmd Groups, there is a special instruction, which takes the same
 parameters as a newGroup instruction :</para>
        <screen>
         Object [][] params =  ...
         Domain domainGroup = null;
         try {
              domainGroup = (Domain) ProSPMD.newSPMDGroup( Domain.class.getName(), params, nodes);
             }
             catch ...</screen>
        <para>Now, to use this OOspmd group properly, we want to use the barrier() methods. We put these in
 the Domains code, to do the synchronization. What happens is that each Domain hits the barrier
 call, and then waits for all the others to have reached it, before reading its request queue
 again.</para>
<screen>        
 public void sendValueToNeighbours() {
    this.neighbours.setValue(this.info, this.identification);       
    ProSPMD.barrier(&quot;barrier&quot; + this.iter);
    this.iter++;
    this.asyncRefToSelf.moveBody();    
  ....
 </screen><para>Beware, the stop-and-wait is not just after the barrier call, but instead blocks
 the request queue. So if there is code after that barrier, it will get executed. In fact, the barrier should be seen as a
 prioritary request on the queue. This explains why we had to put the code after the barrier as a
 method placed on an asynchronous refernce to self. If we hadn&#39;t done it that way, but just
 appended the code of that method just after the barrier, the call to <literal>moveBody()</literal>
 would be executed before the barrier execution, which is exactly what we don&#39;t want!</para>
        <para>
 You may find another view of this example on this <ulink url="http://www-sop.inria.fr/oasis/proactive/apps/nbody-groupoospmd.xml">web page</ulink>.</para>
      </sect2>
      <sect2 remap="h3">
        <title><anchor id="nbody_html_barnes"/>8 Barnes-Hut</title>
        <para>This way to construct the nbody simulation is based on a very different
 algorithm. This is inserted to show how one can express this algorithm in ProActive, but breaks
 off from the previous track, having such a different approach to solving the problem. Here&#39;s
 how it works:</para>
         
        <para>To avoid broadcasting to every active object the new position of every
 particle, a tree implementation can simplify the problem by agglomerating sets of particles as a
 single particle, with a mass equal to the sum of masses of the all the particles:. This is the
 core of the Barnes-Hut algorithm. References on this can be found for example <ulink url="http://physics.gmu.edu/%7Elarge/lr_forces/desc/bh/bhdesc.xml">here</ulink>, and <ulink url="http://www.cita.utoronto.ca/%7Edubinski/treecode/node2.xml">here</ulink>. This method allows us to
 have a complexity brought down to O(N log N).</para>
         
        <para>In our parallel implementation, we have defined an <literal>Active
 Object</literal> called <literal>Domain</literal>, which represents a volume in space, and which contains <literal>Planets</literal>. It is either subdivided into smaller <literal>Domains</literal>, or is a leaf of
 the total tree, and then only contains <literal>Planets</literal>. A Planet is still an Object with
 mass, velocity and position, but is no longer on a one-to-one connection with a <literal>Domain</literal>. We have cut down communications to the biggest <literal>Domains</literal> possible
 : when a <literal>Planet</literal> is distant enough, its interactions are not computed, but it is
 grouped with its local neighbours to a bigger particle. Here is an example of the <literal>Domains</literal> which would be known by the <literal>Domain</literal> drawn in red :</para>
         
        <para>   </para>
        <informaltable frame="none">
          <tgroup cols="3">
<!--            <colspec colname="c1" colwidth="33*"/>
            <colspec colname="c2" colwidth="33*"/>
            <colspec colname="c3" colwidth="33*"/>-->
            <tbody>
              <row>
                <entry><para>
                    <informalfigure>
                      <mediaobject>
                        <imageobject>
                          <imagedata fileref="doc-files/guided_tour/pics/nbody/Domain_subdivision.png" format="PNG"/>   </imageobject>
                      </mediaobject>
                    </informalfigure>
</para></entry>
                <entry>                    
</entry>
                <entry><para> 
                    <informalfigure>
                      <mediaobject>
                        <imageobject>
                          <imagedata fileref="doc-files/guided_tour/pics/nbody/tree.png" format="PNG"/>                        </imageobject>
                      </mediaobject>
                    </informalfigure>
</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>The Domain in the lower left hand-corner, drawn
 in blue, is also divided into sub-Domains, but this needs not be known by the Domain in red : it
 assumes all the particles in the blue Domain are only one big one, centered at the center of mass
 of all the particles within the blue.</para>
        <para>In this version, the <literal>Domains</literal> communicate with a reduced set of other <literal>Domains</literal>, spanning on volumes of different sizes. Synchronization is achieved by
 sending explicitely iteration numbers, and returning when needed older positions. You may notice
 that some <literal>Domains</literal> seem desynchronized with other ones, having several iterations
 inbetween. That is no problem because if they then need to be synchronized and send each other
 information, a mechanism saving the older positions permits to send them when needed.</para>
        <para>You may find another view of this example on this <ulink url="http://www-sop.inria.fr/oasis/proactive/apps/nbody-simple.xml">web page</ulink>.</para>
      </sect2>
      <sect2 remap="h3">
        <title><anchor id="nbody_html_concl"/>9 Conclusion</title>
        <para>In this guided tour, we tried to show different facilities provided by ProActive, based on a
 real problem (nbody). We first saw how to deploy the application, then tuned it by adding Group
 communication, then removed a bottleneck ( due to the hard synchronization ) . Finally, given is
 the code associated to a different algorithm, which cumbersomely shows how to get Active Objects
 deployed along a tree structure to communicate. Remember that there is <ulink url="http://www-sop.inria.fr/oasis/proactive/apps/nbody.xml">another explanation</ulink> of all this on
 the web.</para>
         
         
         
         
         
      </sect2>
    </sect1>
  
</chapter>
