<?xml version="1.0" encoding="UTF-8"?>
<chapter id="Principles">
  <title>Principles</title>

  <sect1 remap="h2">
    <title><anchor id="Principles_html_intro" />Seamless sequential,
    multithreaded and distributed</title>   
   
   <para>Most of the time, activities and distribution are not known at the
    beginning, and change over time. <emphasis role="bold">Seamless implies
    reuse, smooth and incremental transitions</emphasis>.</para>

    <para><figure>
        <title>Different computing deployment paradigms</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/proActiveModelColor.png" format="PNG"
                       contentwidth="100" width="6in"/>
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>A huge gap yet exists between multithreaded and distributed Java
    applications which forbids code reuse in order to build distributed
    applications from multithreaded applications. Both JavaRMI and JavaIDL, as
    examples of distributed object libraries in Java, put a heavy burden on
    the programmer because they require deep modifications of existing code in
    order to turn local objects into remote accessible ones. In these systems,
    remote objects need to be accessed through some specific interfaces. As a
    consequence, these distributed objects libraries do not allow polymorphism
    between local and remote objects. This feature is our first requirement
    for a metacomputing framework. It is strongly required in order to let the
    programmer <emphasis>concentrate first on modeling and algorithmic issues 
    rather than lower-level tasks </emphasis> such as object distribution,
    mapping and load balancing.</para>
  </sect1>

  <sect1 remap="h2" id="Principles_html_active" >
    <title> Active objects: Unifying threads and remote objects</title>

    <para>
     <literal>Active Objects</literal> is the core of the ProActive computing 
     concept. It unifies a <emphasis>Remote Object</emphasis> (which allows 
     to deploy it on a distant host)  and a <emphasis>Thread</emphasis> 
     (which gives it its own activity, its own behaviour independently and in 
     concurrency with other Active Objects deployed). Given a standard object, 
     turning it into an Active Objects provides:</para>

    <itemizedlist>
      <listitem>
        <para>location transparency</para>
      </listitem>

      <listitem>
        <para>activity transparency</para>
      </listitem>

      <listitem>
        <para>synchronization</para>
      </listitem>
    </itemizedlist>

    <para> <emphasis> This <literal>Active Object</literal> concept requires 
      only to modify the instanciation code !</emphasis></para>

      <para>Here are given as example three ways to transform a standard 
       <literal>Object</literal> into an <literal>Active Object</literal>:</para>
     

    <example>
      <title>Class-based Active Object</title>
      <programlisting language="java">Object[] params = new Object[] { new Integer (26), "astring" };
A a = (A) ProActive.newActive("example.A", params, node); </programlisting>
    </example>

    <example>
      <title>Instantiation-based Active Object</title>
      <programlisting language="java">public class AA extends A implements Active {}
Object[] params = new Object[] { new Integer (26), "astring" };
A a = (A) ProActive.newActive("example.AA", params, node); </programlisting>
    </example>

      <para>Object-based <literal>Active Objects</literal> Allows to turn active 
       and set remote objects for which you do not have the source code; this is 
       a necessary feature in the context of code mobility.</para>
       
       <example>
        <title>Object-based Active Object</title>
      <programlisting language="java">A a = new A (26, "astring");
a = (A) ProActive.turnActive(a, node) ; </programlisting>    
    </example>
    
      <note><para> Nodes allows to control the mapping to the hosts </para></note>
  </sect1>

  <sect1 remap="h2" id="Principles_html_model">
    <title> Model of Computation: Based on  previous works and studies</title>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Heterogeneous model</emphasis> both
        passive and active objects</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Systematic asynchronous communications
        towards active objects</emphasis></para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">No shared passive object</emphasis> ,
        Call-by-value between active objects</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Automatic continuations</emphasis> , a
        transparent delegation mechanism</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">wait-by-necessity</emphasis> , automatic
        and transparent futures</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Centralized and explicit
        control</emphasis> , libraries of Abstractions</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 remap="h2" id="Principles_html_reuse">
    <title>Reuse and Seamless: why and how do we achieve better reuse?</title>

    <para>Two key features:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Wait-by-necessity: inter-objects
        synchronization</emphasis>.
       Systematic, implicit and transparent futures. Ease the programming
       of synchronization and reuse of existing methods</para>
      </listitem>
      
      <listitem>
        <para><emphasis role="bold">Polymorphism between standard and active
        objects</emphasis></para>
    <itemizedlist>
      <listitem>
        <para>Type compatibility for classes and not just for interface</para>
      </listitem>

      <listitem>
        <para>Needed and done for the future objects as well</para>
      </listitem>

      <listitem>
        <para>Dynamic mechanism (dynamically achieve if needed)</para>
      </listitem>
    </itemizedlist>
   </listitem>
  </itemizedlist>

    <para><figure>
        <title>Polymorphism</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/polymorphism.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure></para>
  </sect1>

  <sect1 id="TinyHelloWorld" remap="h2">
    <title>Hello world ! (tiny example)</title>

    <para>This example implements the smallest program in ProActive. This is
    the easiest program you could write, using the Active Object concept. This
    is just to show quickly how code can be written, with minimal knowledge of
    the API.</para>

    <para>You can get a more complete 'hello world' example, with deployment
     on a remote host, further on in the manual (<xref linkend="HelloWorld"/>).</para>

    <para>A client object displays a <literal>String</literal> received from
    elsewhere (the original VM). This illustrates the creation of an Active
    Object.</para>

    <para>Only one class is needed: we have put the main method inside the
    class, which when deployed will be an Active Object.</para>

    <sect2 remap="h3">
      <title>The TinyHello class</title>

      <para>This class can be used as an Active Object, serving requests. Its
      creation involves the following steps:

      <itemizedlist>
        <listitem>
          <para>Provide an implementation for the required server-side
          functionalities</para>
        </listitem>

        <listitem>
          <para>Provide an empty, no-arg constructor</para>
        </listitem>

        <listitem>
          <para>Write a <literal>main</literal> method in order to instantiate
          one server object.</para>
        </listitem>
      </itemizedlist>

			</para>

 <example>
    <title>A possible implementation for the <literal>TinyHello</literal> class</title>
    <programlisting language="java"><textobject>
      <textdata fileref="../examples/hello/TinyHello.java" />
     </textobject></programlisting>
   </example>

    </sect2>

    <sect2 remap="h3">
      <title>Implement the required functionalities</title>

      <para>Implementing any remotely-accessible functionality is simply done
      through normal Java methods in a normal Java class, in exactly the same
      manner it would have been done in a non-distributed version of the same
      class. Here, the only method is <literal>sayHello</literal></para>
    </sect2>

    <sect2 remap="h3">
      <title>Creating the <literal>Hello</literal> Active Object</title>

      <para>Now that we know how to write the class that implements the
      required server-side functionalities, let us see how to create the
      server object. We want this active object to be created on the current
      node, which is why we use <literal>newActive</literal> with only two
      parameters (done in the <literal>main</literal> method).</para>

      <para>The code snippet which instantiates the
      <literal>TinyHello</literal> in the same VM is the following (in the
      <literal>main</literal> method):</para>

      <programlisting language="java">        TinyHello tiny = (TinyHello) ProActive.newActive(
                TinyHello.class.getName(), // the class to deploy
                null // the arguments to pass to the constructor, here none
            ); // which jvm should be used to hold the Active Object</programlisting>
    </sect2>

    <sect2 remap="h3">
      <title>Invoking a method on a remote object and printing out the
      message</title>

      <para>This is exactly like invoking a method on a local object of the
      same type. The user does not have to deal with catching
      exceptions related to the distant deployment.</para>

      <para>As already stated, the only modification brought to the code by
      ProActive is located at the place where active objects are created. All
      the rest of the code remains the same, which fosters software reuse. So
      the way to call the <literal>sayHello</literal> method in this example
      is the following (in the <literal>main</literal> method):</para>

      <programlisting language="java">        StringMutableWrapper received = tiny.sayHello(); // possibly remote call
        logger.info("On " + getHostName() + ", a message was received: " + received); // potential wait-by-necessity</programlisting>
    </sect2>

    <sect2 remap="h3">
      <title>Launching</title>

      <para>To launch the example, you may type:<screen>linux&gt; java -Djava.security.policy=scripts/proactive.java.policy \
            -Dlog4j.configuration=file:scripts/proactive-log4j \
            org.objectweb.proactive.examples.hello.TinyHello</screen> 
           
<screen>windows&gt; java -Djava.security.policy=scripts\proactive.java.policy \
              -Dlog4j.configuration=file:scripts\proactive-log4j \
               org.objectweb.proactive.examples.hello.TinyHello</screen></para>

      <para>There are also scripts in the <literal>scripts</literal>
      directory:<screen>linux&gt; cd scripts/unix/ 
linux&gt; tinyHello.sh</screen> 

<screen>windows&gt; cd scripts/windows 
windows&gt; tinyHello.bat</screen></para>

      <sect3 remap="h4">
        <title>The output</title>

        <screen>[apple unix]tinyhello.sh
--- Hello World tiny example ---------------------------------
&gt; This ClassFileServer is reading resources from classpath
ProActive Security Policy (proactive.runtime.security) not set. Runtime Security disabled
Created a new registry on port 1099
//apple.inria.fr/Node628280013 successfully bound in registry at //apple.inria.fr/Node628280013
Generating class: pa.stub.org.objectweb.proactive.examples.hello.Stub_TinyHello
Generating class: pa.stub.org.objectweb.proactive.core.util.wrapper.Stub_StringMutableWrapper
On apple/138.96.218.62, a message was received: Hello World!
  from apple/138.96.218.62
  at 03/11/2005 14:25:32
</screen>
      </sect3>
    </sect2>
  </sect1>
</chapter>