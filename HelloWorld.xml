<sect1 id="HelloWorld"><title>Hello world ! example</title>
<!--  File: /home/irosenbe/PA_new_doc/docbook-tuto/HelloWorld.html  -->
  
      <para>This example implements a very simple client-server application. A client
 object display a <literal>String</literal> received from a remote server. We will see how to write
 classes from which active and remote objects can be created, how to find a remote object and how
 to invoke methods on remote objects.</para>
      <sect2 >
        <title>The two classes</title>
        <para>Only two classes are needed: one for the server object <literal>Hello</literal>
 and one for the client that accesses it <literal>HelloClient</literal>.</para>
        <sect3 >
          <title>The Hello class</title>
          <para>This class implements server-side functionalities. Its creation involves
 the following steps:</para>
          <itemizedlist>
            <listitem>
              <para> Provide an implementation for the required server-side
 functionalities</para>
            </listitem>
            <listitem>
              <para> Provide an empty, no-arg constructor</para>
            </listitem>
            <listitem>
              <para> Write a <literal>main</literal> method in order to instantiate one server
 object and register it with an URL.</para>
            </listitem>
</itemizedlist>
          <para>Here is a possible implementation for the <literal>Hello</literal> class:</para>
          
          
          
<screen>
public class Hello {
  private String name;
  private String hi = &quot;Hello world&quot;;
  private java.text.DateFormat dateFormat = new java.text.SimpleDateFormat(&quot;\
dd/MM/yyyy HH:mm:ss&quot;);
  public Hello() {
  }
  public Hello(String name) {
    this.name = name;
  }
  public String sayHello() {
    return hi + &quot; at &quot; + dateFormat.format(new java.util.Date())+
        &quot; from node : &quot; + org.objectweb.proactive.ProActive.getBodyOnThis().g\
etNodeURL();
  }
  public static void main(String[] args) {
    // Registers it with an URL
    try {
      // Creates an active instance of class HelloServer on the local node
      Hello hello = (Hello)org.objectweb.proactive.ProActive.newActive(Hell\
o.class.getName(), 
                             new Object[]{&quot;remote&quot;});
      java.net.InetAddress localhost = java.net.InetAddress.getLocalHost();
      org.objectweb.proactive.ProActive.register(hello, &quot;//&quot; + localhost.getH\
ostName() + &quot;/Hello&quot;);
    } catch (Exception e) {
      System.err.println(&quot;Error: &quot; + e.getMessage());
      e.printStackTrace();
    }
  }
}
</screen>
         
          
         <sect4 >
          <title>Implement the required functionalities</title>
          <para>Implementing any remotely-accessible functionality is simply done through
 normal Java methods in a normal Java class, in exactly the same manner it would have been done in
 a non-distributed version of the same class. This has to be contrasted with the RMI approach,
 where several more steps are needed:</para>
          <itemizedlist>
            <listitem>
              <para> Define a remote interface for declaring the remotely-accessible
 methods.</para>
            </listitem>
            <listitem>
              <para> Rewrite the class so that it inherits from <literal>java.rmi.server.UnicastRemoteObject</literal>, which is the root class of all remote
 objects.</para>
            </listitem>
            <listitem>
              <para> Add remote exceptions handling to the code.</para>
            </listitem>
</itemizedlist>
</sect4>
        <sect4 >
          <title>Why an empty no-arg constructor ?</title>
          <para>You may have noticed that class <literal>Hello</literal> has a constructor with
 no parameters and an empty implementation. The presence of this empty no-arg constructor is
 imposed by ProActive and is actually a side-effect of ProActive&#39;s transparent implementation
 of active remote objects (as a matter of fact, this side-effect is caused by ProActive being
 implemented on top of a 100% Java metaobject protocol). If no such constructor is provided,
 active objects cannot be created.</para>
          
          <para>
 If no constructor at all is provided, active objects can still be created because, in this
 specific case, all Java compilers provide a default no-arg empty constructor. If a no-arg
 constructor is provided but its implementation is not empty, unwanted behavior may appear because
 the no-arg constructor is always called when an active object is created, whatever code the user
 can write.</para>
</sect4>
        <sect4 >
          <title>Creating the remote <literal>Hello</literal> object</title>
          <para>Now that we know how to write the class that implements the required
 server-side functionalities, let us see how to create the server object. In ProActive, there is
 actually no difference between a server and a client object as both are remote objects.Creating
 the active object is done through <emphasis>instantiation-based creation</emphasis>. We want this active object
 to be created on the current node, which is why we use <literal>newActive</literal> with only two
 parameters. In order for the client to obtain an initial reference onto this remote object, we
 need to register it in the registry (which is actually the well-known <literal>rmiregistry</literal>)
 with a valid RMI URL.</para>
</sect4>
</sect3 ><sect2 >
          <title>The <literal>HelloClient</literal> Class</title>
          <para>The responsibility of this class is first to locate the remote server object, then to invoke a
 method on it in order to retrieve a message, and finally display that message.</para>
          
<para>HelloClient.java</para>
<!-- <title>HelloClient.java</title>   -->
<screen>
public class HelloClient {
  public static void main(String[] args) {
    Hello myServer;
    String message;
    try {
      // checks for the server&#39;s URL
      if (args.length == 0) {
        // There is no url to the server, so create an active server within\
 this VM
        myServer = (Hello)org.objectweb.proactive.ProActive.newActive(Hello\
.class.getName(), 
                          new Object[]{&quot;local&quot;});
      } else {
        // Lookups the server object
        System.out.println(&quot;Using server located on &quot; + args[0]);
        myServer = (Hello)org.objectweb.proactive.ProActive.lookupActive(He\
llo.class.getName(), 
                          args[0]);
      }
      // Invokes a remote method on this object to get the message
      message = myServer.sayHello();
      // Prints out the message
      System.out.println(&quot;The message is : &quot; + message);
    } catch (Exception e) {
      System.err.println(&quot;Could not reach/create server object&quot;);
      e.printStackTrace();
      System.exit(1);
    }
  }
}
</screen>
        <sect4 >
          <title>Looking up a remote object</title>
          <para>The operation of <emphasis>lookup</emphasis> simply means obtaining a reference onto an
 object from the URL it is bound to. The return type of method <literal>Proactive.lookupActive()</literal> is <literal>Object</literal>, then we need to cast it down into
 the type of the variable that holds the reference (<literal>Hello</literal> here). If no object is
 found at this URL, the call to <literal>Proactive.lookupActive()</literal> returns <literal>null</literal>.</para>
</sect4>
        <sect4 >
          <title>Invoking a method on a remote object</title>
          <para>This is exactly like invoking a method on a local object of the same type.
 The user does not have to deal with catching distribution-related exceptions like, for example,
 when using RMI or CORBA. Future versions of ProActive will provide an exception handler mechanism
 in order to process these exceptions in a separate place than the functional code. As class <literal>String</literal> is <literal>final</literal>, there cannot be any asynchronism here since the object
 returned from the call cannot be replaced by a future object (this restriction on <literal>final</literal> classes is imposed by ProActive&#39;s implementation).</para>
</sect4>
        <sect4 >
          <title>Printing out the message</title>
          <para>As already stated, the only modification brought to the code by ProActive
 is located at the place where active objects are created. All the rest of the code remains the
 same, which fosters software reuse.</para>
</sect4>
</sect3>
</sect2><sect1 >
          <title>Hello World within the same VM</title>
          <para>In order to run both the client and server in the same VM, the client
 creates an active object in the same VM if it doesn&#39;t find the server&#39;s URL. The code
 snippet which instantiates the Server in the same VM is the following:</para>
<screen>
if (args.length == 0) {
  // There is no url to the server, so create an active server within this \
VM
  myServer = (Hello)org.objectweb.proactive.ProActive.newActive(Hello.class\
.getName(), new Object[]{&quot;local&quot;});
}
</screen>
          <para>To launch the Client and the Server, just type:</para>
          
<screen>linux&gt; java -Djava.security.policy=scripts/proactive.java.policy
 -Dlog4j.configuration=file:scripts/proactive-log4j
 org.objectweb.proactive.examples.hello.HelloClient</screen>
<screen>windows&gt; java -Djava.security.policy=scripts\unix\proactive.java.policy
 -Dlog4j.configuration=file:scripts\unix\proactive-log4j
 org.objectweb.proactive.examples.hello.HelloClient &amp;</screen>
</sect2>
        <sect2 >
          <title>Hello World from another VM on the same host</title>
        <sect3 >
          <title>Starting the server</title>
          <para>Just start the <literal>main</literal> method in the <literal>Hello</literal> class.</para>
<screen>linux&gt; java -Djava.security.policy=scripts/proactive.java.policy
 -Dlog4j.configuration=file:scripts/proactive-log4j
 org.objectweb.proactive.examples.hello.Hello</screen>
<screen>windows&gt; java -Djava.security.policy=scripts\proactive.java.policy
 -Dlog4j.configuration=file:scripts\proactive-log4j org.objectweb.proactive.examples.hello.Hello
 &amp;</screen>
</sect3>
        <sect3 >
          <title>Launching the client</title>
          <screen>linux&gt; java -Djava.security.policy=scripts/proactive.java.policy
 -Dlog4j.configuration=file:scripts/proactive-log4j
 org.objectweb.proactive.examples.hello.HelloClient //localhost/Hello</screen>
<screen>windows&gt; java -Djava.security.policy=scripts\proactive.java.policy
 -Dlog4j.configuration=file:scripts\proactive-log4j
 org.objectweb.proactive.examples.hello.HelloClient //localhost/Hello</screen>
</sect3>
</sect2 ><sect1 >
          <title>Hello World from abroad: another VM on a different host</title>
      <sect3 >
          <title>Starting the server</title>
          <para>Log on to the server&#39;s host, and launch the <literal>Hello</literal> class.</para>
          <screen>linux remoteHost&gt; java -Djava.security.policy=scripts/proactive.java.policy
 -Dlog4j.configuration=file:scripts/proactive-log4j
 org.objectweb.proactive.examples.hello.Hello</screen>
<screen>windows remoteHost&gt; java -Djava.security.policy=scripts\proactive.java.policy
 -Dlog4j.configuration=file:scripts\proactive-log4j org.objectweb.proactive.examples.hello.Hello
 &amp;</screen>
</sect3>
        <sect3 >
          <title>Launching the client</title>
          <para>Log on to the client Host, and launch the client</para>
          <screen>linux clientHost&gt; java -Djava.security.policy=scripts/proactive.java.policy
 -Dlog4j.configuration=file:scripts/proactive-log4j
 org.objectweb.proactive.examples.hello.HelloClient //remoteHost/Hello</screen>
<screen>windows clientHost&gt; java -Djava.security.policy=scripts\proactive.java.policy
 -Dlog4j.configuration=file:scripts\proactive-log4j
 org.objectweb.proactive.examples.hello.HelloClient //remoteHost/Hello</screen>
          
</sect3>
      </sect2>
</sect1>
