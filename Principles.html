<html>
<head>
<title>ProActive - Principles</title>
<LINK rel="stylesheet" href="ProActive.css">
</head>            
<body bgcolor="white">
<!--
 Header : start 
~~~ -->
<table width="100%">
<tr>
<td align="left" valign="middle">
    <table cellpadding="2" cellspacing="0" border="1">
    <tr>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="../../../../overview-summary.html">back to API</a>&nbsp;&nbsp;</td>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="index.html">back to index</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="index.html">prev</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="Installation.html">next</a>&nbsp;&nbsp;</td>
    </tr>
    </table>
</td>
<td  align="right" valign="top">
<img src="ProActiveLogo200x34.gif"/>
</td>
</tr>
</table>
<hr>
<!-- Link to index : end -->

<h1>Principles</h1>

    <!-- Body -->
    <h2><a name="intro"></a>Seamless sequential, multthreaded and distributed</h2>
      <p class="textNormal">
      Most of the time, activities and distribution are not known at the beginning, and change over time. <b>Seamless implies reuse, smooth and incremental transitions</b>.</p>
    <div align="center"><img src="proActiveModelColor.gif"/></div><br>
      <p class="textNormal">
    A huge gap yet exists between multithreaded and distributed Java applications which forbids code reuse in order to build distributed
    applications from multithreaded applications. Both JavaRMI and JavaIDL, as examples of distributed object libraries in Java, put a heavy
      burden on the programmer because they require deep modifications of existing code in order to turn local objects into remote-accessible
    ones. In these systems, remote objects need to be accessed through some specific interfaces. As a consequence, these distributed
    objects libraries do not allow polymorphism between local and remote objects. This feature is our first requirement for a metacomputing
      framework. It is strongly required in order to let the programmer concentrate first on modeling and algorithmic issues rather than
    lower-level tasks such as object distribution, mapping and load balancing. 
      </p>

    <h2><a name="active"></a>Active objects: Unifying threads and remote objects</h2>
      Given a standard object, we provide the ability to give it: 
      <ul class="listWithSpace">
    <li class="textNormal">location transparency </li>
    <li class="textNormal">activity transparency </li>
    <li class="textNormal">synchronization </li>
      </ul>
      <h3>==> only with modifications of the instanciation code ! </h3>
      Three ways to transform a standard object into an active one: 
    <h3>Class-based </h3>
<blockquote><pre>
Object[] params = new Object[] { new Integer (26), "astring" };
A a = (A) <font color="red">ProActive.newActive("example.A", params, node)</font>;
</pre></blockquote>

    <h3>Instanciation-based</h3>
    <blockquote><pre>
public class AA extends A implements Active {}

Object[] params = new Object[] { new Integer (26), "astring" };
A a = (A) <font color="red">ProActive.newActive("example.AA", params, node)</font>;
</pre></blockquote>

    <h3>Object-based</h3>
    <p class="textNormal">
Allows to turn active and remote objects for which you do not have the source code; a necessary feature in the context of code mobility.
</p>
<blockquote><pre>
A a = new A (26, "astring");
a = (A) <font color="red">ProActive.turnActive(a, node)</font>;
</pre></blockquote>
<b class="textSmall">Notes: </b>
<i class="textSmall">Node allows to control the mapping</i></td>

<h2><a name="model"></a>Model of Computation: Based on previous works and studies</h2>
        <ul class="listWithSpace">
          <li class="textNormal"><b>Heterogeneous model</b> both passive and active objects</li>
          <li class="textNormal"><b>Systematic asynchronous communications towards active objects</b></li>
          <li class="textNormal"><b>No shared passive object</b>, Call-by-value between active objects</li> 
          <li class="textNormal"><b>Automatic continuations</b>, a transparent delegation mechanism</li>
          <li class="textNormal"><b>wait-by-necessity</b>, automatic and transparent futures</li>
          <li class="textNormal"><b>Centralized and explicit control</b>, libraries of Abstractions</li>
        </ul>

<h2><a name="reuse">Reuse and Seamless: why and how do we achieve better reuse ?</a></h2>
<p class="textNormal">Two key features :</p>
        <ul class="listWithSpace">
        <li class="textNormal">
        <b>Wait-by-necessity : inter-objects synchronization</b><br>
        <p class="textNormal">Systematic, implicit and transparent futures. Ease the programming of synchronization and reuse of existing methods</p>
        </li>
          <li class="textNormal"><b>Polymorphism between standard and active objects</b>
        <ul>
          <li class="textNormal">Type compatibility for classes and not just for interface</li>
          <li class="textNormal">Needed and done for the future objects as well</li>
          <li class="textNormal">Dynamic mechanism (dynamically achieve if needed)</li> 
        </ul></li>
        </ul>
    <div align="center"><img src="polymorphism.gif"/></div><br>

  </body>
<!--
 Footer : start 
~~~ -->
<br><hr><div align="right" class="textSmall">Copyright &#169; June 2002 INRIA All Rights Reserved.</p>
<!-- Footer : end -->

</html>
