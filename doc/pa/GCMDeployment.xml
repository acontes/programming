<?xml version="1.0" encoding="utf-8"?><chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="GCMDeployment">
<info>
<title xml:id="ProActiveGridComponentModelDeployment_64">ProActive Grid Component Model Deployment</title>
	</info>


	<section xml:id="gcmd_introduction">
<info>
<title xml:id="Introduction_64">Introduction</title>
		</info>

		<para>
			The GCM Deployment is split in two parts, one for grid administrators and the other for grid application developers. On the grid
			administration side, the administrator will write a Deployment Descriptor that will describe what resources the grid provides, and how
			these resources are acquired. On the application side, the developer will write an Application Descriptor that will describe how the
			application is launched, and what resources it needs. The link between the two sides is made through references from the Application
			Descriptor to one or several Deployment Descriptors.
		</para>
	</section>



	<section xml:id="gcmd_appli"><info><title xml:id="ProActiveDeploymentAPI_64">ProActive Deployment API</title>
		</info>

		<para>There are several ways the grid resources can be used by a deployed application.
		The application may require a fixed set of resources, or it may be flexible enough to work on any
		amount of resources, or finally may require a minimum amount of resources and yet be able to scale
		as more resources become available.</para>

		<para>In all cases, the application must start by creating a <code>GCMApplication</code> object through
		<code>PAGCMDeployment.loadApplicationDescriptor()</code>, and call <code>GCMApplication.startDeployment()</code>. The
		application must quit through <code>GCMApplication.kill()</code>.</para>
		
		<section xml:id="ResourcesfixedbytheapplicationSPMD_64"><info><title>Resources fixed by the application (SPMD)</title>
			</info>

			<para>In this case the application knows the amount of resources it requires. The acquisition of these resources
			 by the application is done as follows :</para>
			 
			 <itemizedlist>
					<listitem>
						<para>get the required virtual nodes through <code>GCMApplication.getVirtualNode(String vnName)</code>,
						 or <code>GCMApplication.getVirtualNodes()</code></para>
					</listitem>
					<listitem>
						<para>For each virtual node, use <code>GCMVirtualNode.getNewNodes()</code> as many times as needed,
						until the virtual node has the expected numbers of physical nodes to run on.
						<code>getNewNodes()</code> will return the list of Nodes that have been acquired since the last time
						it was called. Calls to it should be separated by calls to <code>Thread.sleep()</code>. 
						</para>
					</listitem>
			</itemizedlist>
			
		</section>

		<section xml:id="Resourcesfixedbytheapplicationdeployer_64"><info><title>Resources fixed by the application deployer</title>
			</info>

			<para>In this case the application has no specific requirement on the resources it uses : the more the better.
			This is the simplest of the cases : the application only has to call <code>GCMApplication.waitReady()</code>.
			This will block until all Virtual Nodes have their configured number of physical Nodes.
			Note that this may block forever if a Virtual Node does not to have a limited number of nodes after which it
			is in 'ready' state	(the Virtual Node is said to be 'greedy', <code>GCMVirtualNode.isGreedy()</code> will return true).   
			
			</para>
		</section>

		<section xml:id="OndemandScalability_64"><info><title>On demand Scalability</title>
			</info>

			<para>In the case the application is able to expand on new resources as they become available.
			This is a extension of the two other cases, in that it can work whether the application has fixed minimum requirements
			or not. Once the initial deployment phase is finished, the application should call <code>GCMApplication.getVirtualNodes()</code>
			to obtain the list of configured virtual nodes,
			and then subscribe to the node attachment notifications for each of them (<code>GCMVirtualNode.subscribeNodeAttachment()</code> ).			
			In the notification handler, the application should deal with the newly acquired node appropriately.
			</para>
		</section>


	</section>

	<section xml:id="GCMDeploymentDescriptors_64"><info><title>GCM Deployment Descriptors</title>
		</info>


		<section xml:id="HostInformation_64"><info><title>Host Information</title>
			</info>

			<para>
				The HostInfo data structure describes a single machine and the environment it provides, with the following information:
				<itemizedlist>
					<listitem>
						<para>userName : (string) the name of the user under which this host can be accessed</para>
					</listitem>
					<listitem>
						<para>homeDirectory : (absolute path) the home directory of the user</para>
					</listitem>
					<listitem>
						<para>os : (one of "unix" or "windows") the operating system the host is running</para>
					</listitem>
					<listitem>
						<para>
							hostCapacity : (positive integer) the number of processes (VM or other executable) that this host can handle (default
							value is 1)
						</para>
					</listitem>
					<listitem>
						<para>vmCapacity : (positive integer) the number of nodes a single VM on this host can handle (default value is 1)</para>
					</listitem>
					<listitem>
						<para>id : (ID) an ID identifying the host</para>
					</listitem>
				</itemizedlist>

			</para>
		</section>

		<section xml:id="Bridges_64"><info><title>Bridges</title>
			</info>

			<para>
				A bridge is meant to represent a frontend to a computing resource. Many grid architectures have such a feature : each physical machine
				is not accessible directly, the user must instead go through a single machine called a front-end. In a deployment descriptor, a bridge
				is a gateway toward either :
				<itemizedlist>
					<listitem>
						<para>a host</para>
					</listitem>
					<listitem>
						<para>a set of groups</para>
					</listitem>
					<listitem>
						<para>another bridge</para>
					</listitem>
				</itemizedlist>

				A bridge is defined as a base structure meant to be derived. The base structure only defines an id (string).
			</para>

			<section xml:id="RSH_101"><info><title>RSH</title>
				</info>

				<para>
					An RSH bridge element can have the following attributes :
					<itemizedlist>
						<listitem>
							<para>id (string) : the id of the bridge connector corresponding to this definition</para>
						</listitem>
						<listitem>
							<para>hostname (string) : the network hostname of the physical machine which acts as the bridge</para>
						</listitem>
						<listitem>
							<para>username (string, optional) : the user name under which the machine can be accessed</para>
						</listitem>
						<listitem>
							<para>commandPath (string, optional) : the path of rsh client to use</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>


			<section xml:id="SSH_640"><info><title>SSH</title>
				</info>

				<para>
					An SSH bridge element can have the follow child element :
					<itemizedlist>
						<listitem>
							<para>privateKey (path string) : the file of the private SSH key needed to access the bridge</para>
						</listitem>
					</itemizedlist>

					An SSH bridge element can have the following attributes :
					<itemizedlist>
						<listitem>
							<para>id (string) : the id of the bridge connector corresponding to this definition</para>
						</listitem>
						<listitem>
							<para>hostname (string) : the network hostname of the physical machine which acts as the bridge</para>
						</listitem>
						<listitem>
							<para>username (string, optional) : the user name under which the machine can be accessed</para>
						</listitem>
						<listitem>
							<para>commandPath (string) : the path of the ssh client to use</para>
						</listitem>
						<listitem>
							<para>commandOptions (string) : options to pass to the ssh command</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>
		</section>

		<section xml:id="Groups_64"><info><title>Groups</title>
			</info>

			<para>
				A Group is a data structure defining a set of machines with identical configuration (like a cluster). It is meant as a base structure
				which can be derived in an Object-Oriented manner to implement any kind of group. There currently are two kinds of groups :
				<orderedlist>
					<listitem>
						<para>"direct" groups</para>
					</listitem>
					<listitem>
						<para>job schedulers</para>
					</listitem>
				</orderedlist>
			</para>
			<para>It is therefore possible to define a standard-compliant deployment descriptor even on a grid which has its own job scheduler.</para>
			<para>All group protocols have the following child elements :</para>
			<itemizedlist>
				<listitem>
					<para>environment (environment) : the environment for the command and the following attributes</para>
				</listitem>
			</itemizedlist>
			<para>and the following attributes</para>
			<itemizedlist>
				<listitem>
					<para>id (ID) : the id of the group this element represents</para>
				</listitem>
				<listitem>
					<para>commandPath (path string) : path of the command which is used to submit a job to the group protocol</para>
				</listitem>
			</itemizedlist>

			<section xml:id="CCS_64"><info><title>CCS</title>
				</info>

				<para>
					This group handles Microsoft’s Compute Cluster Server. The CCS group definition has the following child elements :
					<itemizedlist>
						<listitem>
							<para>
								resources : the resources that will be allowed to the job. This element can have two children :
								<itemizedlist>
									<listitem>
										<para>cpus (positive integer) : the number of CPUs allocated for the job</para>
									</listitem>
									<listitem>
										<para>runtime (time) : the maximum runtime allowed for the job</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para>stdout (path string) : path of the file where the standard output of the job will be stored</para>
						</listitem>
						<listitem>
							<para>stderr (path string) : path of the file where the standard error of the job will be stored</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>

			<section xml:id="LSF_64"><info><title>LSF</title>
				</info>

				<para>
					Group definition for the LSF scheduler. The LSF group definition has the following child elements :
					<itemizedlist>
						<listitem>
							<para>
								resource (string) : this element has the following attributes :
								<itemizedlist>
									<listitem>
										<para>(positive integer) : number of processors requested</para>
									</listitem>
									<listitem>
										<para>walltime (time) : maximum time allowed for the job</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para>processorsNumber (positive integer) : minimum number of processors requested to run the job</para>
						</listitem>
						<listitem>
							<para>
								resourceRequirement (string) : a resource requirement string as defined by the lsf documentation (‘lsfintro’ manpage)
							</para>
						</listitem>
					</itemizedlist>
				</para>
				<para>
					It also has the following attributes
					<itemizedlist>
						<listitem>
							<para>interactive (boolean) : whether the job is interactive or not</para>
						</listitem>
						<listitem>
							<para>jobName (string) : name of the job</para>
						</listitem>
						<listitem>
							<para>queue (string) : name of the queue the job will be submitted in</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>

			<section xml:id="OAR_64"><info><title>OAR</title>
				</info>

				<para>
					Group definition for the OAR job scheduler [15]. The OAR group definition has the following child elements :
					<itemizedlist>
						<listitem>
							<para>
								resource (string) : this element has the following attributes :
								<itemizedlist>
									<listitem>
										<para>nodes (positive integer) : number of nodes requested</para>
									</listitem>
									<listitem>
										<para>cpu (positive integer) : number of CPUs requested</para>
									</listitem>
									<listitem>
										<para>core (positive integer) : number of cores requested</para>
									</listitem>
									<listitem>
										<para>walltime (time) : maximum time allowed for the job</para>
									</listitem>
								</itemizedlist>

								It also can have a string content which is passed verbatim–o the ‘--resource’ option of the oarsub command.
							</para>
						</listitem>

						<listitem>
							<para>directory (path string) : the working directory of the job script</para>
						</listitem>
						<listitem>
							<para>stdout (path string) : path of the file where the standard output of the job will be stored</para>
						</listitem>
						<listitem>
							<para>stderr (path string) : path of the file where the standard error of the job will be stored</para>
						</listitem>
					</itemizedlist>
				</para>
				<para>
					It has the following attributes :
					<itemizedlist>
						<listitem>
							<para>
								interactive (boolean) : start an interactive job. If true, open a login shell on the first node instead of running a
								script (default is false).
							</para>
						</listitem>
						<listitem>
							<para>queue (string) : name of the queue to submit the job to.</para>
						</listitem>
						<listitem>
							<para>type (‘deploy’, ‘besteffort’, ‘cosystem’, ‘checkpoint’, ‘timesharing’) : job type – the default is ‘deploy’.</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>

			<section xml:id="PBS_64"><info><title>PBS</title>
				</info>

				<para>
					Group definition for the PBS/Torque job scheduler. The PBS/Torque group definition has the following child elements :
					<itemizedlist>

						<listitem>
							<para>
								resource (string) : this element has the following attributes :
								<itemizedlist>
									<listitem>
										<para>nodes (positive integer) : number of nodes requested</para>
									</listitem>
									<listitem>
										<para>ppn (positive integer) : number of CPUs requested</para>
									</listitem>
									<listitem>
										<para>walltime (time) : maximum time allowed for the job</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para>nodes (positive integer) : number of nodes requested</para>
						</listitem>
						<listitem>
							<para>processorsPerNode (positive integer) : number of processors per node requested</para>
						</listitem>
						<listitem>
							<para>
								mailWhen (combination of Abort, Begin, End separated by ‘|’) : when to send an email (Abort : if the job is aborted,
								Begin : when the job is started, End : when the job terminates)
							</para>
						</listitem>
						<listitem>
							<para>mailTo (comma-seperated list of email addresses) : where the job status emails should be sent</para>
						</listitem>
						<listitem>
							<para>joinOutput (boolean) : if true, join the output of stderr to stdout</para>
						</listitem>
						<listitem>
							<para>stdout (path string) : path of the file where the standard output of the job will be stored</para>
						</listitem>
						<listitem>
							<para>stderr (path string) : path of the file where the standard error of the job will be stored</para>
						</listitem>
					</itemizedlist>

					It has the following attributes :
					<itemizedlist>
						<listitem>
							<para>
								queue (string) : destination queue for the job. The argument can be of the following format :
								<itemizedlist>
									<listitem>
										<para>queue : a queue on the default server</para>
									</listitem>
									<listitem>
										<para>@server : the default queue on the server</para>
									</listitem>
									<listitem>
										<para>queue@server : the queue on the given server</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para>jobName (string 15 chars long, no whitespace, first char must be alphabetic) : the name of the job</para>
						</listitem>
						<listitem>
							<para>interactive (boolean) : whether the job is interactive or not</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>

			<section xml:id="Prun_64"><info><title>Prun</title>
				</info>

				<para>
					Group definition for the PRUN run server. The PRUN group definition has the following child elements :

					<itemizedlist>
						<listitem>
							<para>
								resource (string) : this element has the following attributes :
								<itemizedlist>
									<listitem>
										<para>nodes (positive integer) : number of nodes requested</para>
									</listitem>
									<listitem>
										<para>ppn (positive integer) : number of CPUs requested</para>
									</listitem>
									<listitem>
										<para>walltime (time) : maximum time allowed for the job</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>

						<listitem>
							<para>stdout (path string) : name of the file in which the results will be printed</para>
						</listitem>
					</itemizedlist>

					It has no attribute.
				</para>
			</section>

			<section xml:id="HostList_64"><info><title>Host List</title>
				</info>

				<para>
					A host list can be used with SSH and RSH groups as a shorthand to specify several machine names in a compact form. The format of a
					host list is a whitespace-separated list of name patterns or hostnames. A name pattern describes a set of hostnames with a common
					root. The format is as follows.
					<programlisting>
						
&lt;root name&gt;&lt;interval&gt; 

					</programlisting>

					with root name being an alphanumeric string (only letters and digits, no spaces or punctuation signs), and interval defining a set
					of numerical values in the form of an interval or list of values, possibly followed by an exclusion interval or list of values.
					The general form of an interval is:
					<programlisting>
						

[&lt;value set&gt;]^[&lt;value set&gt;]

					</programlisting>

					or simply
					<programlisting>
						

[&lt;value set&gt;] 

					</programlisting>

					if no exclusion interval is needed.

				</para>

				<para>
					A value set is a coma-seperated list of integers or integers pairs separated by a dash, meaning an interval of values. The values
					of an interval must be specified in increasing order, and the generated values will be in increasing order. Also, the first
					integer of an interval can have leading zeroes to indicate the number of digits (numbers will be padded with zeroes if needed).
					Some examples:
					<itemizedlist>
						<listitem>
							<para>host[0-5]: host0, host1 … host5;</para>
						</listitem>
						<listitem>
							<para>host[0-5]^[4]: host0, host1, host2, host3, host5;</para>
						</listitem>
						<listitem>
							<para>host[0-10]^[4-6]: host0, host1, host2, host3, host7, host8, host9, host10;</para>
						</listitem>
						<listitem>
							<para>host[00-5]: host00, host01, host02… host05;</para>
						</listitem>
						<listitem>
							<para>host[1, 004-7, 09]: host1, host004, host005, host006, host007, host09.</para>
						</listitem>
					</itemizedlist>
				</para>

			</section><!-- host list def -->

			<section xml:id="RSH_64"><info><title>RSH</title>
				</info>

				<para>
					The RSH Group has the following child elements :
					<itemizedlist>
						<listitem>
							<para>(host list) : the list of hosts to connect to</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>

			<section xml:id="SSH_64"><info><title>SSH</title>
				</info>

				<para>
					The SSH Group has the following child elements :
					<itemizedlist>
						<listitem>
							<para>(host list) : the list of hosts to connect to</para>
						</listitem>
						<listitem>
							<para>privateKey (path string) : the file of the private SSH key needed to access the host</para>
						</listitem>
						<listitem>
							<para>commandOptions (string) : the list of options which will be passed to the ssh command</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>

		</section>

	</section>

	<section xml:id="GCMApplicationdescriptor_64"><info><title>GCM Application descriptor</title>
		</info>

		<section xml:id="Executable_64"><info><title>Executable</title>
			</info>

			<para>
				This type of application describes the launch of a stand-alone executable on the grid. It can have the following child elements :
			</para>

			<itemizedlist>
				<listitem>
					<para>
						nodeProvider (empty element with a single ‘refId’ attribute) : the id of a node provider (defined in the &lt;resources&gt;
						part). There can be any number of such element.
					</para>
				</listitem>
				<listitem>
					<para>
						command : the command which will be run on the portion of the grid defined by the specified node providers. The contents of
						this element are described below.
					</para>
				</listitem>
			</itemizedlist>

			<para>This element can have the following attribute :</para>
			<itemizedlist>
				<listitem>
					<para>
						instances (one of “onePerHost”, “onePerVM”, “onePerCapacity”) : the number of instances of the command which will be run
					</para>
				</listitem>
			</itemizedlist>

			<para>The &lt;command&gt; element can have the following children (in this specified order) :</para>
			<itemizedlist>
				<listitem>
					<para>path (path string) : the path of the executable</para>
				</listitem>

				<listitem>
					<para>arg (string) : the arg string which will be passed to the command. There can be any number of such element.</para>
				</listitem>
				<listitem>
					<para>filetransfer (file transfer) : the files which which should be transferred prior to running the command.</para>
				</listitem>
			</itemizedlist>

			<para>It can have the following attribute :</para>
			<itemizedlist>
				<listitem>
					<para>
						name (string) : name of the executable. If a &lt;path&gt; child element is present, the value of this attribute will be
						appended to the value of the %lt;path&gt; child element.
					</para>
				</listitem>
			</itemizedlist>


		</section>


		<section xml:id="ProActive_64"><info><title>ProActive</title>
			</info>

			<para>This element describes a ProActive-based applicatin. It can have the following children :</para>

			<itemizedlist>
				<listitem>
					<para>configuration : various configuration parameters - this element is described below</para>
				</listitem>
				<listitem>
					<para>technicalServices (technical services) : the set of technical services global to this instance of ProActive</para>
				</listitem>
			</itemizedlist>

			<para>the configuration element can have the following child elements :</para>
			<itemizedlist>
				<listitem>
					<para>bootClasspath (simple classpath) : the boot classpath for the JVM</para>
				</listitem>

				<listitem>
					<para>java (path string) : the path to the Java executable</para>
				</listitem>
				<listitem>
					<para>jvmarg (string) : arguments passed to the JVM</para>
				</listitem>
				<listitem>
					<para>applicationClasspath (classpath) : classpath for the application</para>
				</listitem>
				<listitem>
					<para>
						proactiveClasspath (classpath) : classpath used to override the standard ProActive classpath computed from its installation
						location
					</para>
				</listitem>
				<listitem>
					<para>securityPolicy (relative path) : path to the Java security policy file</para>
				</listitem>
				<listitem>
					<para>
						proactiveSecurity : security policy for application and runtime. This element has two children :
						<itemizedlist>
							<listitem>
								<para>
									applicationPolicy (relative path) : path to Java security policy file that will be applied on the application's
									objects deployed at runtime, like nodes and active objects
								</para>
							</listitem>
							<listitem>
								<para>
									runtimePolicy (relative path) : path to Java security policy file that will be applied on the ProActive Runtime
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>log4jProperties (relative path) : path to the Java log4j configuration file</para>
				</listitem>
				<listitem>
					<para>userProperties (relative path) : path to the Java properties file</para>
				</listitem>
				<listitem>
					<para>virtualNode (virtual node) : description of a virtual node. There can be any number of such element</para>
				</listitem>

			</itemizedlist>

			<para>The &lt;proactive&gt; element can have the following attributes :</para>
			<itemizedlist>
				<listitem>
					<para>relpath (path string) : the location of the ProActive installation</para>
				</listitem>
				<listitem>
					<para>
						base (one of ‘HOME’, ‘ROOT’) : base location of the ProActive installation : HOME is the user’s home directory, ROOT is the
						root directory of the system.
					</para>
				</listitem>
			</itemizedlist>


			<para>A &lt;virtualNode&gt; element can have the following children :</para>
			<itemizedlist>
				<listitem>
					<para>
						nodeProvider (reference to a node provider) : the node provider which will provide the ProActive nodes for this virtual node –
						see below for description.
					</para>
				</listitem>
				<listitem>
					<para>
						technicalServices (technical service) : a technical service specific to this virtual node. There can be any number of such
						children.
					</para>
				</listitem>
			</itemizedlist>

			<para>A virtualNode element can also have the following attributes :</para>
			<itemizedlist>
				<listitem>
					<para>id (string) : a string identifying this virtual node</para>
				</listitem>
				<listitem>
					<para>
						capacity (positive integer) : the capacity requested by this virtual node (that is, the total number of nodes it will
						request from the node providers which are affected to it). If no capacity is specified, then the Virtual Node will try to get as many nodes as possible. A such Virtual Node is called greedy.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				A &lt;nodeProvider&gt; within a &lt;virtualNode&gt; can only have &lt;technicalServices&gt; child elements. These describe technical
				services specific to this node provider. A &lt;nodeProvider&gt; can also have the following attributes :
			</para>
			<itemizedlist>
				<listitem>
					<para>refid (string) : the id of the node provider (as defined in the resources element)</para>
				</listitem>
				<listitem>
					<para>
						capacity (positive integer or “max”) : the capacity of this ProActive node provider (that is, the number of ProActive nodes
						which will be requested from it)
					</para>
				</listitem>
			</itemizedlist>

		</section>

	</section>

	<section xml:id="FAQ_64"><info><title>FAQ</title>
		</info>

		<para/>
	</section>

	<section xml:id="Tutorial_64"><info><title>Tutorial</title>
		</info>

		<para>
			This tutorial shows how to deploy a grid-enabled application through the GCM standard. It will present the points of view of both the grid
			administrator and the application developer.
		</para>



		<!-- 
			
			Deployment Descriptor Tutorial
			
		-->
		<section xml:id="FortheGridAdministratorcreatingadeploymentdescriptor_64"><info><title>For the Grid Administrator : creating a deployment descriptor</title>
			</info>

			<para>
				The task of a grid administrator is to make a model of his grid resources through a GCM Deployment Descriptor. Several examples are
				available in the ProActive distribution. The deployment descriptor should represent the resources of the grid.

				A deployment descriptor has the following XML structure:

				<programlisting>
					
&lt;environment&gt;
		&lt;descriptorVariable …/&gt;
…
&lt;/environment&gt;

&lt;resources&gt;
		&lt;bridge …/&gt;
		&lt;group&gt;
			&lt;host …/&gt;
			&lt;host …/&gt;
			…
		&lt;/group&gt;
	…
&lt;/resources&gt;

&lt;acquisition&gt;
		&lt;lookup …/&gt;
	…
&lt;/acquisition&gt;

&lt;infrastructure&gt;
		&lt;hosts&gt;
			&lt;host…/&gt;
		&lt;/hosts&gt;

		&lt;groups&gt;
			&lt;groupType …/&gt;
		&lt;/group&gt;

		&lt;bridges&gt;
			&lt;bridgeType …/&gt;
		&lt;/bridges&gt;
	…
&lt;/infrastructure&gt;



				</programlisting>

			</para>
			<para>
				The elements must be specified in this order. The &lt;environment&gt; and &lt;acquisition&gt; elements can be omitted, while the
				&lt;resources&gt; and &lt;infrastructure&gt; ones are mandatory. They are the ones which define the model :

				<orderedlist>
					<listitem>
						<para>
							Infrastructure: this is a flat list of each individual element of the grid: hosts, groups and bridges listed in no
							particular order.
						</para>
					</listitem>
					<listitem>
						<para>
							Resources: this is a tree describing the hierarchical relationships between these infrastructure elements. These
							relationships are defined by:
							<itemizedlist>
								<listitem>
									<para>a host being within which group;</para>
								</listitem>
								<listitem>
									<para>a group being behind a bridge;</para>
								</listitem>
								<listitem>
									<para>a host being directly available.</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>
				</orderedlist>
			</para>
			<para>
				Let's examine a couple of basic examples. Considering a very simple grid, that is two desktop PCs networked together. Such a setup
				would be represented as follows (configuration parameters are omitted for the sake of clarity):
			</para>

			<programlisting>
				
&lt;resources&gt;
	&lt;hosts&gt;
		&lt;host refid="host1"  /&gt;
		&lt;host refid="host2"  /&gt;
	&lt;/hosts&gt;
&lt;/resources&gt;

&lt;infrastructure&gt;	
    &lt;hosts&gt;
		&lt;host id="host1"  /&gt;
		&lt;host id="host2"  /&gt;
	&lt;/hosts&gt;
&lt;/infrastructure&gt;

			</programlisting>

			<para>
				There is no hierarchical relation between the two hosts, so both resources and infrastructure parts are identical (aside of the extra
				configuration parameters which are omitted here). A slightly more complex example would be a cluster of 12 mono-processor machines
				running LSF. The representation in GCM Deployment would be as follows:
			</para>

			<programlisting>
				
&lt;resources&gt;
		&lt;group refid="LSF_GROUP"&gt;
			&lt;host refid="LSF_GROUP_MEMBER" /&gt;
		&lt;/group&gt;
&lt;/resources&gt;

&lt;infrastructure&gt;
	&lt;hosts&gt;
		&lt;host id="LSF_GROUP_MEMBER" /&gt;
	&lt;/hosts&gt;

	&lt;groups&gt;
		&lt;lsfGroup id="LSF_GROUP" &gt;
			&lt;resources processorNumber="12" /&gt;
		&lt;/lsfGroup&gt;
	&lt;/groups&gt;
&lt;/infrastructure&gt;


			</programlisting>

			<para>
				Within the &lt;infrastructure&gt;, the &lt;hosts&gt; part describes the configuration common to the machines in the group. The
				&lt;groups&gt; part describes the LSF group itself. Finally, the &lt;resources&gt; part describes how they fit together, in this case
				the host model being within the LSF group.
			</para>

			<para>The next paragraphs go more in depth on the content and usage of each element.</para>

			<section xml:id="Environmentelement_64"><info><title>Environment element</title>
				</info>
				<para>
					To allow for a bit of flexibility, it is possible to define variables in a descriptor. The variables can be used in any XML value
					element. They cannot be used in an XML element name. The &lt;environment&gt; element is where the variables are defined. It is a
					simple list of &lt;descriptorVariable&gt; elements. For example:

					<programlisting>
						
&lt;environment&gt;
	&lt;descriptorVariable name="usertype" value="admin" /&gt;
  &lt;descriptorVariable name="username" value="jsmith" /&gt;
&lt;/environment&gt;


					</programlisting>

					This allows the following usage later on in the descriptor: &lt;sshGroup user="${username}" /&gt;


				</para>
			</section>

			<section xml:id="Resourceselement_64"><info><title>Resources element</title>
				</info>
				<para>
					The &lt;resource&gt; element describes the hierarchical structure of the available grid resources. This can be seen as the
					topology of the grid: which hosts are part of a group, which group is behind a bridge, etc… All the grid resources which are
					listed in it must be fully defined in the &lt;infrastructure&gt; element. However it doesn't have to hold every element listed in
					&lt;infrastructure&gt;, it is meant to contain only the subset of resources which are actually used by the deployment.
				</para>

				<para>

					You can use the following elements to build your grid topology :
					<orderedlist>
						<listitem>
							<para>
								&lt;host&gt; : this represents a single machine, or more precisely a single configuration. When used within a group,
								it represents the common configuration of all machines within this group.
							</para>
						</listitem>
						<listitem>
							<para>
								&lt;group&gt; : this represents a set of machines all sharing a common configuration. Typically a cluster. The
								configuration is represented through a Host element.
							</para>
						</listitem>
						<listitem>
							<para>
								&lt;bridge&gt; : this represents a machine which acts as a gateway to one or several other machines. Typically, a
								front-end for a cluster.
							</para>
						</listitem>
					</orderedlist>

					These elements all take a single argument named 'refid'. The value of the argument is the id of the corresponding
					host/bridge/group element defined in the &lt;infrastructure&gt; element. The topology must be described according to the following
					rules:
					<itemizedlist>
						<listitem>
							<para>A host can be at the top level, or in a group element</para>
						</listitem>
						<listitem>
							<para>A group can be at the top level, or in a bridge element</para>
						</listitem>
						<listitem>
							<para>A bridge can only be at the top level</para>
						</listitem>
					</itemizedlist>

					For example, the following constructions are correct: Single host:

					<programlisting>
						
&lt;host refid="A_HOST" /&gt;

					</programlisting>

					Group:

					<programlisting>
						
&lt;group refid="CLUSTER"&gt;
	&lt;host refid="CLUSTER_NODE" /&gt;
&lt;/group&gt;

					</programlisting>

					Group behind a bridge:

					<programlisting>
						
&lt;bridge refid="CLUSTER_FRONT_END" /&gt;
	&lt;group refid="CLUSTER"&gt;
		&lt;host refid="CLUSTER_NODE" /&gt;
	&lt;/group&gt;
&lt;/bridge&gt;

					</programlisting>

				</para>

			</section>

			<section xml:id="Acquisitionelement_64"><info><title>Acquisition element</title>
				</info>
				<para>
					An alternative to the &lt;infrastructure&gt; element, the &lt;acquisition&gt; element describes how resources which are already
					running can be acquired. It contains one type of elements: &lt;lookup&gt;, in this order. Each element can either
					have a single occurrence or be omitted. The &lt;lookup&gt; element has the following three attributes:
					<orderedlist>
						<listitem>
							<para>type: one of "RMI", "HTTP", "IBIS";</para>
						</listitem>
						<listitem>
							<para>hostlist: a HostList as defined in 5.1.1;</para>
						</listitem>
						<listitem>
							<para>port: a positive integer.</para>
						</listitem>
					</orderedlist>
				</para>
			</section>

			<section xml:id="Infrastructureelement_64"><info><title>Infrastructure element</title>
				</info>
				<para>
					The &lt;infrastructure&gt; is where you will list the grid resources on which the deployment can take place, in no particular
					order. Its purpose is to describe how these resources are deployed (i.e. through which protocols). It can have a single child
					element of each of the following types: &lt;hosts&gt;, &lt;bridges&gt;, &lt;groups&gt;. &lt;bridges&gt; and &lt;groups&gt; may be
					empty or omitted, but there should be at least one child element in &lt;hosts&gt;.
				</para>


			</section><!-- infrastructure element -->


		</section><!-- end of Deployment Descriptor Tutorial -->


		<!-- 
			
			Application Descriptor Tutorial
			
		-->
		<section xml:id="FortheGridApplicationDevelopercreatinganapplication_64"><info><title>For the Grid Application Developer : creating an application descriptor</title>
			</info>

			<para>
				While the Deployment Descriptor lists the grid resources, the application descriptor lists the resources the application needs.
			</para>

			<para>
				The overall structure of an Application Descriptor is as follows :

				<programlisting>
					
&lt;environment&gt;
		…
&lt;/environment&gt;

&lt;application&gt;
…
&lt;/application&gt;

&lt;resources&gt;
		&lt;nodeProvider&gt;
			&lt;file …/&gt;
			…
		&lt;/nodeProvider&gt;
		…
&lt;/resources&gt;

				</programlisting>

			</para>

			<para>
				The &lt;environment&gt; element is similar to the one in the Deployment Descriptor. The &lt;application&gt; one is where the
				application itself and the resources it requests are described (see GCM Application descriptor section). Finally, the
				&lt;resources&gt; element is where you'll make the link between the requested resources and the deployed ones.
			</para>

			<para>
				The &lt;application&gt; tag can hold either an &lt;executable&gt; or a &lt;proactive&gt; tag. &lt;executable&gt; is for stand-alone
				applications which you want to run on a grid. &lt;proactive&gt; is for ProActive-based applications. In both cases the requested
				resources are specified through &lt;nodeProvider&gt; elements. These elements only carry a single 'refid' attribute which points to a
				corresponding &lt;nodeProvider&gt; element listed in the &lt;resources&gt; element.
			</para>

			<section xml:id="ExampleofExecutableelement_64"><info><title>Example of Executable element</title>
				</info>

				<para>
					A stand-alone executable is very straightforward to describe. You only need to specify one or several &lt;nodeProvider&gt;s and
					the application will be run on all the physical nodes these providers can yield.

					<programlisting>
						
	&lt;application&gt;
		&lt;executable&gt;
			&lt;command name="ls"&gt;
				&lt;arg&gt;-lh&lt;/arg&gt;
				&lt;arg&gt;--sort=time&lt;/arg&gt;
				&lt;arg&gt;*&lt;/arg&gt;
			&lt;/command&gt;
			&lt;nodeProvider refid="COMPANY_LAN" /&gt;
		&lt;/executable&gt;
	&lt;/application&gt;

	&lt;resources&gt;
		&lt;nodeProvider id="COMPANY_LAN"&gt;
			&lt;file path="deployment.xml" /&gt;
		&lt;/nodeProvider&gt;
	&lt;/resources&gt;
								
								

					</programlisting>

				</para>

			</section>

			<section xml:id="ExampleofProActiveelement_64"><info><title>Example of ProActive element</title>
				</info>

				<para>
					A ProActive application runs on virtual nodes. These virtual nodes aggregate physical nodes that they fetch from the node provider
					specified in the virtual node definition. In the following example, a ProActive application defines two virtual nodes ("master"
					and "slaves"). The first will fetch a single physical node from the COMPANY_LAN node provider. The second will get as many nodes
					as available (its capacity is set to "MAX") from both the COMPANY_LAN and REMOTE_CLUSTER providers.

					<programlisting>
						
				
	&lt;application&gt;
		&lt;proactive relpath="Scratch/ProActive/"&gt;

			&lt;configuration&gt;
			&lt;!-- ommitted for clarity --&gt;
			&lt;/configuration&gt;

			&lt;virtualNode id="master" capacity="1"&gt;
				&lt;nodeProvider refid="COMPANY_LAN" /&gt;
			&lt;/virtualNode&gt;

			&lt;virtualNode id="slaves" capacity="max"&gt;
				&lt;nodeProvider refid="COMPANY_LAN" /&gt;
				&lt;nodeProvider refid="REMOTE_CLUSTER" /&gt;
			&lt;/virtualNode&gt;
		&lt;/proactive&gt;
	&lt;/application&gt;

	&lt;resources&gt;
		&lt;nodeProvider id="COMPANY_LAN"&gt;
			&lt;file path="deployment.xml" /&gt;
		&lt;/nodeProvider&gt;
		&lt;nodeProvider id="REMOTE_CLUSTER"&gt;
			&lt;file path="deployment_cluster.xml" /&gt;
		&lt;/nodeProvider&gt;
	&lt;/resources&gt;

				

					</programlisting>


				</para>

			</section>


		</section><!-- end of Application Descriptor Tutorial -->

		<section xml:id="FortheGridApplicationDeveloperdeployingyourapplication_64"><info><title>For the Grid Application Developer : deploying your application on the grid</title>
			</info>

			<para>
				To deploy your application on the grid, you need to get your application descriptor as a
				<code>java.io.File</code>
				. You then pass it to
				<code>org.objectweb.proactive.extensions.gcmdeployment.PAGCMDeployment.loadApplicationDescriptor()</code>
				which will return a <code>GCMApplication</code> object. To actually start the deployment, simply call the
				<code>startDeployment()</code>
				method.

				<programlisting>
					
GCMApplication app;
									
File desc = new File(this.getClass().getResource("MyApplicationDescriptor.xml").getPath());

app = PAGCMDeployment.loadApplicationDescriptor(desc);
app.startDeployment();

				
				</programlisting>

			</para>

			<para>
				If needed you may want to also create a VariableContract and set some of its variables, then pass it as 2nd argument to
				loadApplicationDescriptor() :

				<programlisting>
					
VariableContractImpl vContract = new VariableContractImpl();
vContract.setVariableFromProgram("HOST_CAPACITY", "4",
				VariableContractType.DescriptorDefaultVariable);
vContract.setVariableFromProgram("VM_CAPACITY", "1",
                VariableContractType.DescriptorDefaultVariable);

GCMApplication app;
									
File desc = new File(this.getClass().getResource("MyApplicationDescriptor.xml").getPath());

app = PAGCMDeployment.loadApplicationDescriptor(desc, vContract);
app.startDeployment();


				</programlisting>

			</para>

			<para>
				In the case of a stand-alone application, it will simply be deployed on all the available nodes without any special intervention on
				your side. In the case of a ProActive-based application, there are two ways for an application to handle the deployment process. The
				simplest one is to call the
				<programlisting><textobject><textdata fileref="automatic_snippets/GCMVirtualNode_waitReady.snip"/></textobject></programlisting>
				method on your <code>GCMApplication</code> object. As the name of the method indicates, it amounts to "wait until everything is ready". The call
				will block until all virtual nodes are ready, that is that they have acquired the minimum number of nodes they need. This method
				should not be used if one of the virtual nodes is "greedy", in which case it will never be in a "ready" state. There's another version
				of the method with a timeout parameter :
				<programlisting><textobject><textdata fileref="automatic_snippets/GCMVirtualNode_waitReady_timeout.snip"/></textobject></programlisting>


				However, a more flexible way is for your application to listen to the availability of new nodes on each virtual node, and act
				accordingly. The method for this is
				<programlisting><textobject><textdata fileref="automatic_snippets/GCMVirtualNode_subscribeNodeAttachment.snip"/></textobject></programlisting>
				in
				<code>GCMVirtualNode</code>
				.
				<code>methodName</code>
				must be the name of a method of
				<code>client</code>
				, which prototype is
				<code>method(GCMVirtualNode node, String virtualNodeName)</code>
				. This method will be called by the virtual node for each new available node.

				To get the list of virtual nodes for your <code>GCMApplication</code>, use
				<programlisting><textobject><textdata fileref="automatic_snippets/GCMApplication_getVirtualNodes.snip"/></textobject></programlisting>

				You can also get a specific virtual node if you know its name :
				<programlisting><textobject><textdata fileref="automatic_snippets/GCMApplication_getVirtualNode.snip"/></textobject></programlisting>
			</para>

		</section>



	</section><!-- end of Tutorial -->


</chapter>
