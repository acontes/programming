<?xml version="1.0" encoding="utf-8"?><chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="ComponentsTutorial"><info><title xml:id="GCMComponentsTutorial_27">GCM Components Tutorial</title></info>
	<section xml:id="Introduction_27"><info><title>Introduction</title></info> 
		
		<para>
			This chapter presents a short user guide which explains how to use the ProActive/GCM implementation.
			The chapter will not explain how to program with components but instead focus on the particularities
			of the GCM implementation for ProActive. 
		</para>
	</section>
		
	<section xml:id="Creatingandusingcomponentsinaprogramaticway_27"><info><title>Creating and using components in a programatic way</title></info>
					<para> Along this short user guide, we will show: how to
 			  create primitive and composite components, how to assemble
 			   them using Fractal/GCM API and Fractal API files, how
 		  	to interoperate with components, and then how to describe
 			the deployment of components using deployment descriptor file.
 			</para>
 	
 				<para> The first step of this user guide explains how
 				 to create a single primitive component. Next, we will use an
 				  assembly of two primitive components in a composite one.</para>
 				  <section xml:id="the_first_component"><info><title>The first component </title></info>
 				  	
				
					<para>We want to create a primitive component, 
					called PrimitiveComputer. It exposes one server interface 
					called computer-itf which provides the two following
					 methods: compute and doNothing. To do that, we need to write the two following classes.
					 	</para>
					 <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/simple_composite_interface.snip"/></textobject></programlisting>

					 <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/primitive_computer.snip"/></textobject></programlisting>
					 
				<para>Now, we will discuss on the different ways to use this component.
					First, we must create the component with
					the ProActive/GCM framework. Two kinds of component
					instantiation are shown. In the first case, we can
					do all these steps in the application. However, in
					the second case, we will show how we can use the ADL
					files to simplify the application and create it in a simpler way.
					</para>
					<para>
					In order to illustrate these different ways,
					a new class, Main, containing the possible main
					method of our application (see the source code below), 
					is written. In this main method, four different methods
					are called and will be described in the following parts
					of this document, launchFirstPrimitive,
					launchWithoutADL, launchWithADL, and finally
					the last launchAndDeployWithADL. To launch this
					class, you must put in your classpath all
					the libraries contained in the lib directory
					 and subdirectories and the ProActive jar. And finally,
					 you must set the three Java properties 
					 (fractal.provider, java.security.policy, log4j.configuration) as shown in the command line:
					 
					</para>
					 <programlisting><textobject><textdata fileref="guided_tour/code_snippets/components/simple_component_run.txt"/></textobject></programlisting>


					 <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/full-main.snip"/></textobject></programlisting>
					<para> If we want to create and call components in
					 a standard Java application, we need to use the GCM API [1].
					 The method launchFirstPrimitive shows all the steps
					 to create and use our first primitive component.
					 Firstly, define the type of the component. Secondly,
					 create component using a factory. Thirdly,
					 start the component. And finally, retrieve the component’s
					 interface and use it as a standard Java object to access our component.
					 </para>

					 <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/launch_first_primitive.snip"/></textobject></programlisting>
				
				
				
				
				<para> Uncomment the line calling the <literal>launchFirstPrimitive</literal>
				 method in the main method, launch it and see
				  below the expected output. The first lines are ProActive
				  log, and at the end, information printed in the component and in the Main class is visible.
				  </para>
					 <programlisting><textobject><textdata fileref="guided_tour/code_snippets/components/simple_run_output.txt"/></textobject></programlisting>
							</section>
			<section xml:id="Defineanassembly_27"><info><title>Define an assembly</title></info>
				
					<para> Now that we succeeded to create and use
					 a primitive component, we will learn how to use
					  it in a component assembly. First of all, we want
					   use the previous shown primitive component with another
					    primitive component to explain how to define, implement and
					     use client interfaces. Moreover, in order to use composite
					      component, we put the two primitive components in
					       a composite. The <xref linkend="component_assembly"/> shows this assembly. 
					       </para>
			
	      	<figure xml:id="component_assembly"><info><title xml:id="Componentassembly_27">Component assembly </title></info> 
			  <mediaobject>
	          <imageobject>
	            <imagedata scalefit="1" width="100%" contentdepth="100%" fileref="guided_tour/pics/gcm/component_assembly.png" format="PNG"/>
	          </imageobject>
	        </mediaobject>
	      </figure>
			<para> To implement this assembly we need one more class,
			 PrimitiveMaster. This class implements the following Java interfaces: 
			 java.lang.Runnable and moreover the BindindController to allow binding
			 on the compute-itf client interface. In the run method we
			 put the call to the PrimitiveComputer component, we
			 don’t need to retrieve the compute-itf interface since the assembling
			 it’s done in the launchWithoutADL method or in the following part using ADL.
			  </para>
			 <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/primitive_master.snip"/></textobject></programlisting>
			   <para> In the launchWithoutADL method, we extend component type definition
			    and component creation parts. And we add one more part, 
			    the component assembling. In this part, at first 
			    we put the two primitives, PrimitiveComputer and PrimitiveMaster 
			    in the composite component. Next, we make the binding between each component interfaces.
			    </para>
			 <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/launch_without_ADL.snip"/></textobject></programlisting>
			    <para> This way isn’t the simplest one to create and use
			     component. There is a lot of code to write, that
			      could introduce mistakes or errors in an assembly. We will show an easier one next.
			      </para>
			      </section>
			      </section>
			<section xml:id="CreateandusecomponentsusingADL_27"><info><title>Create and use components using ADL</title></info>
			
				<para> We want create the same component directly using
				 ADL capabilities. The source code of the method launchWithADL shows
				  how to use it. Another factory is used, and we can create
				   directly the component without defining at first its
				    type. Utilization of the created component is still the same. You can
				     see that we don’t need to define
				      and assemble parts any more. Moreover, we need to create only one
				       component, the other ones are automatically created.
				       </para>
			 <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/launch_with_ADL.snip"/></textobject></programlisting>
				<para> ADL allows describing a component assembly through a text
				 file. In our case, we have defined fives files. These
				 files need to be in the classpath of
				 the application, for instance the PrimitiveComputer.fractal
				 file needs to be in the <literal>org/objectweb/proactive/examples/components/userguide/adl</literal>
				 directory in the classpath. The first one, PrimitiveComputerType.fractal, 
				 describes the component type, in particular the interface and
				 the membrane with the tags interface and controller. The second one, 
				 PrimitiveComputer.fractal, adds two necessary information: the 
				 implementation class with the content tag and a virtual node
				  with the virtual-node tag. These tags are explained in the following section.
				  </para>
			 <programlisting xml:lang="xml"><textobject><textdata fileref="../src/Examples/org/objectweb/proactive/examples/components/userguide/adl/PrimitiveComputerType.fractal"/></textobject></programlisting>
					<para> 		It is quite the same for the
					PrimitiveMaster component; just the name
					 and definition class change, and there is one more interface, a client one.
					 </para>
			<programlisting xml:lang="xml"><textobject><textdata fileref="../src/Examples/org/objectweb/proactive/examples/components/userguide/adl/PrimitiveMasterType.fractal"/></textobject></programlisting>

				<para>And finally, there is the composite one. It
				 defines one interface, and include the two primitive
				  described previously. The binding tag is new; it describes
				   the binding between the interface from composite and inner components.
				   </para>
			<programlisting xml:lang="xml"><textobject><textdata fileref="../src/Examples/org/objectweb/proactive/examples/components/userguide/adl/PrimitiveMaster.fractal"/></textobject></programlisting>

				<para>Now, we can run the example; uncomment the line calling the
				 launchWithADL method in the main and then you can see the same output as in the previous section.
				 </para>
				 </section>
				 <section xml:id="CreatingusinganddeployingcomponentsusingADL_27"><info><title>Creating, using and deploying components using ADL </title></info>
				 
				 	<para>To deploy components on a specific virtual node, we need
				 	 to use ADL files. Just before we saw that the tag
				 	 virtual-node allows to specify which virtual node to
				 	 use for a component. The virtual node is defined in a separate
				 	 file: a deployment descriptor. You can find more information on how to write a
				 	 deployment descriptor file in the ProActive documentation, 
				 	 <!-- TODO add xref -->chapter 21, XML Deployment Descriptors. 
				 	 The deployment descriptor file used in this example is in the Appendix: <literal>deploymentDescriptor.xml.</literal>
				 	 </para>
				 	 <para>Furthermore, we need to inform the factory how
				 	  to use this deployment descriptor; we do
				 	   this in the launchPrimitiveADLAndDeployment method :
				 	   </para>
				 	   <itemizedlist>
				 	   <listitem><para>We create a ProActiveDescriptor object</para></listitem> 
						<listitem><para>We put this object in the context HashMap</para></listitem>
						<listitem><para>We give this HashMap to the factory</para></listitem>
						</itemizedlist>
							<para>Thus, the factory can retrieve the virtual node defined, 
							and use it as described in the ADL files. </para>
							<para> There is another specific point in the
							 end of this method with the 
							 <literal>deploymentDescriptor.killall(false);</literal> call.
							This method kills all the JVM deployed using the
							original deployment descriptor file. Before this call, we need 
							to suspend the program since the method calls in GCM
							 are asynchronous, in order to not kill JVM before the end of the component execution.
							 </para>

			 <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/launch_and_deploy_with_ADL.snip"/></textobject></programlisting>

				 <para> Now we can run this example; uncomment the
				  line calling the launchPrimitiveADLAndDeployment method, launch it and see
				    the  output. The first lines are
				    ProActive log; it’s more verbose than during previous 
				    execution because we deploy the two JVMs defined in the
				     deployment descriptor file. After that, you can see information
				      printed from the component and the Main class
				      . And finally, the ProActive log again when the created JVMs are killed.
				      </para>
				      
				      
				      
				      <!--  TODO  launchPrimitiveADLAndDeployment Output
Launch primitive component example
Launch component assembly example
Launch component assembly example with ADL
Launch and deploy component assembly example with ADL
				      -->
				      </section>
				      <section xml:id="ComponentinterfaceCardinality_27"><info><title>Component interface Cardinality</title></info>
				      
				      <para> Client and server also support multicast and gathercast
				       interface cardinality. The GCM [1] explains which constraints
				        the server and client interfaces must respect.
				         </para>
				         <para> For multicast interfaces you can specify the parameter dispatching
				          mode thanks to Java annotations available in
				           the org.objectweb.proactive.core.component.type.annotations.multicast package.
				           </para>
				           </section>
				   <section xml:id="Additionalexamples_27"><info><title>Additional examples</title></info>
				   
				   <para> Two component applications are included in ProActive the HelloWorld and C3D example.
				   </para>
				   <para>A Hello World example is provided. It shows the
				    different ways of creating a component system programmatically and using
				     ADL. You can find the code for this example in the package 
				     <literal>org.objectweb.proactive.examples.components.helloworld </literal> of the CFI prototype distribution. 
				     </para>
				     <para>The example code can either be compiled and run manually or using scripts
				      (hello-world_fractal.sh (or .bat) in the scripts/unix/components directory) can
				       be used to launch it. If you choose the first solution, do not forget to set the fractal.provider system property.
				       </para>
				       <para> The other example, C3D application — a parallel, distributed and collaborative
				        3D renderer, is in the org.objectweb.proactive.examples.components.c3d package.
				        </para>
				        
				        <programlisting xml:lang="xml"><textobject><textdata fileref="../src/Examples/org/objectweb/proactive/examples/components/userguide/deploymentDescriptor.xml"/></textobject></programlisting>
				        
	        </section>				        
</chapter>
