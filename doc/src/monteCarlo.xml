<?xml version="1.0" encoding="utf-8"?><chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="monte_carlo">

<info>
<title xml:id="MonteCarloAPI_34">Monte-Carlo API</title>
    </info>
    <section xml:id="mc_overview">
<info>
<title xml:id="Overview_34">Overview</title>
        </info>

        <para>
            <link xlink:href="http://en.wikipedia.org/wiki/Monte_Carlo_method">Monte Carlo</link>
            methods are a class of computational algorithms that rely on repeated random sampling to compute their
            results. Monte Carlo methods are often used when simulating physical and mathematical systems. Because of
            their reliance on repeated computation and random or pseudo-random numbers, Monte Carlo methods are most
            suited to calculation by a computer. Monte Carlo methods tend to be used when it is infeasible or impossible
            to compute an exact result with a deterministic algorithm.
        </para>

        <para>The goal of the ProActive Monte-Carlo API is to provide and easy to use API for running Monte-Carlo
            simulations in a distributed environment.
        </para>

        <para>The main features are:</para>
        <itemizedlist>
            <listitem>
                <para>
                    Monte-Carlo simulations or other tasks can be run on remote workers. Tasks are defined by
                    implementing an interface.
                </para>
            </listitem>
            <listitem>
                <para>
                    It integrates<link xlink:href="http://www.iro.umontreal.ca/~simardr/ssj/">SSJ</link>, a distributed
                    random generator written by Pierre l'Ecuyer. Each worker has its own independant stream of random
                    numbers and there is a guaranty that two different workers, will generate sequences that won't
                    overlap until a certain number of experiences (2¹²⁷).
                </para>
            </listitem>
            <listitem>
                <para>
                    It is based on ProActive Master-Worker API as the underlying framework (see ProActive documentation,
                    Master/Worker for more info).
                </para>
            </listitem>
            <listitem>
                <para>
                    Deployment of the workers infrastructure is done through GCM descriptors (see ProActive
                    documentation, GCMDeployment for more info).
                </para>
            </listitem>
            <listitem>
                <para>
                    A small set of processes, taken from the financial field, are included as example.
                </para>
            </listitem>
        </itemizedlist>
    </section>
    <section xml:id="mc_api">
<info>
<title xml:id="API_34">API</title>
        </info>
        <para>
            The Monte-Carlo APi is located in the following package:
        </para>
        <screen>org.objectweb.proactive.extra.montecarlo.example</screen>
        <section xml:id="mc_api_main_class">
<info>
<title xml:id="MainClass_34">Main Class</title>
            </info>
            <para>
                The entry point of the Monte-Carlo API is the PAMonteCarlo class. Its main constructor allows you to
                deploy the monte-carlo framework, using ProActive GCM deployment framework. The first constructor is the
                URL of the GCMApplication file which will be used. The next argument is the virtual node name
                corresponding to the Workers infrastructure of machines. The third argument (optional) is a virtual node
                name that will correspond to a remote deployment of the master. The final argument is to allow changing
                the default Random Number Generator from the SSJ package.
            </para>
            <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/montecarlo_constructor.snip"/></textobject></programlisting>
            <para>
                The run method from the PAMonteCarlo class, is the starting point of the computation. It runs a single
                task, called a top-level engine task. This task, while running, will most likely generate new children
                subtasks. The different tasks existing in the framework are described in<xref linkend="mc_api_tasks"/>.
            </para>
            <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/montecarlo_run.snip"/></textobject></programlisting>
            <para>
                Finally, the terminate method will shut down the framework and every remote JVM created during the
                initialization phase.
            </para>
            <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/montecarlo_terminate.snip"/></textobject></programlisting>
        </section>
        <section xml:id="mc_api_tasks">
<info>
<title xml:id="Tasks_34">Tasks</title>
            </info>
            <para>This section describes the different types of tasks and their use</para>
            <section xml:id="mc_api_engine_task">
<info>
<title xml:id="EngineTask_34">Engine Task</title>
                </info>
                <para>
                    An Engine Task is a general-purpose task, it is used when any computation which doesn't include
                    runnig
                    Monte-Carlo simulation needs to be done. The top-level task, submitted to the PAMonteCarlo class is
                    an
                    engine task.
                    An engine task can, through the access to two interfaces (the Executor and the Simulator), spawn
                    children engine tasks or simulation sets.
                </para>
                <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/montecarlo_enginetask.snip"/></textobject></programlisting>
            </section>
            <section xml:id="mc_api_simulation_set">
<info>
<title xml:id="SimuationSet_34">Simuation Set</title>
                </info>
                <para>
                    A Simulation Set is a specific task for running Monte-Carlo simulations. It is given a random number
                    generator and can use it to generate random double numbers which are by default in the uniform
                    distribution. Classes from the SSJ package can be used to convert this distribution to any wanted
                    one.
                    Unlike the Engine Task, the Simulation Set cannot spawn other tasks and is therefore a "terminal
                    task".
                </para>
                <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/montecarlo_simulationset.snip"/></textobject></programlisting>
            </section>
            <section xml:id="mc_api_simulation_set_post_process">
<info>
<title xml:id="SimuationSetPostProcess_34">Simuation Set Post Process</title>
                </info>
                <para>
                    A simulation set task will return as output a huge number of values (e.g. arrays of size 10000 or
                    more).
                    In general, these results are not the result of the general algorithm which uses the Monte-Carlo
                    method.
                    Therefore, a post-treatment needs to be done on this big array.
                    Of course, this post-treatment could be done by an engine task that spawned the simulation set task,
                    but
                    in that case, the big array would be tranferred by the network from the Worker which handles the
                    simulation set to the worker which handles the parent engine task.
                    The Simulation Set Post Process avoids this tranfer, and allows to do some computations on the same
                    machine which generated the Monte-Carlo simulations.
                </para>
                <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/montecarlo_simulationsetpostprocess.snip"/></textobject></programlisting>
            </section>
        </section>
        <section xml:id="mc_example">
<info>
<title xml:id="Examples_34">Examples</title>
            </info>
            <section xml:id="mc_api_basic_processes">
<info>
<title xml:id="BasicSimulationsProcesses_34">Basic Simulations Processes</title>
                </info>
                <para>
                    Some basic Simulation Sets are provided as an example. These basic processes are widely used in the
                    financial risk management theory.
                    An example of such a process is the Geometric Brownian Motion:
                </para>
                <programlisting xml:lang="java"><textobject><textdata fileref="automatic_snippets/montecarlo_geometricbrownianmotion.snip"/></textobject></programlisting>
            </section>
            <section xml:id="mc_api_basic_applications">
<info>
<title xml:id="BasicExampleApplications_34">Basic Example Applications</title>
                </info>
                <para>
                    Two basic example applications are provided. The first one computes PI using the Monte-Carlo method
                    (it's only a theoretic approach as the method is very unefficient to compute PI at a good
                    precision).
                    The second example is an European Option Pricing from the financial risk analysis world. Both
                    examples can be found in the subpackage example of the monte-carlo package.
                    A script exists to launch the European Option and is located at PROACTIVE/examples/montecarlo
                </para>
            </section>
        </section>
    </section>
</chapter>