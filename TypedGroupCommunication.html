<!-- saved from url=(0022)http://internet.e-mail -->
<html>
<head>
<title>Typed Group Communication</title>
<link rel="stylesheet" href="ProActive.css">
</head>
<body bgcolor="white">

<!--
 Header : start 
~~~ -->
<table width="100%">
<tr>
<td align="left" valign="middle">
    <table cellpadding="2" cellspacing="0" border="1">
    <tr>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="../../../../overview-summary.html">back to API</a>&nbsp;&nbsp;</td>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="index.html">back to index</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="FutureObjectCreation.html">prev</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="MOP.html">next</a>&nbsp;&nbsp;</td>
    </tr>
    </table>
</td>
<td  align="right" valign="top">
<img src="ProActiveLogo200x34.gif"/>
</td>
</tr>
</table>
<hr>
<!-- Link to index : end -->

<h1>Typed Group Communication</h1>


<h2>Overview</h2>
<p class="textNormal">
Group communication is a crucial feature for high-performance and Grid 
      computing. While previous works and libraries proposed such a
      characteristic (e.g. MPI, or object-oriented frameworks), the
      use of groups imposed specific constraints on programmers, for
      instance the use of dedicated interfaces to trigger group
      communications.
<br><br>
We aim at a more flexible mechanism. We propose a scheme where, given 
      a Java class, one can initiate group communications using the
      standard public methods of the class together with the classical
      dot notation; in that way, group communications remains typed.
<br><br>
In order to ease the use of the group communication, we provide a set
      of static methods on the <code><a href="../core/group/ProActiveGroup.html">ProActiveGroup</a></code>
      class and a set of methods on the <code><a href="../core/group/Group.html">Group</a></code>
      interface.
<br><br>
Here, a short compilation about the syntax and some method used in
      the Group Communication API is presented. More informations follow.
</p>

<blockquote><pre>
   // created at once, 
   // with parameters specified  in params,
   // and on the nodes specified in nodes
A ag1 = (A) ProActiveGroup.newActiveGroup( "A", params, [nodes]);

   // A general group communication without result
   // A request to foo is sent in parallel to all active objects 
   // in the target group (ag1)
ag1.foo(...);

   // A general group communication with a result
V vg = ag1.bar(...);
   // vg is a typed group of "V": operation 
   // below is also a collective operation
   // triggered on results
vg.f1();
</pre></blockquote>


<h2>Creation of a Group</h2>
<p class="textNormal">
Any object that is reifiable has the ability to be included in a
      group. Groups are created using the static method
      <code><a href="../core/group/ProActiveGroup.html#newActiveGroup(java.lang.String)">ProActiveGroup.newActiveGroup</a></code>.
The  superclass common for all the group
members has to be specified, thus giving the group a minimal type.
<br><br>
Let us take a standard Java class:
</p>

<blockquote><pre>
class A { 
  public A() {}
  public void foo (...) {...}
  public V bar (...) {...}
  ...
}
</pre></blockquote>

<p class="textNormal">
Here are examples of some group creation operations:
</p>

<blockquote><pre>
   // Pre-construction of some parameters: 
   //   For constructors:
Object[][] params = {{...} , {...} , ... };
   //   Nodes to identify JVMs to map objects
Node[] nodes  = { ... , ..., ... };

   // Solution 1: 
   // create an empty group of type "A"
A ag1 = (A) ProActiveGroup.newActiveGroup("A");

   // Solution 2: 
   // a group of type "A" and its members are 
   // created at once, 
   // with parameters specified  in params,
   // and on the nodes specified in nodes
A ag2 = (A) ProActiveGroup.newActiveGroup(
                               "A", params, nodes);

   // Solution 3: 
   // a group of type "A"  and its members are 
   // created at once, 
   // with parameters specified in params,
   // and on the nodes directly specified 
A ag3 = (A) ProActiveGroup.newActiveGroup(
                   "A", params[], 
                   {rmi://globus1.inria.fr/Node1,
                    rmi://globus2.inria.fr/Node2});
</pre></blockquote>

<p class="textNormal">
Elements can be included into a typed group only if their class  equals
or extends the class specified at the group creation. For example, an
object of class B (B extending A) can be included to a group of type
A. However based on Java typing, only the methods defined 
in the class A can be invoked on the group.
</p>


<h2>Group representation and manipulation</h2>
<p class="textNormal">
The <b>typed group representation</b> we have presented in corresponds to the functional
view of groups of objects.
In order to provide a dynamic management of groups, a second
and complementary representation of a group has been designed. In
order to manage a group, this second representation must
be used instead.
This second representation, <b>the management representation</b>, follows a more standard pattern
for grouping objects : the <code><a href="../core/group/Group.html">Group</a></code> interface.<br><br>

We are careful to have a strong coherence between
both representations of the same group, which implies that 
modifications executed through one representation are
immediately reported on the other one. 
In order to switch from one representation to the other,
two methods have been defined : 
the static method named
<code><a href="../core/group/ProActiveGroup.html#getGroup(java.lang.Object)">ProActiveGroup.getGroup</a></code>,
returns the Group form associated to the given group object;  
the method <code><a href="../core/group/Group.html#getGroupByType()">getGroupBytype</a></code> defined in the <code><a href="../core/group/Group.html">Group</a></code> interface
does the opposite.<br><br>

Below is an example of when and how to use each representation of a group:
</p>
<blockquote><pre>
   // definition of one standard Java object
   // and two active objects
A a1 = new A();
A a2 = (A) ProActive.newActive("A", paramsA[], node);
B b  = (B) ProActive.newActive("B", paramsB[], node);
   // Note that B extends A

   // For management purposes, get the representation
   // as a group given a typed group, created with
   // code on the left column:
Group gA = ProActiveGroup.getGroup(ag1);

   // Now, add objects to the group:
   // Note that active and non-active objects 
   // may be mixed in groups
gA.add(a1);
gA.add(a2);
gA.add(b); 

   // The addition of members to a group immediately
   // reflects on the typed group form,  so a method
   // can be invoked on the typed group  and will
   // reach all its current members
ag1.foo(); // the caller of ag1.foo() may not belong to ag1

   // A new reference to the typed group  
   // can also be built as follows
A ag1new = (A) gA.getGroupByType();
</pre></blockquote>


<h2>Group as result of group communications</h2>

<p class="textNormal">
The particularity of our group communication mechanism is that
the <b>result</b> of a typed group communication <b>is also a group</b>. The result
group is transparently built at invocation time, with a future for each elementary reply.
It  will be dynamically updated with the incoming results, thus gathering results.
Nevertheless, the result group can be immediately used to execute another
method call, even if all the results are not available. In that case
the <b>wait-by-necessity</b> mechanism implemented by ProActive is used.
</p>

<blockquote><pre>
   // A method call on a group, returning a result
V vg = ag1.bar();
   // vg is a typed group of "V": operation 
   // below is also a collective operation
   // triggered on results
vg.f1();
</pre></blockquote>

<p class="textNormal">
As say in the Group creation section, groups whose type is based on final classes
or primitive types cannot be built. So, the construction of a  dynamic group 
as a result of a group method call is also limited. 
Consequently, only methods whose return type is either void or 
is a 'reifiable type', in the sense of the Meta Object Protocol of ProActive,
may be called on a group of objects; otherwise, they
will raise an exception at run-time, because the
transparent construction of a group of futures of
non-reifiable types fails.
<br><br>

To take advantage with the asynchronous remote method call model of ProActive, 
some new synchronisation mechanisms have been added.
Static methods defined in the <code><a href="../core/group/ProActiveGroup.html">ProActiveGroup</a></code>
class enable to execute various forms of synchronisation. For instance:
<code><a href="../core/group/ProActiveGroup.html#waitOne(java.lang.Object)">waitOne</a></code>,
<code><a href="../core/group/ProActiveGroup.html#waitN(java.lang.Object)">waitN</a></code>,
<code><a href="../core/group/ProActiveGroup.html#waitAll(java.lang.Object)">waitAll</a></code>,
<code><a href="../core/group/ProActiveGroup.html#waitTheNth(java.lang.Object)">waitTheNth</a></code>,
<code><a href="../core/group/ProActiveGroup.html#waitAndGet(java.lang.Object)">waitAndGet</a></code>.
Here is an exemple :
</p>

<blockquote><pre>
   // A method call on a typed group
V vg = ag1.bar();

   // To wait and capture the first returned 
   // member of vg
V v = (V) ProActiveGroup.waitAndGetOne(vg);

   // To wait all the members of vg are arrived
ProActiveGroup.waitAll(vg);
</pre></blockquote>



<h2>Broadcast vs Dispatching</h2>
<p class="textNormal">
Regarding the parameters of a method call towards a group of
objects, the default behaviour is to broadcast them to
all members. But sometimes, only a specific portion of the parameters,
usually dependent of the rank of the member in the group,
may be  really useful for the method execution, and so,
parts of the parameter transmissions  are useless. 
In other words, in some cases, there is a 
need to transmit different parameters to the various members.
<br><br>
A common way to achieve the scattering of a global parameter is
to use the rank of each member of the group, in order to select
the appropriate part that it should get
in order to execute the method. There is
a natural traduction of this idea inside
our group communication mechanism:<b>
the use of a group of objects in order to represent
a parameter of a group method call that must
be scattered to its members</b>.
<br><br>
The default
behaviour regarding parameters passing for method
call on a  group, is to pass a deep copy
of the group of type P to all members.
Thus, in order to scatter this group of elements 
of type P instead, the programmer must 
apply the static method <code><a href="../core/group/ProActiveGroup.html#setScatterGroup(java.lang.Object)">setScatterGroup</a></code>
of the <code><a href="../core/group/ProActiveGroup.html">ProActiveGroup</a></code> class to the group.
In order to switch back to the default behaviour, the 
static method <code><a href="../core/group/ProActiveGroup.html#unsetScatterGroup(java.lang.Object)">unsetScatterGroup</a></code> is available.
</p>

<blockquote><pre>
   // Broadcast the group gb to all the members
   // of the group ag1:
ag1.foo(gb);

   // Change the distribution mode of the 
   // parameter group:
ProActiveGroup.setScatterGroup(gb);

   // Scatter the members of gb onto the 
   // members of ag1:
ag1.foo(gb);
</pre></blockquote>

<br><br>
To learn more, see the <a href="../../../../index.html">JavaDoc</a> and the paper <b>Efficient, Flexible
      and Typed Group Communications for Java</b> located in the
    <a href="http://www-sop.inria.fr/oasis/ProActive/doc/index.html">Documentation page</a>.

<!--
 Footer : start 
~~~ -->
<br><hr><div align="right" class="textSmall">Copyright &#169; May 2003 INRIA All Rights Reserved.</p>
<!-- Footer : end -->
</body>
</html>
