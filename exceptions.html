<html>
<head>
<title>Exception Handling</title>
<link rel="stylesheet" href="ProActive.css">
</head>
<body bgcolor="white">

<!--
 Header : start 
~~~ -->
<table width="100%">
<tr>
<td align="left" valign="middle">
    <table cellpadding="2" cellspacing="0" border="1">
    <tr>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="../../../../overview-summary.html">back to API</a>&nbsp;&nbsp;</td>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="index.html">back to index</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="Migration.html">prev</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="bnb.html">next</a>&nbsp;&nbsp;</td>
    </tr>
    </table>
</td>
<td  align="right" valign="top">
<img src="ProActiveLogo200x34.gif"/>
</td>
</tr>
</table>
<hr>
<!-- Link to index : end -->

<H1>Exception Handling</h1>

<h2><a name="presentation"></a>Exceptions and Asynchrony</h2>
<p class="textNormal">
In the asynchronous environment provided by ProActive, exceptions cannot be
handled the same as in a sequential environment. Let's see the problem with
exceptions and asynchrony in a piece of code:
</p>

<pre>
1  <b class="java">try</b> {
2     Result r = someAO.someMethodCall(); // Asynchronous method call that can throw an exception
3     // ...
4     doSomethingWith(r);
5 } <b class="java">catch</b> (SomeException se) {
6     doSomethingWithMyException(se);
7 }
</pre>

<p class="textNormal">
In this piece of code, as the method call in line 2 is asynchronous, we don't wait
for its completion and continue the execution. So, it's possible the control flow
exits the <b class="java">try</b>. In this case, if the method call ends up with
an exception, we cannot throw it anymore back in the code because we are no more
in the <b class="java">try</b> block. That's why, by default, ProActive method calls
with potential exceptions are handled synchronously.
</p>

<h3>Barriers around <b class="java">try</b> blocks</h3>

<p class="textNormal">
The ProActive solution to this problem is to put barriers around
<b class="java">try</b>/<b class="java">catch</b> blocks. This way,
the control flow cannot exit the block, the exception can be
handled in the appropriate <b class="java">catch</b> block, and the
call is asynchronous within the block.
</p>

<p class="textNormal">
With this configuration, the potential exception can be throw for several points:
</p>
<ul>
<li>When accessing a future</li>
<li>In the barrier</li>
<li>Using the provided API (see after)</li>
</ul>

<p class="textNormal">
Let's reuse the previous example to see how to use these barriers
</p>

<pre>
1    <b>ProActive.tryWithCatch(SomeException.class);</b>
2    <b class="java">try</b> {
3       Result r = someAO.someMethodCall(); // Asynchronous method call that can throw an exception
4       // ...
5       doSomethingWith(r);
6       <b>ProActive.endTryWithCatch();</b>
7    } <b class="java">catch</b> (SomeException se) {
8       doSomethingWithMyException(se);
9    } <b>finally {</b>
10      <b>ProActive.removeTryWithCatch();</b>
11   <b>}</b>
</pre>

<p class="textNormal">
With this code, the call in line 3 will be asynchronous, and the exception will be
handled in the correct <b class="java">catch</b> block. Even if this implies waiting
at the end of the <b class="java">try</b> block for the completion of the call.
</p>

<p class="textNormal">
Let's see in detail the needed modifications to the code:
</p>

<ul>
<li>ProActive.tryWithCatch() call right before the <b class="java">try</b> block.
The parameter is either the caught exception class or an array of these classes
if there are many</li>
<li>ProActive.endWithTry() at the end of the <b class="java">try</b> block</li>
<li>ProActive.removeTryWithCatch() at the beginning of the
<b class="java">finally</b> block, so the block becomes mandatory</li>
</ul>

<h3>TryWithCatch Annotator</h3>

<p class="textNormal">
These needed annotations can be seen as cumbersome, so we provide a tool
to add them automatically to a given source file. It transforms the first
example code in the second. Here is a sample session with the tool:
</p>

<pre>
$ ProActive/scripts/unix/trywithcatch.sh MyClass.java # A backup will be made in MyClass.java~

--- ProActive TryWithCatch annotator -----------------------

$ diff -u MyClass.java~ MyClass.java
--- MyClass.java~
+++ MyClass.java
@@ -1,9 +1,13 @@
 public class MyClass {
     public MyClass someMethod(AnotherClass a) {
+        ProActive.tryWithCatch(AnException.class);
         try {
             return a.aMethod();
+            ProActive.endTryWithCatch();
         } catch (AnException ae) {
             return null;
+        } finally {
+            ProActive.removeTryWithCatch();
         }
     }
 }
</pre>

<p class="textNormal">
As we can see, ProActive method calls are added to make sure all calls within
<b class="java">try</b>/<b class="java">catch</b> blocks are handled
asynchronously.
</p>

<h3>Additional API</h3>

<p class="textNormal">
We have seen the 3 methods mandatory to perform asynchronous calls with exceptions,
but the complete API includes two more calls. So far, the blocks boundaries define
the barries. But, some control over the barrier is provided thanks to two additional
methods.
</p>

<p class="textNormal">
The first method is ProActive.throwArrivedException(). During a computation an exception
may be raised but there is no point from where the exception can be thrown (a future or
a barrier). The solution is to call the ProActive.throwArrivedException() method which
simply queries ProActive to see if an exception has arrived with no opportunity of being
thrown back in the user code. In this case, the exception is thrown by this method.
</p>

<p class="textNormal">
The method behaviour is thus dependant on the timing. That is, calling this method may or
may not result in an exception being thrown, depending on the time for an exception to
come back. That's why another method is provided, this is ProActive.waitForPotentialException().
Unlike the previous one, this method is blocking. After calling this method, either an
exception is thrown, or it is assured that all previous calls in the block completed
successfully, so no exception can be thrown from the previous calls.
</p>

<h2><a name="nfe"></a>Non-Functional Exceptions</h2>

<h3>Overview</h3>

<p class="textNormal">
In the first part, we were concerned with functional exception. That is, exceptions
originating from "business" code. The middleware adds its set of exceptions that we
call Non-Functional Exceptions (NFE): network errors, ... ProActive has a mechanism
for dealing with these exceptions.
</p>

<h3>Exception types</h3>

<p class="textNormal">
We have classified the non functional exceptions in two categories: those on the
proxy, and those on the body. So, exceptions concerning the proxy are in the
org.objectweb.proactive.core.exceptions.proxy package and inherits from the
ProxyNonFunctionalException package.
</p>

<h3>Exception handlers</h3>

<p class="textNormal">
The NFE mechanism in ProActive calls user defined handlers when a NFE is thrown. A
handler implements the following interface:
</p>

<pre>
public interface NFEListener {
    public boolean handleNFE(NonFunctionalException e);
}
</pre>

<p class="textNormal">
The handleNFE method is called with the exception to handle as parameter. The boolean
return code indicates if the handler could do something with the exception. This way,
if no handler could do anything with a given exception, the default behavior is used.
</p>

<p class="textNormal">
If the exception is on the proxy side, the default behaviour is to throw the exception
which is a RuntimeException. But on the proxy side, the default behaviour is to log
the exception with its stack trace to avoid killing an active object.
</p>

<h4>Association</h4>

<p class="textNormal">
These handlers are associated to entities generating exceptions. These are: an active
object proxy, a body, a JVM. Given a NFE, the handlers on the local JVM will be executed,
then either those associated to the proxy or the body depending on the exception.
</p>

<p class="textNormal">
Here is an example about how to add a handler to an active object on its side (body):
</p><pre>
ProActive.addNFEListenerOnAO(myAO, <b class="java">new</b> NFEListener() {
    <b class="java">public boolean</b> handleNFE(NonFunctionalException nfe) {
        <FONT ID="SingleLineComment">// Do something with the exception...</FONT>
        <FONT ID="SingleLineComment">// Return true if we were able to handle it</FONT>
        <b class="java">return true</b>;
    }
});
</pre>

<p class="textNormal">
Handlers can also be added to the client side (proxy) of an active object with
</p>

<pre>ProActive.addNFEListenerOnProxy(ao, handler)</pre>
<p class="textNormal">or to a JVM with</p>
<pre>ProActive.addNFEListenerOnJVM(handler)</pre>
<p class="textNormal">and even to a group with <p>
<pre>ProActive.addNFEListenerOnGroup(group, handler)</pre>

<p class="textNormal">
These handlers can also be removed with
</p>

<pre>ProActive.removeNFEListenerOnAO(ao, handler),
ProActive.removeNFEListenerOnProxy(ao, handler),
ProActive.removeNFEListenerOnJVM(handler)
ProActive.removeNFEListenerOnGroup(group, handler)</pre>

<p class="textNormal">
It's also possible to define an handler only for some exception types, for example:
</p>

<pre>
ProActive.addNFEListenerOnJVM(<b class="java">new</b> TypedNFEListener(
    SendRequestCommunicationException.<b class="java">class</b>,
    <b class="java">new</b> NFEListener() {
    <b class="java">public boolean</b> handleNFE(NonFunctionalException e) {
        <FONT ID="SingleLineComment">// Do something with the SendRequestCommunicationException...</FONT>
        <FONT ID="SingleLineComment">// Return true if we were able to handle it</FONT>
        <b class="java">return true</b>;
    }
}));
</pre>

<p class="textNormal">
You can use NFE for example, to automatically remove dead elements from a ProActive
group when trying to contact them. This can be achieved using the following construction:
</p>
<pre>
ProActive.addNFEListenerOnGroup(group, FailedGroupRendezVousException.AUTO_GROUP_PURGE);
</pre>
<p class="textNormal">
Note that this currently works only for one-way calls.
</p>
<!--
 Footer : start 
~~~ -->
<br><hr><div align="right" class="textSmall">Copyright &copy; 2001-2005 INRIA All Rights Reserved.</div>
<!-- Footer : end -->
</body>
</html>
