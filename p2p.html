<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<meta name="Keywords"
	content="infrastructure, p2p, peer-to-peer, proactive, daemon, xml">
<title>ProActive P2P Infrastructure</title>


<link rel="stylesheet" href="ProActive.css">

<meta name="Author" content="Alexandre di Costanzo">

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

</head>


<body>

<!-- Header : start ~~~ -->
<table width="100%">

	<tbody>

		<tr>

			<td align="left" valign="middle">
			<table border="1" cellpadding="2" cellspacing="0">

				<tbody>

					<tr>

						<td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1"
							href="../../../../overview-summary.html">back to API</a>&nbsp;&nbsp;</td>

						<td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1"
							href="index.html">back to index</a>&nbsp;&nbsp;</td>

						<td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2"
							href="components/intro.html">prev</a>&nbsp;&nbsp;</td>

						<td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2"
							href="Security.html">next</a>&nbsp;&nbsp;</td>

					</tr>

				</tbody>
			</table>

			</td>

			<td align="right" valign="top"><img src="ProActiveLogo200x34.gif"
				alt="ProActive Logo"></td>

		</tr>

	</tbody>
</table>

<hr>
<!-- Link to index : end -->
<h1><a class="mozTocH1" name="mozTocId874379"></a>ProActive Peer-to-Peer
Infrastructure</h1>

<p>The outline of this short handbook:</p>

<ol id="mozToc">
	<!--mozToc h2 1 h3 2 h4 3 h5 4 h6 5-->
	<li><a href="#mozTocId121981">Overview</a></li>
	<li><a href="#mozTocId1224">The P2P Infrastructure Model</a>
	<ol>
		<li><a href="#mozTocId356736">What is Peer-to-Peer?</a></li>
		<li><a href="#mozTocId928306">The P2P Infrastructure in short</a>
		<ol>
			<li><a href="#mozTocId101413">Bootstrapping: First Contact</a></li>
			<li><a href="#mozTocId470123">Discovering and Self-Organizing in
			Continue</a></li>
			<li><a href="#mozTocId299524">Asking Computational Nodes </a></li>
		</ol>
		</li>
	</ol>
	</li>
	<li><a href="#mozTocId197757">The P2P Infrastructure Implementation</a>
	<ol>
		<li><a href="#mozTocId467214">Peers Implementation</a></li>
		<li><a href="#mozTocId587594">Dynamic Shared ProActive Group</a></li>
		<li><a href="#mozTocId690451">Sharing Node Mechanism</a></li>
		<li><a href="#mozTocId586812">IC2D Screen shot</a></li>
	</ol>
	</li>
	<li><a href="#mozTocId325247">Installing and Using the P2P
	Infrastructure</a>
	<ol>
		<li><a href="#mozTocId765069">Create your P2P Network</a>
		<ol>
			<li><a href="#mozTocId117139">Quick Start Peer</a></li>
			<li><a href="#mozTocId979491">Usage Example</a></li>
			<li><a href="#mozTocId690540">The P2P Daemon</a>
			<ol>
				<li><a href="#mozTocId895651">Installation</a></li>
				<li><a href="#mozTocId799743">Configuration</a></li>
				<li><a href="#mozTocId994982">Control</a></li>
			</ol>
			</li>
		</ol>
		</li>
		<li><a href="#mozTocId315155">Acquiring Nodes by ProActive XML
		Deployment Descriptors</a></li>
		<li><a href="#mozTocId294040">The P2P Infrastructure API</a></li>
	</ol>
	</li>
	<li><a href="#mozTocId789872">Future Work</a></li>
</ol>

<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<h2><a class="mozTocH2" name="mozTocId121981"></a>Overview</h2>

<p>Computational Peer-To-Peer (P2P) is becoming a key execution
environment. The potential of 100,000 nodes interconnected to execute a
single application is rather appealing, especially for Grid computing.
Mimicking data P2P, one could start a computation that no failure would
ever be able to stop (and maybe nobody).</p>

<p>The ProActive P2P aims to use spare CPU cycles from organization's or
institution's desktop workstations.</p>

<p>This short document explains how to create a simple computational P2P
network. This network is a <b>dynamic JVMs network</b> which works like
computational nodes.</p>

<p>The P2P infrastructure works as an overlay network. It works with a <b>P2P
Service</b> which is a peer which in turn is in computational node. The
P2P Service is implemented with a ProActive JVM and few Active Objects.
The next figure shows an example of a network of hosts where some JVMs
are running and several of them are running the P2P Service.</p>

<div align="center"><img src="p2p_files/overlaynetwork.jpg"
	alt="Overlay Network">
<p><b class="legend">Example of a ProActive P2P infrastructure.</b></p>

</div>

<p>When the P2P infrastructure is running, it is very easy to obtain
some nodes (JVMs). The next section describes how to use it.</p>

<p>Further research information is available <a
	href="http://www-sop.inria.fr/oasis/personnel/Alexandre.Di_Costanzo/publications.html">here</a>.</p>

<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<h2><a class="mozTocH2" name="mozTocId1224"></a><a
	name="infrastructure_model"></a>The P2P Infrastructure Model</h2>

<p>The goals of this work are to use sparse CPU cycles from
institutions' desktop workstations combined with grids and clusters.
Desktop workstations are not available all the time for sharing
computation times with different users other than the workstation owner.
Grids and clusters have the same problem as normal users don't want to
share their usage time. <br>

</p>

<p>Managing different sorts of resources (grids, clusters, desktop
workstations) as a single network of resources with a high instability
between them needs a fully decentralized and dynamic approach.</p>

<p>Therefore, P2P is a good solution for sharing a dynamic JVM network,
where JVMs are the shared resources. Thereby, the P2P Infrastructure is
a P2P network which shares JVMs for computation. This infrastructure is
completely self-organized and fully configurable.</p>

<p>Before going on to consider the P2P infrastructure, it's important to
define what Peer-to-Peer is.<br>

</p>

<h3><a class="mozTocH3" name="mozTocId356736"></a>What is Peer-to-Peer?</h3>

<p>There are a lot of P2P definitions, many of them are similar to other
distributed infrastructures, such as Grid, client / server, etc. There
are 2 better definitions which describe really P2P well:</p>

<ul>

	<li>From&nbsp; <span style="font-style: italic;">Peer-to-Peer
	Harnessing&nbsp; the Power of Disruptive Technologies</span> (edited by
	Andy Oram):</li>

</ul>

<p>"[...] P2P is a class of applications that take advantage of <b>resources</b>
- available at the edges of the Internet [...]"</p>

<ul>

	<li>And from <span style="font-style: italic;">A Definition of
	Peer-to-Peer Networking for the Classification of Peer-to-Peer
	Architectures and Applications </span>(R&uuml;diger Schollmeier -
	P2P'01):</li>

</ul>

<p>"[...] Peers are <b>accessible</b> by other peers directly [...] Any
arbitrary chosen peer can be <b>removed</b> from the network <b>without
fault</b> [...]"</p>

<p><b>P2P's focus on sharing, decentralization, instability and fault
tolerance.</b></p>

<h3><a class="mozTocH3" name="mozTocId928306"></a>The P2P Infrastructure
in short</h3>

<h4><a class="mozTocH4" name="mozTocId101413"></a>Bootstrapping: First
Contact</h4>

<p>A fresh (or new) peer which would like to join the P2P network, will
encounter a serious bootstrapping problem or first contact problem: "How
can it connect to the P2P network?"</p>

<p>A solution for that is to use a specific protocol. ProActive provides
an interface for a network-centric services protocol which is named
JINI. JINI can be used for discovering services in a dynamic computing
environment, such as a fresh peer which would like to join a P2P
network. This protocol is perfectly adapted to solve the bootstrapping
problem. However, there is a serious drawback&nbsp; for using a
protocol&nbsp; such as JINI&nbsp; as peer discovering protocol. JINI is
limited to working only in the same sub-network. That means JINI doesn't
pass through firewalls or NAT and can't be considered to be used for
Internet.</p>

<p>Therefore,&nbsp; a different solution for the bootstrapping problem
was chosen. The solution for ProActive first contact P2P is inspired
from Data P2P Networks. This solution is based on real life , i.e. when
a person wants to join a community, this person has to first know
another person who is already a member of the community. After the first
person has contacted the community member, the new person is introduced
to all the community members. <br>

</p>

<p>The ProActive P2P bootstrapping protocol works as follows:</p>

<ul>

	<li>A fresh peer has a list of "server" addresses. These are
	peers&nbsp; which have a high potential to be available and to be in
	the P2P network, they are in a certain way the P2P network core.</li>

	<li>With this list the fresh peer tries to contact each server. When a
	server is reached the server is added to ithe fresh peer's list of
	known peers (acquaintances).<br>

	</li>

	<li>Then the fresh peer knows some servers, it is in the P2P Network
	and it is no longer a fresh peer, it is a peer of the P2P network.</li>

</ul>

<p>Furthermore, in the case of the fresh peer not able to contact any
servers from the list, the fresh peer will try every TTU (see below,
about Time To Update parameter) to re-contact all of them until one or
several of them are finally available. At any moment when the peer knows
nobody because all of its acquaintances are no longer available, the
peer will try to contact all the servers as explained earlier.</p>

<p>An example of a fresh peer which is trying to join a P2P network is
shown by the next Figure. The new peer has 2 servers to contact in order
to join the existing P2P infrastructure.<br>

</p>

<div align="center"><img src="p2p_files/firstContact.jpg"
	alt="Bootstrapping">
<p><b class="legend">Example of first contact (Bootstrapping).</b></p>

</div>

<h4><a class="mozTocH4" name="mozTocId470123"></a>Discovering and
Self-Organizing in Continue</h4>

<p>The main particularity of a P2P network is the peers high
volatility.&nbsp; This results from various attributes which compose
P2P: <br>

</p>

<ul>

	<li>Peers run on different kinds of computers: desktop workstations,
	laptops, servers, cluster nodes, etc.</li>

	<li>Each peer has a particular configuration: operating system, etc.</li>

	<li>Communicating network between peers consists of different speed
	connections: modem, 100Mb Ethernet, fiber channel, etc.</li>

	<li>Peers are not available all the time and not all at the same
	moment.</li>

	<li>Peer latency is not&nbsp; equal for all.</li>

	<li>etc.</li>

</ul>

<p>The result is the instability of the P2P network. But the ProActive
P2P infrastructure deals with these problems with transparency.</p>

<p>ProActive P2P infrastructure aims to maintain a created P2P network
alive while there are available peers in the network, this is called
self-organizing of the P2P network. Because P2P doesn't have exterior
entities, such as&nbsp; centralized servers which maintain peer data
bases, the P2P network has to be self-organized. That means all peers
should be enabled to stay in the P2P network by their own means.</p>

<p>There is a solution which is widely used in data P2P networks; this
consists of each peer keeping a list of their neighbors, a peer's
neighbor is typically a peer close to it (IP address or geographically).</p>

<p>In the same way, this idea was selected to keep the ProActive P2P
infrastructure up. All peers have to maintain a list of <b>acquaintances</b>.
At the beginning, when a fresh peer has just joined the P2P
infrastructure, it knows only peers from its <a href="#mozTocId101413">bootstrapping</a>
step. However, depending on how long the list of servers is, many of
them could be unreachable, unavailable, etc. and the fresh peer ends up
knowing a small number of acquaintances. Knowing a small number of
acquaintances is a real problem in a dynamic P2P network when all the
servers will be unavailable, the fresh peer will be unconnected from the
P2P infrastructure.</p>

<p>Therefore, the ProActive P2P infrastructure uses a specific parameter
called: <b>Number Of Acquaintances (NOA)</b>. This is a minimum size of
the list of acquaintances of all peers. The more the peers are highly
dynamic, the&nbsp; more NOA should be high. Thereby, a peer must
discover new acquaintances through the P2P infrastructure.<br>

</p>

<p>In the next <a href="#mozTocId299524">section</a>, we will see in
detail how the message protocol works. For the moment we will just
explain briefly the discovering acquaintances process without going into
detail about the message protocol.</p>

<p>The peer called "Alice" has 2 acquaintances resulting from its first
contact with the P2P infrastructure and by default NOA is 10 peers.
Alice must find at least 8 peers to be able to stay with a certain
guarantee inside the infrastructure.</p>

<p>The acquaintance discovering works as follows:</p>

<ul>

	<li>Send an exploring message to all of its acquaintances, and wait for
	responses from new acquaintances (not peers that have already been
	contacted peers and not already known peers).</li>

	<li>When receiving an exploring message:
	<ul>

		<li>Forward the message to acquaintances until the message Time To
		Live (TTL) reaches 0. <br>

		</li>

		<li>Choose to be or not to be an acquaintance of the asking peer.</li>

	</ul>

	</li>

</ul>

<p>In order to not have isolated peers in the infrastructure, all peers
registration are symmetric. That means if Alice knows the peer "Bob",
Bod also knows Alice. Hence, when a peer chooses whether to be an
acquaintance or not, the peer has to check previously in its own
acquaintance list if it doesn't already know the asking peer. Next, if
it's an unknown peer, the peer decides with a random function to be an
acquaintance or not. With the parameter of <b>agree responses</b>, it is
possible to configure the percentage of positive responses to an
exploring message. The random function is a temporary solution to solve
the flooding problem due to the message protocol (see next <a
	href="#mozTocId299524">section</a>), we are thinking of using a new
parameter Maximum Number of Acquaintances and improving the message
protocol. For the moment, we don't consider peers IP addresses or
geographical location of the peers as an acquaintances criteria.<br>

</p>

<p>As the P2P infrastructure is a dynamic environment, the list of
acquaintances must also be dynamic. Many acquaintances could be
unavailable and must be removed of the list. When the size of the list
is less than the NOA, the peer has to discover new peers. Therefore, all
peers keep their lists up-to-date. That's why a new parameter must be
introduced: <b>Time To Update (TTU)</b>. The peer must frequency check
its own acquaintances' list to remove unavailable peers and discover new
peers. To verify the acquaintances availability, the peer send a <b>Heart
Beat</b> to all of its acquaintances. The heart beat is sent every TTU.</p>

<p>The next figure shows a peer which is sending a heart beat to all of
its acquaintances.</p>

<div align="center"><img src="p2p_files/heartbeat.jpg" alt="Heart Beat">
<p><b class="legend">Heart beat sent every TTU.</b></p>

</div>

<h4><a class="mozTocH4" name="mozTocId299524"></a>Asking Computational
Nodes<br>

</h4>

<p>The main goal of this work is to provide an infrastructure for
sharing computational nodes (JVMs). Therefore, a resource query
mechanism is needed; there are 2 types of resources in this context,
thus 2 query types:</p>

<ul>

	<li>Exploring the P2P infrastructure to search new acquaintances.</li>

	<li>Asking free computational nodes to deploy distributed applications.</li>

</ul>

<p>The mechanism is similar to Gnutella's communication system: <b>Breadth-First
Search</b> algorithm (BFS). The system is message-based with
application-level routing. <br>

</p>

<p>All BFS messages must contain this information:</p>

<ul>

	<li>A Unique Universal Message Identifier (UUID): this message
	identifier is not totally universally unique, it is just unique for the
	infrastructure;</li>

	<li>The <b>Time To Live (TTL) infrastructure parameter</b>, in number
	of hops;</li>

	<li>A reference to the requester peer. The peer waits for responses for
	nodes or acquaintances.</li>

</ul>

<p>Our BFS inspired version works as follow:</p>

<ul>

	<li><b>Broadcasting</b> a request message to all of its acquaintances
	with an <b>UUID</b>, and <b>TTL</b>, and <b>number of asked nodes</b>.</li>

	<li>When <b>receiving</b> a message:
	<ul>

		<li>Test the message UUID, <b>is it an old message?</b>
		<ul>

			<li>Yes, it is: continue;</li>

			<li>No, it's not:
			<ul>
				<li><b>Keep</b> the <b>UUID</b>;</li>
				<li>I have a free node:</li>
				<ul>
					<li>Send the node reference to the caller and waiting an <b>ACK</b>
					until <b>timeout</b></li>
					<li>if <b>timeout</b> is reached or <b>NACK</b></li>
					<ul>
						<li>continue;</li>
					</ul>
					<li>if <b>ACK</b> and <b>asked nodes - 1 &gt; 0</b> and <b>TTL &gt;
					0</b> then</li>
					<ul>
						<li><b>Broadcast</b> with <b>TTL - 1</b> and <b>asked nodes -1</b>
						</li>
					</ul>
					<li>continue;</li>
				</ul>
			</ul>

			</li>

		</ul>

		</li>

	</ul>

	</li>

</ul>

<p>Gnutella's BFS got a lot of justified critics for scaling, bandwidth,
etc. It is true this protocol is not good enough but we're working to
improve it. We are inquiring into solutions with a not fixed TTL to
avoid network flooding.</p>

<p>The next Figure shows briefly the execution of the inspired BFS
algorithm:<br>

</p>

<div align="center"><img src="p2p_files/sendingNode.jpg"
	alt="Asking nodes">
<p><b class="legend">Asking nodes to acquaintances and getting a node.</b></p>

</div>

<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<h2><a class="mozTocH2" name="mozTocId197757"></a><a
	name="implementation"></a>The P2P Infrastructure Implementation</h2>

<h3><a class="mozTocH3" name="mozTocId467214"></a>Peers Implementation</h3>

<p>The P2P infrastructure is implemented with ProActive. Thus the shared
resource is not a JVMs but a ProActive node, nodes are like a container
which receives work.</p>

<p>The P2P infrastructure is not directly implemented in the ProActive
core at the ProActive runtime level because we choose to be above
communication protocols, such as RMI, HTTP, Ibis, etc. Therefore, the
P2P infrastructure can use RMI or HTTP as communication layer. Hence,
the P2P infrastructure is implemented with classic ProActive active
objects and especially with ProActive typed group for broadcasting
communications between peers due to your inspired BFS.</p>

<p>Using active objects for the implementation is a good mapping with
the idea of a peer which is an independent entities that works as a
server with a FIFO request queue. The peer is also a client which sends
requests to other peers.</p>

<p>The list of P2P active objects:</p>

<ul>

	<li><b>P2PService</b>: is the main active object. It serves all
	register requests or resource queries, such as nodes or acquaintances.</li>

	<li><b>P2PNodeManager</b>: works together with the P2PService, this
	active object manages one or several shared nodes. It handles the
	booking node system, see <a href="#mozTocId690451">here</a> for more
	details.</li>

	<li><b>P2PAcquaintanceManager</b>: manages the list of acquaintances
	and provides group communication, see next <a href="#mozTocId587594">section</a>.</li>

	<li><b>P2PNodeLookup</b>: works as a broker when the P2PService asks
	nodes. All the asking node protocol is inside it. This broker can
	migrate to a different node to be closer to the deployed application.</li>

	<li><b>FirstContact</b>: it's the <a href="#mozTocId101413">bootstrapping</a>
	object.</li>

</ul>

<div>
<p>The Figure below shows the connection between all active objects:</p>

</div>

<div style="text-align: center;"><img src="p2p_files/implementation.jpg"
	alt="P2P Implementation"></div>

<p style="text-align: center;"><b class="legend">Nodes and Active
Objects which make up a P2P Service.</b></p>

<p>All communications between peers use Group communication but for
sending a response to a request message, it's a point-to-point
communication. Though ProActive communications are asynchronous, it's
not really messages which are sent between peers. Nevertheless, it's not
a real problem; ProActive is implemented above Java RMI which is RPC and
RPC is synchronous. However, ProActive uses future mechanism and
Rendez-vous method to turn RPC methods to asynchronous. That means
ProActive is asynchronous RPC. Rendez-vous is interesting in your case
because it&nbsp; guarantees the method is successfully received by the
receiver. With the Heart beat message which is sent a Java exception
when an acquaintance is down. <br>

</p>

<p>The P2PAcquaintanceManager manages the list of acquaintances, this
list is represented by a ProActive typed group of P2PService. This is
the point of the next section.</p>

<h3><a class="mozTocH3" name="mozTocId587594"></a>Dynamic Shared
ProActive Group</h3>

<p>ProActive typed group does not allow access to group elements and
make calls from different active objects to the same group is not
possible, i.e. a group can not be shared. However, the point of the P2P
infrastructure is to broadcast messages to all members on the
acquaintance list, ProActive typed group is&nbsp; perfect for doing
that. A typed group of P2PService is a good implementation of the
acquaintance list design.</p>

<p>But a typed group does not support to be shared by many active
objects, especially for making group method calls from different
objects, adding / removing / etc. members in the group. For the P2P
infrastructure the P2PAcquaintanceManager (PAM) was designed.</p>

<p>The PAM is a standard active object, at its initialization it
constructs an empty P2PService group. The PAM provides an access to few
group methods, such as removing, adding and group size methods. All
other active objects, such as P2PService or P2PNodeLookup, have to use
PAM methods to access the group. The PAM works as a server with an FIFO
queue behind the group.</p>

<p>That solves the problem of group members accessing but not how other
active objects can call methods on the group. The ProActive group API
provides a method to active a group that is made possible to get
ProActive reference on the group. The PAM actives the group after its
creation. P2PService, P2PNodeLookup and all get the group reference from
a PAM's getter.</p>

<p>The PAM, during its activity, frequently sends heart beats to remove
unavailable peers. The P2PService adds, via the PAM, new discovered
acquaintances (P2PService) and the P2PNodeLookup calls group methods to
ask nodes to the group reference. The P2PService does also group method
calls.</p>

<p>In short, this can be seen in the next Figure:</p>

<div align="center"><img src="p2p_files/dynamicGroup.jpg"
	alt="Dynamic Shared Group">
<p><b class="legend">Dynamic Shared ProActive Typed Group.</b></p>

</div>

<p>We just explained how to share a typed group between active objects
but that is not solve all the problems. For the moment, the BFS
implementation with broadcasting to all acquaintances each time is not
perfect due to the message which is always send back to the previous
sender. We are working to add member exclusion in a group method call.<br>

</p>

<h3><a class="mozTocH3" name="mozTocId690451"></a>Sharing Node Mechanism</h3>

<p>The sharing node mechanism is an independent activity from the P2P
service. Nodes are the sharing resource of this P2P network. This
activity is handled by the P2PNodeManager active object.</p>

<p>At the initialization of the P2PNodeManager (PNM), it has to
instantiate the shared resource. By default, it's 1 ProActive nodes by
CPUs, for example on a single processor machine the PNM starts 1 node
and on a bi-processors machine it starts 2 nodes. It's possible to
choose to share only a single node. An another way is to share nodes
from an XML deployment descriptor file by specifing the descriptor to
the PNM which actives the deployment and gets nodes ready to share.</p>

<p>When the P2P service receives a node request, the request is
forwarded (after the BFS broadcast) to the PNM which checks for a free
node. In the case of at least 1 free node, the PNM must book the node
and send back a reference to the the node to the original request
sender. However, the booking remains valid for a predetermined time,
this time expires after a configurable timeout. The PNM knows if the
node is used or not by testing the active object presence inside the
node. Consequently, at the end of the booking time, the PNM kills the
node, the node is no longer usable. Though, some applications need empty
nodes for a long time before using them, thereby there is a pseudo
expand booking time system: creating "Dummy" active objects in booked
nodes for later use. This system is allowed by the P2PNodeLookup.</p>

<p>The P2PNodeLookup could receive more nodes than it needs, for all
additional nodes, the P2PNodeLookup sends a message to all PNMs' nodes
to cancel its booking on the node.</p>

<p>The deployed applications have to leave nodes after use. Therefore,
the PNM offers a leaving node mechanism that is the application sent a
leaving message for a specified node to the PNM which kills all node's
active objects by terminating their bodies and kills the node. After
that, the PNM creates a new node which is ready for sharing. However, if
nodes are deployed by an XML descriptor the PNM does't kill the node, it
just terminates all its active objects and re-shares the same node.</p>

<p>The asking node mechanism is allowed by the P2PNodeLookup, this
object is active by the P2PService when it receives an asking node
request from an application. The P2PNodeLookup (PNL) works as a broker,
it could migrate to another place (node, machine, etc.) to be near the
application.</p>

<p>The PNL aims to find the number of nodes requested by&nbsp; the
application. It uses the BFS to frequently flood the network until it
gets all nodes or until the timeout is reached. However, the application
can ask to the maximum number of nodes, in that case the PNL asks to
nodes until the end of the application. The PNL provides a listener /
producer event mechanism which is great for the application which wants
to know when a node is found.<br>

</p>

<p>Finally, the application kills nodes by the PNL which is in charge of
contacting all the PNMs of each node and asks them to leave nodes. The
PNMs leave nodes with the same mechanism of the booking timeout.</p>

<p>Lastly, the asking nodes mechanism with the PNL is fully integrated
to the ProActive XML deployment descriptor.</p>

<h3><a class="mozTocH3" name="mozTocId586812"></a>IC2D Screen shot</h3>

<p>A screen shot made with IC2D. You can see 3 P2P services which are
sharing 2 nodes (bi-processors machines). Inside the nodes there are
some active Domain objects from the nBody application which is deployed
on this small P2P infrastructure.</p>

<div align="center"><img src="p2p_files/screenshot.jpg"
	alt="IC2D Screen Shot">
<p></p>

</div>

<div align="center">
<p><b class="legend">nBody application deployed on P2P Infrastructure.</b></p>

</div>

<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<h2><a class="mozTocH2" name="mozTocId325247"></a>Installing and Using
the P2P Infrastructure</h2>

<h3><a class="mozTocH2" name="mozTocId765069"></a><a name="network"></a>Create
your P2P Network</h3>

<p>The P2P infrastructure is self-organized and configurable. When the
infrastructure is running you have nothing to do to keep it up. There
are 3 main parameters to configure:</p>

<ul type="disc">

	<li><b>Time To Update (TTU)</b>: each peer checks if its known peers
	are available when TTU expires. By default, its value is 1 minute.</li>

	<li><b>Number Of Acquaintances (NOA)</b>: is the minimal number of
	peers one peer needs to know to keep up the infrastructure. By default,
	its value is 10 peers.</li>

	<li><b>Time To Live (TTL)</b>: in hops for JVMs (node) depth search
	(acquisition). By default, its value is 5 hops.</li>

</ul>

<p>All parameter descriptions and the way to change their default values
are explained <a href="Configuration.html#p2p_properties">here</a>. Next
section shows how to configure the infrastructure when starting the P2P
Service with the command line.</p>

<p>The bootstrapping or first contact problem is how a new peer can join
the p2p infrastructure. We solved this problem by just specifying one or
several addresses of supposed peers which are running in the p2p
infrastructure. Next, we will explain how and where you can specify this
list of peers.</p>

<p>Now, you just have to start peers. There are two ways to do so:</p>

<h4><a class="mozTocH3" name="mozTocId117139"></a>Quick Start Peer</h4>

<p>This method explains how to rapidly launch a simple P2P Service on
one host.</p>

<p>ProActive provides a very simple <i>script</i> to start a P2P Service
on your local host. The name of this script is <b>startP2PService</b>.</p>

<ul>

	<li>UNIX, GNU/Linux, BSD and MacOsX systems: the script is located in <b>ProActive/scripts/unix/p2p/startP2PService.sh</b>
	file.</li>

	<li>Microsoft Windows system: the script is located in <b>
	ProActive/p2p/scripts/windows/p2p/startP2PService.bat</b> file.</li>

</ul>

<p>Before launching this script, you have to specify some parameters to
this command:</p>

<pre class="snippet">startP2PService [-acq acquisitionMethod] [-port portNumber] [-s Peer ...] [-f PeersListFile]</pre>

<ul>

	<li><b>-acq acquisitionMethod</b> the ProActive Runtime communication
	protocol used. Examples: rmi, http, ibis, ... By default it is <i>rmi</i>.</li>

	<li><b>-port portNumber</b> is the port number where the P2P Service
	will listen. By default it is <i>2410</i></li>

	<li><b>-s Peer ...</b> specify addresses of peers which are used to
	join the P2P infrastructure. Example: <pre class="snippet">rmi://applepie.proactive.org:8080</pre>

	</li>

	<li><b>-f PeersListFile</b> same of <b>-s</b> but peers are specified
	in file <b>ServerListFile</b>. One per line.</li>

</ul>

<p>More options:</p>

<ul>

	<li><b>-noa NOA</b> in number of host. NOA is the minimal number of
	peers one peer needs to know to keep up the infrastructure. By default,
	its value is 10 peers.</li>

	<li><b>-ttu TTU</b> is in minutes.&nbsp; Each peer sends a heart beat
	to its acquaintances. By default, its value is 1 minute.</li>

	<li><b>-ttl TTL</b> is in hop. TTL represents live time messages in
	hops of JVMs (node). By default, its value is 5 hops.</li>

	<li><b>-capacity Number_of_Messages</b> is the maximum memory size to
	stock message UUID. Default value is 1000 messages UUID.</li>

	<li><b>-exploring Percentage</b> is the percentage of agree response
	when a peer is looking for acquaintances. By default, its value is 66%.</li>

	<li><b>-booking Time</b> in ms it takes while booking a shared node.
	It's the maximum time in milliseconds to create at least an active
	object in the shared node. After this time, and if no active objects
	are created, the shared node will leave and the peer which gets this
	shared node will be no longer be able to use it. Default is 3 minutes.</li>

	<li><b>-node_acq Time</b> in milliseconds which is the timeout for node
	acquisition. The default value is 3 minutes.</li>

	<li><b>-lookup Time</b> is the lookup frequency in milliseconds for
	re-asking nodes. By default, it's value is 30 seconds.</li>

	<li><b>-no_multi_proc_nodes</b> to share only a node. Otherwise, 1 node
	by CPU that means the p2p service which is running on a bi-pro will
	share 2 nodes. By default, 1 shared node for 1 CPU.</li>

	<li><b>-xml_path</b> to share nodes from a XML deployment descriptor
	file. This option takes a file path. By default, no descriptors are
	specified. That means the P2P Service shares only one local node or one
	local node by CPUs.</li>

</ul>

<p>All arguments are optional.</p>

<p><b>Comment: </b>With the UNIX version of the startP2PService script,
the P2P service is persistent and runs like a UNIX <i>nice</i> process.
If the JVMs that are running the P2P service stop (for a Java exception)
the script re-starts a new one.</p>

<h4><a class="mozTocH4" name="mozTocId979491"></a>Usage Example</h4>

<p>In this illustration, we will explain how to start a first peer and
then how new peers can create a P2P network with the first one.</p>

<p>Start the first peer with <i>rmi</i> protocol and listening on port <i>2410</i>:</p>

<pre class="snippet">first.peer.host$startP2PService.sh -acq rmi -port 2410</pre>

<p>Now, start new peers and connect them to the first peer to create a
tiny P2P network:</p>

<pre class="snippet">second.peer.host$startP2PService.sh -acq rmi -port 2410 -s rmi://first.peer.host</pre>

<p></p>

<pre class="snippet">third.peer.host$startP2PService.sh -acq rmi -port 2602 -s rmi://first.peer.host</pre>

<p>You could specify a different port number for each peer.</p>

<p>Use a file to specify the addresses of peers:</p>

<p>The file <i>hosts.file</i>:</p>

<pre class="snippet"> rmi://first.peer.host:2410<br> rmi://third.peer.host:2602<br><br></pre>

<pre class="snippet"> file.peer.host$startP2PService.sh -acq rmi -port 8989 -f hosts.file</pre>

<p>Lastly, a new peer joins the P2P network:</p>

<pre class="snippet">last.peer.host$startP2PService.sh -acq rmi -port 6666 -s rmi://third.peer.host:2410</pre>

<div align="center"><img src="p2p_files/example.jpg" alt="Example">
<p><b class="legend">Usage example P2P network (after firsts
connections).</b></p>

</div>

<h4><a class="mozTocH3" name="mozTocId690540"></a>The P2P Daemon</h4>

<p>The daemon aims to use computers in Peer-to-Peer computations. There
will be a Java virtual machine sleeping on your computer and waking up
at scheduled times to get some work done.</p>

<p>By default, the JVM is scheduled to wake up during the weekend and
during the night. Next, we will explain how to change the schedule. The
JVM is running with the lowest priority.</p>

<h5><a class="mozTocH4" name="mozTocId895651"></a>Installation</h5>

<b>UNIX</b>
<p>Go to the directory: <b>ProActive/compile</b> and run this command:</p>

<pre class="snippet">$ ./build daemon</pre>

<p>Before compiling you should change some parameters like the daemon
user or the port in the file:</p>

<pre class="snippet">ProActive/p2p/src/common/proactivep2p.h</pre>

<p></p>

<p>Ask your system administrator to add the daemon in a crontab or
init.d. The process to run is located here:</p>

<pre class="snippet">ProActive/p2p/build/proactivep2p</pre>

<b>Microsoft Windows</b>
<p>To compile daemon source (in c++), we don't provide any automatic
script, you have to do it yourself. All sources for Windows are in the
directory: <b>ProActive/p2p/src/windows</b>. If you use Microsoft Visual
Studio, you can find&nbsp; in the src directory the Microsoft VS project
files.</p>

<p>After that you are ready to install the daemon with Windows, you just
have to run this script:</p>

<pre class="snippet">C:&gt;ProActive\scripts\windows\p2p\Service\install.bat</pre>

<p>To remove the daemon:</p>

<pre class="snippet">C:&gt;ProActive\scripts\windows\p2p\Service\remove.bat</pre>

<p><b>Comment</b>: By default the port number of the daemon is <b>9015</b>.</p>

<h5><a class="mozTocH4" name="mozTocId799743"></a>Configuration</h5>

<p>The daemon is configured with XML files in the <b>ProActive/p2p/config/</b>
directory. To find the correct configuration file, the daemon will first
try with a host dependent file: <b>config/proactivep2p.${HOST}.xml</b>
for example: <b>config/proactivep2p.camel.inria.fr.xml</b> if the daemon
is running on the host named <b>camel.inria.fr.</b></p>

<p>If this host specific file is not found, the daemon will load <b>config/proactivep2p.xml</b>.
This mechanism can be useful to setup a default configuration and have a
specific configuration for some hosts.</p>

<p>The reference is the XML Schema in <a
	href="p2p_files/proactivep2p.xsd">proactivep2p.xsd</a>. For those not
fluent in XML Schema, here is a description of all markup tags--</p>

<p>The root element in <b>&lt;configFile&gt;</b> it contains one or many
<b>&lt;p2pconfig&gt;</b> . This latter element can start with a <b>&lt;loadconfig
path="path/to/xml"/&gt;</b> it will include the designated XML file.
After these file inclusions, you can with <b>&lt;host
name="name.domain"&gt;</b> specify which hosts are concerned by the
configuration. Then there can be a <b>&lt;configForHost&gt;</b> element
containing a configuration for the selected hosts and/or a <b>&lt;default&gt;</b>
element if no suitable configuration was already found.</p>

<p>Bear in mind that the XML parser sees a lot of configuration and the
first that matches is used and the parsing is finished. This means that
the elements we have just seen are tightly linked together. For example
if an XML file designated by a <b>&lt;loadconfig&gt;</b> contains a <b>&lt;default&gt;</b>
element, then after this file no other element will be evaluated. This
is because either a configuration was already found so the parsing
stops, or no configuration matched and the <b>&lt;default&gt;</b> does,
so the parsing ends.</p>

<p>The proper configuration is contained in a <b>&lt;configForHost&gt;</b>
or <b>&lt;default&gt;</b> element. It consists of the scheduled times
for work and the hosts where we register ourselves. Here is an example:</p>

<table width="100%">

	<tbody>

		<tr>

			<td>
			<table class="xml" align="left">

				<tbody>

					<tr>

						<td>
						<p class="xml">&lt;periods&gt;<br>

						&nbsp;&lt;period&gt;<br>

						&nbsp; &lt;start day="monday" hour="18" minute="0"/&gt;<br>

						&nbsp; &lt;end day="tuesday" hour="6" minute="0"/&gt;<br>

						&nbsp; &lt;/period&gt;<br>

						&nbsp; &lt;period&gt;<br>

						&nbsp;&nbsp; &lt;start day="saturday" hour="0" minute="0"/&gt;<br>

						&nbsp;&nbsp; &lt;end day="monday" hour="6" minute="0"/&gt;<br>

						&nbsp; &lt;/period&gt;<br>

						&lt;/periods&gt;<br>

						&lt;register&gt;<br>

						&nbsp;&lt;registry url="trinidad.inria.fr"/&gt;<br>

						&nbsp;&lt;registry url="amda.inria.fr"/&gt;<br>

						&nbsp;&lt;registry url="tranquility.inria.fr"/&gt;<br>

						&nbsp;&lt;registry url="psychoquack.inria.fr"/&gt;<br>

						&lt;/register&gt;<br>

						</p>

						</td>

					</tr>

				</tbody>
			</table>

			</td>

		</tr>

	</tbody>
</table>

<p>In this example we clearly see that the JVM will wake up Monday
evening and shut down Tuesday morning. It will also work during the
weekend. In the <b>&lt;register&gt;</b> part we put the URL in which we
will register ourselves, in the example we used the short form which is
equivalent to <i>rmi://host:9301</i>.</p>

<h5><a class="mozTocH4" name="mozTocId994982"></a>Control</h5>

<p>The following commands only work with UNIX friendly systems.</p>

<ul>

	<li><b>Stop the JVM</b>: This command will stop the JVM and will
	restart it at the next scheduled time, which is the day after:<br>

	<pre class="snippet">$ProActive/p2p/build/p2pctl stop [hostname]</pre>

	</li>

	<li><b>Kill the daemon</b>:<br>

	<pre class="snippet">$ProActive/p2p/build/p2pctl killdaemon [hostname]</pre>

	</li>

	<li><b>Restart the daemon</b>: <pre class="snippet">$ProActive/p2p/build/p2pctl restart [hostname]</pre>

	</li>

	<li><b>Test the daemon</b>: <pre class="snippet">$ProActive/p2p/build/p2pctl alive [hostname]</pre>

	</li>

	<li><b>Flush the daemon logs</b>: <pre class="snippet">$ProActive/p2p/build/p2pctl flush [hostname]</pre>

	</li>

</ul>

<p><b>hostname</b> is the name of the remote host which the daemon
command is sent to. This parameter is optional, if the host name is not
specified the command is executed on the local host.</p>

<p>Under Windows you could use some littles scripts in <b>ProActive//script/windows/p2p/JVM</b>
to do that.</p>

<p>All daemon logs are written in a file. All logs are available in:</p>

<pre class="snippet">ProActive/p2p/build/logs/hostname</pre>

<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<h3><a class="mozTocH2" name="mozTocId315155"></a><a name="appli"></a>Example
of Acquiring Nodes by ProActive XML Deployment Descriptors</h3>


<p>You can customize some P2P settings such as:</p>

<ul>

	<li><b>nodesAsked</b> is the number of nodes you want from the P2P
	infrastructure. Setting <b>MAX</b> as value is equivalent to an
	infinite number of nodes. This attribute is required.</li>

	<li><b>acq</b> is the communication protocol that's used to communicate
	with this P2P Service. All ProActive communication protocols are
	supported: rmi, http, etc. Default is rmi.</li>

	<li><b>port</b> represents the port number on which to start the P2P
	Service. Default is 2410. The port is used by the communication
	protocol.</li>

	<li>The <b>NOA Number Of Acquaintances</b> is the minimal number of
	peers one peer needs to know to keep up the infrastructure. By default,
	its value is 10 peers.</li>

	<li>The <b>TTU Time To Update</b> each peer sends a heart beat to its
	acquaintances. By default, its value is 1 minute.</li>

	<li>The <b>TTL Time To Live</b> represents messages live time in hops
	of JVMs (node). By default, its value is 5 hops.</li>

	<li><b>multi_proc_nodes</b> is a boolean (use true or false) attribute.
	When its value is true the P2P service will share 1 node by CPU, if not
	only one node is shared. By default, its value is true, i.e. 1 node /
	CPU.</li>

	<li><b>xml_path</b> is used with a XML deployment descriptor path. The
	P2P Service shares nodes which are deployed by the descriptor. No
	default nodes are shared.<br>

	</li>

	<li><b>booking_nodes</b> is a boolean value (true or false). During
	asking nodes processs there is a timeout, booking timeout is used
	for&nbsp; obtaining nodes. That means if no active objects are created
	before the end of the timeout, the node will be free and no longer
	shared. To avoid the booking timeout, put this attribute at true,
	obtained nodes will be <span onclick="dr4sdgryt()">permanently</span>
	booked for you. By default, its value is false. See below, for more
	information about the booking timeout.</li>

</ul>

<p>With elements <b>acq</b> and <b>port</b>,&nbsp; if a P2P Service is
already running with this configuration the descriptor will use this
one, if not a new one is started.</p>

<p>In order to get nodes, the <b>peerSet</b> tag will allow you to
specify entry point of your P2P Infrastructure.</p>

<p>You can get nodes from the P2P Infrastructure using the ProActive
Deployment Descriptor as described above. <br>

In fact you will ask for a certain number of nodes and ProActive will
notify a "listener" (one of your class), every time a new node is
available.</p>

<pre class="snippet"> ProActiveDescriptor pad = ProActive.getProactiveDescriptor("myP2PXmlDescriptor.xml");<br><br> // getting virtual node "p2pvn" defined in the ProActive Deployement Descriptor<br> VirtualNode vn = pad.getVirtualNode("p2pvn");<br> <br> // adding "this" or anyother class has a listener of the "NodeCreationEvent"<br> ((VirtualNodeImpl) vn).addNodeCreationEventListener(this);<br><br> //activate that virtual node<br> vn.activate();<br><br></pre>

<p>As you can see, the class executing this code must implement an
interface in order to be notified when a new node is available from the
P2P infrastructure.<br>

Basically you will have to implement the interface
NodeCreationEventListener that can be found in package
org.objectweb.proactive.core.event. For example, this method will be
called every time a new host is acquired:</p>

<pre class="snippet"> public void nodeCreated(NodeCreationEvent event) <br> {<br> // get the node<br> Node newNode = event.getNode();<br><br>	// now you can create an active object on your node.<br> }<br> <br></pre>

<p>You should carefully notice that you can be notified at any time,
whatever the code you are executing, once you have activated the virtual
node.</p>

<p>A short preview of a XML descriptor:</p>

<table width="100%">

	<tbody>

		<tr>

			<td>
			<table class="xml" align="left">

				<tbody>

					<tr>

						<td>
						<p class="xml">&lt;infrastructure&gt;<br>

						&nbsp;&lt;services&gt;<br>

						&nbsp; &lt;serviceDefinition id="p2pservice"&gt;<br>

						&nbsp;&nbsp; &lt;P2PService nodesAsked="2" acq="rmi" port="2410"
						NOA="10" TTU="60000" TTL="10"&gt;<br>

						&nbsp;&nbsp;&nbsp; &lt;peerSet&gt;<br>

						&nbsp;&nbsp;&nbsp;&nbsp;
						&lt;peer&gt;rmi://localhost:3000&lt;/peer&gt;<br>

						&nbsp;&nbsp;&nbsp; &lt;/peerSet&gt;<br>

						&nbsp;&nbsp; &lt;/P2PService&gt;<br>

						&nbsp; &lt;/serviceDefinition&gt;<br>

						&nbsp;&lt;/services&gt;<br>

						&lt;/infrastructure&gt;<br>

						</p>

						</td>

					</tr>

				</tbody>
			</table>

			</td>

		</tr>

	</tbody>
</table>

<p>A complete example of file is available <a
	href="p2p_files/sample_p2p.xml">here</a>.</p>

<p>The next figure shows a P2P Service started with a XML deployment
descriptor (xml_path attribute). Six nodes are shared on different
hosts:</p>

<div align="center"><img src="p2p_files/descriptor.jpg"
	alt="Sharing nodes with descriptor.">
<p><b class="legend">A P2P Service which is sharing nodes deployed by a
descriptor.</b></p>

</div>

<p>For more information about ProActive XML Deployment Descriptor see
this <a
	href="http://www-sop.inria.fr/oasis/ProActive/doc/api/org/objectweb/proactive/doc-files/Descriptor.html">page</a>.</p>

<h3><a class="mozTocH3" name="mozTocId294040"></a>The P2P Infrastructure
API Usage Example</h3>

<p>The next little sample of code explains how, from an application, you
can start a P2P Service and get nodes:</p>

<pre class="snippet"><br>import org.objectweb.proactive.ProActive;<br>import org.objectweb.proactive.core.ProActiveException;<br>import org.objectweb.proactive.core.mop.ClassNotReifiableException;<br>import org.objectweb.proactive.core.node.Node;<br>import org.objectweb.proactive.core.node.NodeException;<br>import org.objectweb.proactive.core.node.NodeFactory;<br>import org.objectweb.proactive.core.runtime.ProActiveRuntime;<br>import org.objectweb.proactive.core.runtime.RuntimeFactory;<br>import org.objectweb.proactive.p2p.core.service.P2PService;<br>import org.objectweb.proactive.p2p.core.service.StartP2PService;<br>import org.objectweb.proactive.p2p.core.service.node.P2PNodeLookup;<br>...<br>// This constructor uses a file with address of peers<br>// See the Javadoc to choose different parameters<br>StartP2PService startServiceP2P = new StartP2PService(p2pFile)<br><br>// Start the P2P Service on the local host<br>startServiceP2P.start();<br><br>// Get the reference on the P2P Service<br>P2PService serviceP2P = startServiceP2P.getP2PService();<br><br>// By the application's P2P Service ask to the P2P infrastructure<br>// for getting nodes.<br>P2PNodeLookup p2pNodeLookup = p2pService.getNodes(nNodes,<br> virtualNodeName, JobID);<br><br>// You can migrate the P2P node lookup from the p2p service<br>// to an another node:<br>p2pNodeLookup.moveTo("//localhost/localNode");<br><br>// Use method from p2pNodeLookup to get nodes<br>// such as<br>while (! p2pNodeLookup.allArrived()) {<br> Vector arrivedNodes = p2pNodeLookup.getAndRemoveNodes();<br> // Do something with nodes<br> ...<br>}<br><br>// Your application<br>...<br><br>// End of your program<br>// Free shared nodes<br>p2pNodeLookup.killAllNodes();<br><br></pre>

<h2><a class="mozTocH2" name="mozTocId789872"></a><a name="limitations"></a>Future
Work</h2>

<ul>

	<li>Plug technical services, such as Fault-tolerance schemes or Load
	Balancing, for each application at the deployment time.</li>

</ul>

<hr>
<div class="textSmall" align="right">Copyright &copy;  2001-2005 INRIA
All Rights Reserved.</div>

<!-- Footer : end -->
</body>
</html>
