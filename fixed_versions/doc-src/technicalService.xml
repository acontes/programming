<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<chapter id="technicalService">
	<title>Technical Service</title>

	<indexterm>
		<primary>Technical Service</primary>
	</indexterm>

	<sect1>
		<title>Context</title>

		<para>
			For effective components, non-functional aspects must be
			added to the application functional code. Likewise
			enterprise middleware and component platforms, in the
			context of Grids, services must be deployed at execution in
			the component containers in order to implement those
			aspects. This work proposes an architecture for defining,
			configuring, and deploying such
			<emphasis role="bold">Technical Services</emphasis>
			in a Grid platform.
		</para>

	</sect1>
	<sect1>
		<title>Overview</title>

		<para>
			A technical service is a non-functional requirement that may
			be dynamically fulfilled at runtime by adapting the
			configuration of selected resources.
		</para>

		<para>
			From the programmer point of view, a technical service is a
			class that implements the
			<literal>TechnicalService</literal>
			interface. This class defines how to configure a node.
		</para>
		<programlisting lang="java">package org.objectweb.proactive.core.descriptor.services;
			
public interface TechnicalService { 
	public void init(HashMap argValues);
	public void apply(Node node);
}</programlisting>
		<para>
			From the deployer point of view, a technical service is a
			set of ”variable-value” tuples, each of them configuring a
			given aspect of the application environment.
		</para>
		<programlisting lang="xml">&lt;technical-service id="myService" class="services.Service1">
	&lt;arg name="name1" value="value1" />
	&lt;arg name="name2" value="value2" />
&lt;/technical-service></programlisting>
		<para>
			The class attribute defines the implementation of the
			service, a class which must implement the
			<literal>TechnicalService</literal>
			interface.
		</para>
		<para>
			The configuration parameters of the service are specified by
			<literal>arg</literal>
			tags in the deployment descriptor. Those parameters are
			passed to the
			<literal>init</literal>
			method as a map associating the name of a parameter as a key
			and its value. The
			<literal>apply</literal>
			method takes as parameter the node on which the service must
			be applied. This method is called after the creation or
			acquisition of a node, and before the node is used by the
			application.
		</para>

		<note>
			<para>
				Two or several technical services could be combined if
				they touch separate aspects. Indeed, two different
				technical services, which are conceptually orthogonal,
				could be
				<emphasis role="bold">
					incompatible at source code level
				</emphasis>
				.
			</para>
			<para>
				That is why a virtual node can be configured by only
				<emphasis role="bold">one</emphasis>
				technical service. However, combining two technical
				services can be done at source code level, by providing
				a class extending
				<literal>TechnicalService</literal>
				that defines the correct merging of two concurrent
				technical services.
			</para>
		</note>
	</sect1>

	<sect1>
		<title>Progamming Guide</title>
	
	<sect2>
		<title>A full XML Descriptor File</title>
		<programlisting lang="xml">&lt;ProActiveDescriptor>
	&lt;componentDefinition>
		&lt;virtualNodesDefinition>
			&lt;virtualNode name="master" property="multiple" serviceRefid="ft-master" />
			&lt;virtualNode name="slaves" property="multiple" serviceRefid="ft-slaves" />
		&lt;/virtualNodesDefinition>
	&lt;/componentDefinition>
	...
	&lt;infrastructure>
		&lt;processes>
			&lt;processDefinition id="localJVM">
				&lt;jvmProcess class="JVMNodeProcess" />
			&lt;/processDefinition>
		&lt;/processes>
		&lt;aquisition>
			&lt;aquisitionDefinition id="p2pservice">
				&lt;P2PService nodesAsked="100000">
					&lt;peerSet>
						&lt;peer>rmi://registry1:3000&lt;/peer>
					&lt;/peerSet>
				&lt;/P2PService>
			&lt;/acquisitionDefinition>
		&lt;/services>
	&lt;/infrastructure>
	&lt;technicalServiceDefinitions>
		&lt;service id="ft-master" class="services.FaultTolerance">
			&lt;arg name="proto" value="pml" />
			&lt;arg name="server" value="rmi://host/FTServer1" />
			&lt;arg name="TTC" value="60" />
		&lt;/service>
		&lt;service id="ft-slaves" class="services.FaultTolerance">
			&lt;arg name="proto" value="cic" />
			&lt;arg name="server" value="rmi://host/FTServer2" />
			&lt;arg name="TTC" value="600" />
		&lt;/service>
	&lt;/technicalServiceDefinitions>
&lt;/ProActiveDescriptor></programlisting>
	</sect2>
	<sect2>
		<title>Nodes Properties</title>

		<para>
			In order to help programmers for implementing their owns
			technical services, we have added a property system to the
			nodes. This is usefull for configuring technical services.
		</para>

		<para>Get the current node:</para>
		<programlisting lang="java">Node localNode = ProActive.getNode();</programlisting>

		<para>Using properties:</para>
		<programlisting lang="java">String myProperty = localNode.getProperty(myKeyAsString);
localNode.setProperty(myKeyAsString, itsValueAsString);</programlisting>
	</sect2>
	</sect1>
	<sect1>
		<title>Further Information</title>
		<para>
			The seminal paper
			<citation>
				<xref linkend="CDD06c" endterm="CDD06c.abbrev" />
			</citation>
			.
		</para>
		<para>
			The first presentation of this work is available
			<ulink
				url="http://www-sop.inria.fr/oasis/personnel/Alexandre.Di_Costanzo/AdC/Publications_files/wp4_v1.pdf">
				here
			</ulink>
			.
		</para>
		<para>
			The work of this paper
			<citation>
				<xref linkend="CCDMCompFrame06"
					endterm="CCDMCompFrame06.abbrev" />
			</citation>
			is based on Technical Services.
		</para>
	</sect1>

</chapter>