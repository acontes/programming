<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<chapter id="WrappingMpiAndLegacyCode">
	<title>Wrapping MPI Legacy code</title>



	<para>The <emphasis role="bold">Message Passing Interface (MPI)</emphasis> is a widely adopted communication 
library for parallel and distributed computing. This work has been designed to make it easier to <emphasis role="bold">wrap</emphasis>, 
<emphasis role="bold">deploy</emphasis> and <emphasis role="bold">couple</emphasis> several MPI legacy codes, especially on the Grid.</para>

	<para>On one hand, we propose a <emphasis role="bold">simple wrapping</emphasis> method designed to automatically
deploy MPI applications on clusters or desktop Grid through the use of deployment descriptor, allowing an MPI application
to be embedded within ProActive. The proposed wrapping permits users to develop conventional stand-alone Java applications
using some MPI legacy codes.</para>

	<para>On the other hand, we propose a <emphasis role="bold">wrapping</emphasis> method <emphasis role="bold"> with control</emphasis>
(currently under development) designed to let SPMD processes associated with one code communicate with the SPMD processors associated with another simulation code.
This feature adds the parallel capability of MPI on the Grid with the support of ProActive for inter-process communication between
MPI processes at different Grid point. A special feature of the proposed wrapping is the support of "MPI&lt;->User Java application" communications
which permit users to exchange data towards its proper classes.</para>

	<para> The API is organized in the package <emphasis role="bold">org.objectweb.proactive.mpi</emphasis>, with the class
<emphasis role="bold">org.objectweb.proactive.mpi.MPI</emphasis> gathering static methods and the class <emphasis role="bold">org.objectweb.proactive.mpi.MPISpmd</emphasis> for which,
instances represent and allow to control a given deployed MPI code.</para>



	<!-- ////////////////////////////////// SIMPLE WRAPPING \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ -->

	<sect1>
		<title>Simple Wrapping</title>
		<sect2>
			<title>Principles</title>
			<!-- ///// PRINCIPLES \\\\ -->
			<para>This work is mainly intended to deploy automatically and transparently MPI parallel applications on clusters. 
Transparency means that a deployer does not know what particular resources provide computer power. 
So the user should have to finalize the deployment descriptor file and to get back the result of the application 
without worrying about resources selections, resource locations and types, or mapping processes on resources.
	</para>
			<para>
				<figure>
					<title>File transfer and asking for resources</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="mpi_files/deployment.png" format="PNG" width="6in" />
						</imageobject>
					</mediaobject>
				</figure>
			</para>
			<para>
				<emphasis role="bold">Suggestions on how to deploy: </emphasis>
			</para>
			<itemizedlist>

				<listitem>

					<para>
						<emphasis role="bold">File Transfer [using file descriptor]</emphasis>
					</para>

					<para>The primary objective is to provide user an automatic deployment of his application 
<emphasis role="bold">through an XML file deployment descriptor</emphasis>. In fact, ProActive provides support for File Transfer. In this way, user can
transfer MPI application <emphasis role="bold">input data</emphasis> and/or MPI <emphasis role="bold">application code</emphasis> to the remote host. The File Transfer happens before the user launches his application.
For more details about File Transfer see  <xref linkend="FileTransfer_html_intro" />.
		</para>
				</listitem>
				<listitem>

					<para>
						<emphasis role="bold">Asking for resources [using file descriptor]</emphasis>
					</para>
					<para>User describes MPI job requirements in the <emphasis role="bold">file deployment descriptor</emphasis> using a Virtual Node.
He gets back a set of Nodes corresponding to the remote available hosts for the MPI Job execution.
For more details (or usage example) about resources booking, have a look at section <emphasis role="bold">"27.4 Using the Simple Wrapping Infrastructure" </emphasis>.
				</para>
				</listitem>
				<listitem>

					<para>
						<emphasis role="bold">Control MPI process [using ProActive API]</emphasis>
					</para>
					<para>After deployment, user obtains the Virtual Node containing resources required for the MPI job, that is a set of Nodes.
The MPI API provides user with the ability to create an <emphasis role="bold">MPISpmd object</emphasis> from the Virtual Node obtained. 
To this end the programmer is able to control the MPI program, that is: trigger the job execution, kill the job, synchronize the job, get the object status/result etc..).
This API is detailed in the next chapter.
 			</para>
				</listitem>
			</itemizedlist>

		</sect2>
		<sect2>
			<title>API For Deploying MPI Codes</title>
			<!-- ///// API \\\\ -->

			<sect3>
				<title>API Definition</title>
				<!-- ///// API Definition \\\\ -->
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">What is an MPISpmd object ?</emphasis>
						</para>
						<para>
An MPISpmd object is regarded as an MPI code wrapper. It has the following features : </para>
						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold">It holds a state</emphasis> (which can take different value, and reflects the MPI code status)
								</para>
							</listitem>
							<listitem>
								<para>
									<emphasis role="bold">It can be controlled through an API</emphasis> (presented in the next section)
								</para>
							</listitem>
						</itemizedlist>

					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">MPISpmd object creation methods</emphasis>
						</para>
						<programlisting language="java">import org.objectweb.proactive.mpi;

/**
 * creates an <emphasis role="bold">MPISpmd object</emphasis> from a Virtual Node which represents the deployment of an MPI code.
 * Activates the virtual node (i.e activates all the Nodes mapped to this VirtualNode
 * in the XML Descriptor) if it's not already activated and returns an object representing
 * the MPI deployement process.
 */

static public MPISpmd <emphasis role="bold">MPI.newMPISpmd</emphasis>(VirtualNode virtualNode);
</programlisting>

					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">MPISpmd object control methods</emphasis>
						</para>
						<programlisting language="java">
/**
 * Triggers the process execution represented by the MPISpmd object on the resources previously
 * allocated. This method call is an asynchronous request, thus the call does not
 * block until the result (MPI result) is used or explicit synchronisation is required. The method
 * immediately returns a future object, especially a <emphasis role="bold">future on an MPIResult object</emphasis>.
 * As a consequence, the application can go on with executing its code, as long as it doesn't need
 * to invoke methods on this MPIResult returned object, in which case the calling thread is
 * automatically blocked if the result of the method invocation is not yet available.
 */

public <emphasis role="bold">MPIResult startMPI</emphasis>();</programlisting>


						<programlisting language="java">
/**
 * Restarts the process represented by the MPISpmd object on the same resources. This process has
 * to previously been started once with the start method, otherwise the method throws an
 * <emphasis role="bold">IllegalMPIStateException</emphasis>. If state is Running, a new independent computation is triggered,
 * and a new MPIResult object is created. It's also an asynchronous method which returns a future
 * on an MPIResult object.
 */

public <emphasis role="bold">MPIResult reStartMPI</emphasis>();</programlisting>

						<programlisting language="java">
/** 
 * Stops the process represented by the MPISpmd object. 
 * It returns true if the process was running when it has been killed, false otherwise.
 */						

public boolean <emphasis role="bold">killMPI</emphasis>();</programlisting>

						<programlisting language="java">
/**
 * Returns the current status of the MPISpmd object. The different status are listed below.
 */

public String <emphasis role="bold">getStatus</emphasis>();</programlisting>

						<programlisting language="java">
/**
 * Add or modify the MPI command parameters. It allows users to specify arguments to the MPI code.
 */

public String <emphasis role="bold">setCommandArguments</emphasis>(String arguments);</programlisting>

					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">MPIResult object </emphasis>
						</para>
						<para> An MPIResult object is obtained with the <emphasis role="bold">startMPI/reStartMPI</emphasis> methods call. Rather, these methods return
 a future on an MPIResult object that does not block application as long as no method is called on this MPIResult object.
On the contrary, application is blocked until the MPIResult object is updated and so available.
The following method gets the exit value of the MPI program.</para>
						<programlisting language="java">
/**
 * Returns the exit value of the MPI program. 
 * By usual convention, the value 0 indicates normal termination.
 */

public int <emphasis role="bold">getReturnValue</emphasis>();</programlisting>

					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">MPISpmd object status</emphasis>
						</para>

						<programlisting language="java">import org.objectweb.proactive.mpi;

<emphasis role="bold">ProActiveMPIConstants.MPI_UNSTARTED</emphasis>; // default status - after MPISpmd object creation
<emphasis role="bold">ProActiveMPIConstants.MPI_RUNNING</emphasis>;   // after MPISpmd object has been started or restarted
<emphasis role="bold">ProActiveMPIConstants.MPI_KILLED</emphasis>;    // after MPISpmd object has been killed
<emphasis role="bold">ProActiveMPIConstants.MPI_FINISHED</emphasis>;  // after MPISpmd object has finished</programlisting>
						<para> Each status defines the current state of the MPISpmd object.
 It provides the guarantee of application consistency and a better control of the application
 in case of multiple MPISpmd objects.</para>

				<para>
					<figure>
						<title>State transition diagram</title>
						<mediaobject>
							<imageobject>
								<imagedata fileref="mpi_files/status.png" format="PNG" />
							</imageobject>
						</mediaobject>
					</figure>
				</para>
					</listitem>
				</itemizedlist>
			</sect3>
</sect2>
			<sect2>
				<!-- ///// How to write an application with the API \\\\ -->
				<title>How to write an application with the API</title>

				<para>First finalize the xml file descriptor to specify files which have to be transfered on the remote hosts and resources requirement
as it is explained in the next section <xref linkend="Using_the_MPI_Infrastructure"/>.
Then import the package <emphasis role="bold">org.objectweb.proactive.mpi</emphasis>. In an attempt to keep application consistency, the MPISpmd object makes use of status.
It garantees that either the method call on object is coherent or an exception is thrown. 
Especially the exception is an <emphasis role="bold">IllegalMPIStateException</emphasis> that signals a method which has been called at an illegal or inappropriate time.
In other words, an application is not in an appropriate state for the requested operation.</para>
<para>
An application does not require to declare in its throws clause because IllegalMPIStateException is a subclass of RuntimeException.
The graph above presents a kind of finite state machine or finite automaton, that is a model of behavior composed of<emphasis role="bold"> states</emphasis> (status of the MPISpmd object) and 
<emphasis role="bold">transition actions</emphasis> (methods of the API). Once the MPISpmd object is created, the object enters in the initial state: <emphasis role="bold">ProActiveMPIConstants.MPI_UNSTARTED</emphasis>.
</para>


				<para>
					<emphasis role="bold">Sample of code (available in the release) </emphasis> 
These few lines show how to execute the MPI executive <emphasis role="bold">jacobi</emphasis> and to get its return value once finished.
No modification have to be made to the source code. 
				</para>

				<programlisting language="java">
<emphasis role="bold">import org.objectweb.proactive.mpi.*;</emphasis>

...
// load the file desciptor 
ProActiveDescriptor pad = ProActive.getProactiveDescriptor('file:descriptor.xml');

// get the Virtual Node which references the jacobi MPI code you want to execute
VirtualNode jacobiVN = pad.getVirtualNode('JACOBIVN');

// activate Virtual Node (it's not mandatory because the MPI.newMPISpmd method does
// it automatically if it has not been already done)
jacobiVN.activate();

// create the MPISpmd object with the Virtual Node
<emphasis role="bold">MPISpmd</emphasis> jacobiSpmd = <emphasis role="bold">MPI.newMPISpmd(jacobiVN);</emphasis>

// trigger jacobi mpi code execution and get future on MPIResult
<emphasis role="bold">MPIResult</emphasis> jacobiResult = jacobiSpmd.<emphasis role="bold">startMPI();</emphasis>

// print current status
logger.info("Current status: "+jacobiSpmd.<emphasis role="bold">getStatus()</emphasis>);


// get return value (block the thread until the jacobiResult is available)
logger.info("Return value: "+jacobiResult.<emphasis role="bold">getReturnValue()</emphasis>);

// print the MPISpmd object caracteristics (name, current status, processes number ...)
logger.info(<emphasis role="bold">jacobiSpmd</emphasis>);

...
	</programlisting>

		</sect2>

		<sect2 id="Using_the_MPI_Infrastructure">
			<!-- ///// Using the Infrastructure \\\\ -->
			<title>
			Using the Infrastructure</title>
			<para>
	 Resources booking is specified using ProActive Descriptors.
	We have explained the operation with an example included in the release. The entire file is available 
        in <xref linkend="miscFileSrc.mpi_files.MPIRemote-descriptor.xml" />.
</para>
			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold">File Transfer: </emphasis> specify all the files which
 have to be transferred on the remote host like <emphasis role="bold">binary code</emphasis> and <emphasis role="bold">input data</emphasis>. 
In the following example, <emphasis role="bold">jacobi</emphasis> is the binary of the MPI program.
For further details about File Transfer see <xref linkend="FileTransfer_html_intro" />.
				</para>
					<screen>&lt;componentDefinition&gt;
   &lt;virtualNodesDefinition&gt;
    &lt;virtualNode name="<emphasis role="bold">JACOBIVN</emphasis>" /&gt;
   &lt;/virtualNodesDefinition&gt;
  &lt;/componentDefinition&gt;
  &lt;deployment&gt;
   ...
  &lt;/deployment&gt;
  &lt;fileTransferDefinitions&gt;
   &lt;fileTransfer id="<emphasis role="bold">jacobiCodeTransfer</emphasis>"&gt;
    &lt;file src="jacobi" dest="jacobi" /&gt;
   &lt;/fileTransfer&gt;
  &lt;/fileTransferDefinitions&gt;
</screen>
				</listitem>
				<listitem>
					<para>
						<emphasis role="bold">Resource allocation:</emphasis> define processes for resources reservation.
 Of course the processes name in the creation part must point at an existing defined process in the infrastructure part.
 See section <emphasis role="bold">11.7. Infrastructure and processes (part III)</emphasis> for more details on processes.
				</para>
					<para>
						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold">SSHProcess:</emphasis>
first define the process used to join the remote host on which resources will be reserved. Link the reference ID
 of the file transfer with the FileTransfer previously defined and link the
 reference ID to the DependentProcessSequence process explained below.</para>

								<screen>&lt;processDefinition id="sshProcess"&gt;
   &lt;sshProcess class="org.objectweb.proactive.core.process.ssh.SSHProcess" hostname="nef.inria.fr"
		 username="user"&gt;
    &lt;processReference refid="<emphasis role="bold">jacobiDependentProcess</emphasis>"  /&gt;
	&lt;fileTransferDeploy refid="<emphasis role="bold">jacobiCodeTransfer</emphasis>"&gt;
	  &lt;copyProtocol&gt;scp&lt;/copyProtocol&gt;
	   &lt;sourceInfo prefix=<emphasis role="bold">"/user/user/home/ProActive/src/org/objectweb/proactive/examples/mpi"</emphasis> /&gt;
	   &lt;destinationInfo prefix=<emphasis role="bold">"/home/user/MyApp"</emphasis> /&gt;
	&lt;/fileTransferDeploy&gt;
   &lt;/sshProcess&gt;
  &lt;/processDefinition&gt;
</screen>
							</listitem>
							<listitem>
								<para>
									<emphasis role="bold">DependentProcessSequence:</emphasis>
This process is used when a process is dependent on an another process.
The first process of the list can be any process of the infrastructure of processes in ProActive, but the second has to 
be imperatively a <emphasis role="bold">DependentProcess</emphasis>, that is to implement the <emphasis role="bold">org.objectweb.proactive.core.process.DependentProcess</emphasis> interface.
The following lines express that the mpiProcess is dependent on the resources allocated by the pbsProcess.
				</para>
								<screen>
&lt;processDefinition id=<emphasis role="bold">"jacobiDependentProcess"</emphasis>&gt;
   &lt;<emphasis role="bold">dependentProcessSequence</emphasis> class='<emphasis role="bold">org.objectweb.proactive.core.process.DependentListProcess</emphasis>"&gt;
	&lt;processReference refid=<emphasis role="bold">"jacobiPBSProcess"</emphasis> /&gt;
	&lt;processReference refid=<emphasis role="bold">"jacobiMPIProcess"</emphasis> /&gt;
   &lt;<emphasis role="bold">/dependentProcessSequence</emphasis>&gt;
  &lt;/processDefinition&gt;
</screen>
							</listitem>
							<listitem>
								<para>
									<emphasis role="bold">PBS Process:</emphasis>
 note that you can use any services defined in ProActive to allocate resources instead of the PBS one.
				</para>
								<screen>
&lt;processDefinition id=<emphasis role="bold">"jacobiPBSProcess"</emphasis>&gt;
  &lt;pbsProcess class="org.objectweb.proactive.core.process.pbs.PBSSubProcess"&gt;
	&lt;processReference refid="jvmProcess" /&gt;
	&lt;commandPath value="/opt/torque/bin/qsub" /&gt;
	&lt;pbsOption&gt;
	 &lt;hostsNumber&gt;16&lt;/hostsNumber&gt;
	 &lt;processorPerNode&gt;1&lt;/processorPerNode&gt;
	 &lt;bookingDuration&gt;00:02:00&lt;/bookingDuration&gt;
	 &lt;scriptPath&gt;
	  &lt;absolutePath value="/home/smariani/pbsStartRuntime.sh" /&gt;
	 &lt;/scriptPath&gt;
	&lt;/pbsOption&gt;
  &lt;/pbsProcess&gt;
 &lt;/processDefinition&gt;
</screen>
							</listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis role="bold">MPI process: </emphasis> define the MPI process and its attributes. 
It is possible to pass a command option to mpirun by filling the attribute <emphasis role="bold">mpiCommandOptions</emphasis>.
Specify the number of hosts you wish the application to be deployed on, and at least the MPI code local path.
The local path is the path from which you start the application.
In the case of remote application, if the remote path field is not set, the host file will not be sent to remote host
and MPI process will raise an error.

				</para>
					<screen>&lt;processDefinition id=<emphasis role="bold">"jacobiMPIProcess"</emphasis>&gt;
 &lt;<emphasis role="bold">mpiProcess</emphasis> class="<emphasis role="bold">org.objectweb.proactive.core.process.mpi.MPIDependentProcess</emphasis>" mpiFileName="<emphasis role="bold">jacobi</emphasis>"
	mpiCommandOptions="input_file.dat output_file.dat"&gt;
  &lt;commandPath value="/usr/src/redhat/BUILD/mpich-1.2.6/bin/mpirun" /&gt;
  &lt;mpiOptions&gt;
   &lt;processNumber&gt;<emphasis role="bold">16</emphasis>&lt;/processNumber&gt;
   &lt;localRelativePath&gt;
    &lt;relativePath origin="user.home" value=<emphasis role="bold">"/ProActive/scripts/unix"</emphasis> /&gt;
   &lt;/localRelativePath&gt;
   &lt;remoteAbsolutePath&gt;
    &lt;absolutePath value=<emphasis role="bold">"/home/smariani/MyApp"</emphasis> /&gt;
   &lt;/remoteAbsolutePath&gt;
  &lt;/mpiOptions&gt;
 &lt;<emphasis role="bold">/mpiProcess</emphasis>&gt;
&lt;/processDefinition&gt;</screen>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<!-- ///// Usage example with several codes \\\\ -->
			<title>
			Example with several codes</title>

Let's assume we want to interconnect together several modules (VibroToAcous, AcousToVibro, Vibro, Acous, CheckConvergency) which are each one a parallel MPI binary code. 
	
	<programlisting language="java">
import org.objectweb.proactive.ProActive;
import org.objectweb.proactive.core.ProActiveException;
import org.objectweb.proactive.core.config.ProActiveConfiguration;
import org.objectweb.proactive.core.descriptor.data.ProActiveDescriptor;
import org.objectweb.proactive.core.descriptor.data.VirtualNode;

...
// load the file desciptor 
ProActiveDescriptor pad = ProActive.getProactiveDescriptor('file:descriptor.xml');

// get the Virtual Nodes which references all the MPI code we want to use
VirtualNode VibToAc = pad.getVirtualNode("VibToAc");
VirtualNode AcToVib = pad.getVirtualNode("AcToVib");
VirtualNode Vibro = pad.getVirtualNode("Vibro");
VirtualNode Acous = pad.getVirtualNode("Acous");
VirtualNode CheckConvergency = pad.getVirtualNode("CheckConvergency");

// it's not necessary to activate manually each Virtual Node because it's done
// when creating the MPISpmd object with the Virtual Node

// create MPISpmd objects from Virtual Nodes
MPISpmd vibToAc = MPI.newMPISpmd(VibToAc);
MPISpmd acToVib = MPI.newMPISpmd(AcToVib);
MPISpmd vibro = MPI.newMPISpmd(Vibro);
MPISpmd acous = MPI.newMPISpmd(Acous);

// create two different MPISpmd objects from a <emphasis role="bold"> same Virtual Node </emphasis>
MPISpmd checkVibro = MPI.newMPISpmd(<emphasis role="bold">CheckConvergency</emphasis>);
MPISpmd checkAcous = MPI.newMPISpmd(<emphasis role="bold">CheckConvergency</emphasis>);

 // create MPIResult object for each MPISpmd object
MPIResult vibToAcRes, acToVibRes, vibroRes, acousRes, checkVibroRes, checkAcousRes;

boolean convergence = false;
boolean firstLoop = true;

While (!convergence)
{
	//  trigger execution of vibToAc and acToVib MPISpmd object
	if (firstLoop){
		vibToAcRes = vibToAc.<emphasis role="bold">startMPI();</emphasis>
		acToVibRes = acToVib.<emphasis role="bold">startMPI();</emphasis>
	}else{
		vibToAcRes = vibToAc.<emphasis role="bold">reStartMPI();</emphasis>
		acToVibRes = acToVib.<emphasis role="bold">reStartMPI();</emphasis>
	}
	
	// good termination?
	if (( vibToACRes.<emphasis role="bold">getReturnValue()</emphasis> &lt; 0 ) || ( acToVibRes.<emphasis role="bold">getReturnValue()</emphasis> &lt; 0 ))
		System.exit(-1);
   
	//  trigger execution of vibro and acous MPISpmd object
	if (firstLoop){
		vibroRes = vibro.<emphasis role="bold">startMPI();</emphasis>
		acousRes = acous.<emphasis role="bold">startMPI();</emphasis>
	}else{
		vibroRes = vibro.<emphasis role="bold">reStartMPI();</emphasis>
		acousRes = acous.<emphasis role="bold">reStartMPI();</emphasis>
	}

	
	// good termination?
	if (( vibroRes.<emphasis role="bold">getReturnValue()</emphasis> &lt; 0 ) || ( acousRes.<emphasis role="bold">getReturnValue()</emphasis> &lt; 0 ))
		System.exit(-1);
	
		
	// Check convergency of acoustic part and structure part
	if (firstLoop){
		// modify argument  
		checkVibro.<emphasis role="bold">setCommandArguments("oldVibro.res newVibro.res");</emphasis>
		checkAcous.<emphasis role="bold">setCommandArguments("oldAcous.res newAcous.res");</emphasis>
		checkVibroRes = checkVibro.<emphasis role="bold">startMPI();</emphasis>
		checkAcousRes = checkAcous.<emphasis role="bold">startMPI();</emphasis>
	}else{
		checkVibroRes = checkVibro.<emphasis role="bold">reStartMPI();</emphasis>
		checkAcousRes = checkAcous.<emphasis role="bold">reStartMPI();</emphasis>
	}

	
	// Convergency?
	if (( checkVibroRes.<emphasis role="bold">getReturnValue()</emphasis> == 0 ) || ( checkAcousRes.<emphasis role="bold">getReturnValue() </emphasis>== 0 ))
	{
		convergence = true;
	}
	firstLoop = false;
}

	
// free resources
VibToAc.killAll(false);
AcToVib.killAll(false);
Vibro.killAll(false);
Acous.killAll(false);
CheckConvergency.killAll(false);

				</programlisting>
		</sect2>
	</sect1>

	

	<!-- ////////////////////////////////// DESIGN AND IMPLEMENTATION  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ -->

	<sect1>
		<title>
			Design and Implementation</title>


		<sect2>
			<title>
				Simple wrapping</title>

			<sect3>
				<title>
					Structural Design</title>

				<para>
					<figure>
						<title> Proxy Pattern</title>
						<mediaobject>
							<imageobject>
								<imagedata fileref="mpi_files/Design.png" format="PNG" width="6in" />
							</imageobject>
						</mediaobject>
					</figure>

				</para>


				<itemizedlist>
					<listitem>
						<para>
						The proxy has the role of a smart reference that performs additional actions 
						when the MPISpmdImpl Active Object is accessed. Especially the proxy forwards requests to the Active Object if the current
status of this Active Object is in an appropriate state, otherwise an IllegalMPIStateException is thrown.
						</para>

					</listitem>
				</itemizedlist>
			</sect3>
			<sect3>
				<title>
					Infrastructure of processes</title>
				<para>
					<figure>
						<title> Process Package Architecture</title>
						<mediaobject>
							<imageobject>
								<imagedata fileref="mpi_files/architecture.png" format="PNG" width="6in" />
							</imageobject>
						</mediaobject>
					</figure>

				</para>

				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">DependentListProcess and IndependentListProcess (left part on the picture)</emphasis>
						</para>
						<para>The <emphasis role="bold">SequentialListProcess </emphasis>relative classes are defined in the <emphasis role="bold">org.objectweb.proactive.core.process</emphasis> package.
The two classes share the same caracteristics: 
both contain a <emphasis role="bold">list of processes which have to be executed sequentially</emphasis>.
This dependent constraint has been integrated in order to satisfy the MPI process requirement. Indeed, the DependentListProcess class specifies
a list of processes which have to extend the <emphasis role="bold">DependentProcess interface</emphasis>, unless the header process which is a simple allocation resources process.
It provides user to be sure that the dependent process will be executed if and only if this dependent process gets back parameters from which it is 
dependent.
 			</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">MPIDependentProcess (right part on the picture)</emphasis>
						</para>
						<para> The <emphasis role="bold">MPI</emphasis> relative classes are defined in the <emphasis role="bold">org.objectweb.proactive.core.process.mpi</emphasis> package.
MPI process preliminary requires a list of hosts for job execution. 
Thus, this process has to implement the <emphasis role="bold">Dependent Process</emphasis> interface.
See section <emphasis role="bold">11.7. Infrastructure and processes (part III)</emphasis> for more details on processes.
 			</para>
					</listitem>

				</itemizedlist>


			</sect3>

		</sect2>
	</sect1>


</chapter>