<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<chapter id="WrappingMpiAndLegacyCode">
	<title>Wrapping MPI and Legacy code</title>

	<sect1 >
		<title>
			Simple wrapping - Overview</title>

		<para>The <emphasis role="bold">Message Passing Interface (MPI)</emphasis> is a widely adopted communication 
library for parallel and distributed computing. This work has been designed to make it easier to wrap and deploy MPI legacy code, especially on the Grid.</para>

		<para>The <emphasis role="bold">simple wrapping</emphasis> allows an MPI cluster application to be embedded 
within ProActive with a view to write application in a problem-solving environment. It permits users to develop 
conventional stand-alone Java applications that use a <emphasis role="bold">native MPI application</emphasis> on 
cluster systems or desktop Grids. Primary objective is <emphasis role="bold">to ease the deployment of coupled application</emphasis> on several clusters.
This document exposes a simple wrapping architecture designed to <emphasis role="bold">automatically deploy MPI applications</emphasis> on a cluster through the use of deployment descriptor.</para>

		<para>This work can also <emphasis role="bold">be combined with the ProActive Fractal component 
model</emphasis> in order to write application as component tasks.
The idea is to encapsulate simulation codes into components and let 
them communicate through ProActive. In fact, ProActive provides a communication layer 
so that components can be distributed on different computing resources within a 
Computational Grid. </para>
		<para>
			<emphasis role="bold">However</emphasis> the simple wrapping method 
do not let SPMD processes associated with one code communicate with the SPMD 
processors associated with another simulation code. We are currently studying this 
last point in the <emphasis role="bold">interacting wrapping context</emphasis>.</para>


		<para> The API is organized in the package <emphasis role="bold">org.objectweb.proactive.mpi</emphasis>, with the class
<emphasis role="bold">org.objectweb.proactive.mpi.MPI</emphasis> gathering static methods and the class <emphasis role="bold">org.objectweb.proactive.mpi.MPISpmd</emphasis> for which,
instances represent and allow to control a given deployed MPI code.</para>

	</sect1>

	<sect1 >
		<title>
			Simple Wrapping - Infrastructure Model</title>

		<para>This work is mainly intended to deploy automatically and transparently 
MPI parallel applications on cluster. Transparency means that deployer
does not know what particular resources provides computer power. So the user should just have to finalize the deployment 
descriptor file and get back the result of the application without worrying about resources
selection, resource location and type, or mapping process on resources.
	</para>

		<para>
			<figure>
				<title>File transfer and asking for resources</title>
				<mediaobject>
					<imageobject>
						<imagedata fileref="mpi_files/deployment.png" format="PNG" width="6in" />
					</imageobject>
				</mediaobject>
			</figure>
		</para>
		<para>
			<emphasis role="bold">The deployment can include the following steps: </emphasis>
		</para>
		<itemizedlist>

			<listitem>
				<para>
					<emphasis role="bold">(1) File Transfer</emphasis>
				</para>

				<para>Primary objective is to provide user an automatic deployment of his application 
through a file deployment descriptor. In fact, ProActive provides support for File Transfer. In this way, user can
transfer MPI application <emphasis role="bold">input data</emphasis> and/or MPI <emphasis role="bold">application code</emphasis> to the remote host. The File Transfer happens before the user launches his application.
For more details about File Transfer see  <xref linkend="FileTransfer_html_intro"/>.
		</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">(2) Asking for resources</emphasis>
				</para>
				<para>User describes MPI job requirements in the file deployment descriptor using a Virtual Node.
He gets back a set of Nodes corresponding to the remote available hosts for the MPI Job execution.
For more details (or usage example) about resources booking, have a look to section: <emphasis role="bold">"27.4 Using the Simple Wrapping Infrastructure" </emphasis>.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">(3) Control MPI process using the MPI API</emphasis>
				</para>
				<para>After deployment, user obtains the Virtual Node containing resources required for the MPI job, that is a set of Nodes.
The MPI API provides user with the ability to create an <emphasis role="bold">MPISpmd object</emphasis> from the Virtual Node obtained. 
To this end the programmer is able to control the MPI program, that is: trigger the job execution, kill the job, synchronize the job, get the object status/result etc..).
This API is detailed in the next chapter.
 			</para>
			</listitem>
		</itemizedlist>

	</sect1>
	<sect1 >
		<title>
			MPI Wrapping API</title>


		<sect2 >
			<title>
				Simple wrapping</title>

			<sect3 >
				<title>
					MPI API Definition</title>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">What is an MPISpmd object ?</emphasis>
						</para>
						<para>
An MPISpmd object is regarded as an MPI code wrapper. It has the following features : </para>
						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold">It holds a state</emphasis> (which can take different status)
								</para>
							</listitem>
							<listitem>
								<para>
									<emphasis role="bold">It can be controlled through an API</emphasis> (presented in next section)
								</para>
							</listitem>
						</itemizedlist>

					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">MPISpmd object creation methods</emphasis>
						</para>
						<screen>import org.objectweb.proactive.mpi;

/**
 * creates an <emphasis role="bold">MPISpmd object</emphasis> from a Virtual Node which represents the deployment of an MPI code. 
 */

static public MPISpmd <emphasis role="bold">MPI.newMPISpmd</emphasis>(VirtualNode virtualNode);
</screen>

					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">MPISpmd object control methods</emphasis>
						</para>
						<screen>
/**
 * Triggers the process execution represented by the MPISpmd object on the resources previously allocated. This
 * method call is reified as an asynchronous request, thus the call does not lock until the reply is received.
 * The method immediately returns a future object, especially a <emphasis role="bold">future on an MPIResult object</emphasis>.
 * As a consequence, the application can go on with executing its code, as long as it doesn't need to invoke methods 
 * on this MPIResult returned object, in which case the calling thread is automatically blocked if the result of the 
 * method invocation is not yet available.
 */

public <emphasis role="bold">MPIResult startMPI</emphasis>();</screen>


						<screen>
/**
 * Restarts the process represented by the MPISpmd object on the same resources. This process has to previously
 * been started once with the start method, otherwise the method throws an <emphasis role="bold">IllegalMPIStateException</emphasis>.
 * It's also an asynchronous method and returns a future on an MPIResult object.
 */

public <emphasis role="bold">MPIResult reStartMPI</emphasis>();</screen>

						<screen>
/** 
 * Stops the process represented by the MPISpmd object. 
 * It returns true if the process was running when it has been killed, false otherwise.
 */						

public boolean <emphasis role="bold">killMPI</emphasis>();</screen>

						<screen>
/**
 * Returns the current status of the MPISpmd object. The different status are listed in the next item.
 */

public String <emphasis role="bold">getStatus</emphasis>();</screen>

						<screen>
/**
 * Add or modify the MPI command parameters. It allows user to specify arguments to the MPI code.
 */

public String <emphasis role="bold">setCommandArguments</emphasis>(String arguments);</screen>

					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">MPIResult object </emphasis>
						</para>
						<para> An MPIResult object is obtained with the startMPI/reStartMPI methods call. Rather, these methods return
 a future on an MPIResult object that not locks application as long as no method is called on this MPIResult object.
In contrary case, application is blocked until the MPIResult object is updated and so available.
The following method get the exit value of the MPI program.</para>
						<screen>
/**
 * Returns the exit value of the MPI program. 
 * By usual convention, the value 0 indicates normal termination.
 */

public int <emphasis role="bold">getReturnValue</emphasis>();</screen>

					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">MPISpmd object status</emphasis>
						</para>

						<screen>import org.objectweb.proactive.mpi;

<emphasis role="bold">MPIConstants.MPI_UNSTARTED</emphasis>; // default status - after MPISpmd object creation
<emphasis role="bold">MPIConstants.MPI_RUNNING</emphasis>;   // after MPISpmd object has been started or restarted
<emphasis role="bold">MPIConstants.MPI_KILLED</emphasis>;    // after MPISpmd object has been killed
<emphasis role="bold">MPIConstants.MPI_FINISHED</emphasis>;  // after MPISpmd object has finished</screen>
						<para> Each status defines the current state of the MPISpmd object.
 It provides the guarantee of application consistency and a better control of the application
 in case of multiple MPISpmd objects.</para>

					</listitem>
				</itemizedlist>
			</sect3>
			<sect3 >
				<title>
					Using the API</title>


				<para>

					<figure>
						<title>State transition diagram</title>
						<mediaobject>
							<imageobject>
								<imagedata fileref="mpi_files/status.png" format="PNG" width="6in" />
							</imageobject>
						</mediaobject>
					</figure>
				</para>
				<para>
					<emphasis role="bold">How to write application with the API? </emphasis>
				</para>
				<para> Import the package <emphasis role="bold">org.objectweb.proactive.mpi</emphasis>. In an attempt to keep application consistency, the MPISpmd object makes use of status.
It garantees that either the method call on object is coherent or an exception is thrown. 
Especially the exception is an <emphasis role="bold">IllegalMPIStateException</emphasis> that signals that a method has been called at an illegal or inappropriate time.
In other words, application is not in an appropriate state for the requested operation.</para>
				<para>
Application does not require to declare in its throws clause because IllegalMPIStateException is a subclasse of RuntimeException.
The graph above presents a kind of finite state machine or finite automaton, that is a model of behavior composed of<emphasis role="bold"> states</emphasis> (status of the MPISpmd object) and 
<emphasis role="bold">transition actions</emphasis> (methods of the API). Once the MPISpmd object is created, the object enters in the initial state: <emphasis role="bold">MPIConstants.MPI_UNSTARTED</emphasis>.
</para>


				<para>
					<emphasis role="bold">Sample of code: </emphasis> 
These few lines show how to execute an MPI job and get its return value once finished. 

				</para>
				<screen>
					<emphasis role="bold">import org.objectweb.proactive.mpi.*;</emphasis>

...
// load the file desciptor 
ProActiveDescriptor pad = ProActive.getProactiveDescriptor('file:descriptor.xml');

// get the Virtual Node which references the MPI code you want to execute
VirtualNode vnCpi = pad.getVirtualNode('CPI');

// activate Virtual Node (it's not mandatory because the MPI.newMPISpmd method does
// it automatically if it has not been already done)
vnCpi.activate();

// create the MPISpmd object with the Virtual Node
<emphasis role="bold">MPISpmd</emphasis> my_spmd = <emphasis role="bold">MPI.newMPISpmd(vnCpi);</emphasis>

// trigger MPI code execution and get future on MPIResult
<emphasis role="bold">MPIResult</emphasis> my_result = my_spmd.<emphasis role="bold">startMPI();</emphasis>

// print current status
logger.info("Current status: "+my_spmd.<emphasis role="bold">getStatus()</emphasis>);


// get return value (block the thread until the my_result is available)
logger.info("Return value: "+my_result.<emphasis role="bold">getReturnValue()</emphasis>);

// print the MPISpmd object caracteristics (name, current status, processes number ...)
logger.info(<emphasis role="bold">my_spmd</emphasis>);

...

				</screen>
			</sect3>
		</sect2>
	</sect1>


	<sect1 >
		<title>
			Using the Simple Wrapping Infrastructure</title>
		<para>
	 Resources booking is specified using ProActive Descriptors.
	We explain the operation with the example included in the release. The entire file is available 
        in <xref linkend="miscFileSrc.mpi_files.MPIRemote-descriptor.xml"/>.
</para>
		<itemizedlist>
			<listitem>
				<para>
					<emphasis role="bold">File Transfer: </emphasis> specify all the files which
 have to be transferred on the remote host like <emphasis role="bold">binary code</emphasis> and <emphasis role="bold">input data</emphasis>. 
In the following example, "cpi" is the binary of the MPI program.
For more details about File Transfer see <xref linkend="FileTransfer_html_intro"/>.
				</para>
				<screen>&lt;componentDefinition&gt;
   &lt;virtualNodesDefinition&gt;
    &lt;virtualNode name="CPI" /&gt;
   &lt;/virtualNodesDefinition&gt;
  &lt;/componentDefinition&gt;
  &lt;deployment&gt;
   ...
  &lt;/deployment&gt;
  &lt;FileTransferDefinitions&gt;
   &lt;FileTransfer id="<emphasis role="bold">mpiCodeTransfer</emphasis>"&gt;
    &lt;file src="cpi" dest="cpi" /&gt;
   &lt;/FileTransfer&gt;
  &lt;/FileTransferDefinitions&gt;
</screen>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">Resource allocation:</emphasis> define processes for resources reservation.
 Of course the processes name in the creation part must point at an existing defined process in the infrastructure part.
 See section <emphasis role="bold">11.7. Infrastructure and processes (part III)</emphasis> for more details on processes.
				</para>
				<para>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis role="bold">SSHProcess:</emphasis>
first define the process used to join the remote host on which resources will be reserved. Link the reference id
 of the file transfer with the FileTransfer previously defined and link the
 reference id to the DependentProcessSequence process explained below.</para>

							<screen>&lt;processDefinition id="sshProcess"&gt;
   &lt;sshProcess class="org.objectweb.proactive.core.process.ssh.SSHProcess" hostname="nef.inria.fr"
		 username="user"&gt;
    &lt;processReference refid="<emphasis role="bold">dependentProcessCPI</emphasis>"  /&gt;
	&lt;FileTransferDeploy refid="<emphasis role="bold">mpiCodeTransfer</emphasis>"&gt;
	  &lt;copyProtocol&gt;scp&lt;/copyProtocol&gt;
	   &lt;sourceInfo prefix=<emphasis role="bold">"/user/user/home/ProActive/src/org/objectweb/proactive/examples/mpi"</emphasis> /&gt;
	   &lt;destinationInfo prefix=<emphasis role="bold">"/home/user/MyApp"</emphasis> /&gt;
	&lt;/FileTransferDeploy&gt;
   &lt;/sshProcess&gt;
  &lt;/processDefinition&gt;
</screen>
						</listitem>
						<listitem>
							<para>
								<emphasis role="bold">DependentProcessSequence:</emphasis>
This process is used when a process is dependent on an another process.
The first process of the list can be any process of the infrastructure of processes in ProActive, but the second has to 
be imperatively a <emphasis role="bold">DependentProcess</emphasis>, that is to implement the <emphasis role="bold">org.objectweb.proactive.core.process.DependentProcess</emphasis> interface.
The following lines express that the mpiProcess is dependent on the resources allocated by the pbsProcess.
				</para>
							<screen>
&lt;processDefinition id=<emphasis role="bold">"dependentProcessCPI"</emphasis>&gt;
   &lt;<emphasis role="bold">dependentProcessSequence</emphasis> class='<emphasis role="bold">org.objectweb.proactive.core.process.DependentListProcess</emphasis>"&gt;
	&lt;processReference refid=<emphasis role="bold">"pbsProcess"</emphasis> /&gt;
	&lt;processReference refid=<emphasis role="bold">"mpiProcess"</emphasis> /&gt;
   &lt;<emphasis role="bold">/dependentProcessSequence</emphasis>&gt;
  &lt;/processDefinition&gt;
</screen>
						</listitem>
						<listitem>
							<para>
								<emphasis role="bold">PBS Process:</emphasis>
 note that you can use any services defined in ProActive to allocate resources instead of the PBS one.
				</para>
							<screen>
&lt;processDefinition id=<emphasis role="bold">"pbsProcess"</emphasis>&gt;
  &lt;pbsProcess class="org.objectweb.proactive.core.process.pbs.PBSSubProcess"&gt;
	&lt;processReference refid="jvmProcess" /&gt;
	&lt;commandPath value="/opt/torque/bin/qsub" /&gt;
	&lt;pbsOption&gt;
	 &lt;hostsNumber&gt;16&lt;/hostsNumber&gt;
	 &lt;processorPerNode&gt;1&lt;/processorPerNode&gt;
	 &lt;bookingDuration&gt;00:02:00&lt;/bookingDuration&gt;
	 &lt;scriptPath&gt;
	  &lt;absolutePath value="/home/smariani/pbsStartRuntime.sh" /&gt;
	 &lt;/scriptPath&gt;
	&lt;/pbsOption&gt;
  &lt;/pbsProcess&gt;
 &lt;/processDefinition&gt;
</screen>
						</listitem>
					</itemizedlist>
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">MPI process: </emphasis> define the MPI process and its attributes. 
It is possible to pass a command option to mpirun by filling the attribute <emphasis role="bold">mpiCommandOptions</emphasis>.
Specify hosts number you whish the application to be deployed and at least the MPI code local path.
The local path is the path from which you start the application.
In the case of remote application, if the remote path field is not set, the host file will not be sent to remote host
and MPI process will raise an error.

				</para>
				<screen>&lt;processDefinition id=<emphasis role="bold">"mpiProcess"</emphasis>&gt;
 &lt;<emphasis role="bold">mpiProcess</emphasis> class="<emphasis role="bold">org.objectweb.proactive.core.process.mpi.MPIDependentProcess</emphasis>" mpiFileName="cpi"
	mpiCommandOptions="input_file.dat output_file.dat"&gt;
  &lt;commandPath value="/usr/src/redhat/BUILD/mpich-1.2.6/bin/mpirun" /&gt;
  &lt;mpiOptions&gt;
   &lt;processNumber&gt;<emphasis role="bold">16</emphasis>&lt;/processNumber&gt;
   &lt;localRelativePath&gt;
    &lt;relativePath origin="user.home" value=<emphasis role="bold">"/ProActive/scripts/unix"</emphasis> /&gt;
   &lt;/localRelativePath&gt;
   &lt;remoteAbsolutePath&gt;
    &lt;absolutePath value=<emphasis role="bold">"/home/smariani/MyApp"</emphasis> /&gt;
   &lt;/remoteAbsolutePath&gt;
  &lt;/mpiOptions&gt;
 &lt;<emphasis role="bold">/mpiProcess</emphasis>&gt;
&lt;/processDefinition&gt;</screen>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 >
		<title>
			Usage example with several codes</title>
		<para>
			Let's assume we want to interconnect together several modules 
			(VibroToAcous, AcousToVibro, Vibro, Acous, CheckConvergency) which are each one a parallel MPI code. 
		</para>

	<screen>
import org.objectweb.proactive.ProActive;
import org.objectweb.proactive.core.ProActiveException;
import org.objectweb.proactive.core.config.ProActiveConfiguration;
import org.objectweb.proactive.core.descriptor.data.ProActiveDescriptor;
import org.objectweb.proactive.core.descriptor.data.VirtualNode;

...
// load the file desciptor 
ProActiveDescriptor pad = ProActive.getProactiveDescriptor('file:descriptor.xml');

// get the Virtual Nodes which references all the MPI code we want to use
VirtualNode VibToAc = pad.getVirtualNode("VibToAc");
VirtualNode AcToVib = pad.getVirtualNode("AcToVib");
VirtualNode Vibro = pad.getVirtualNode("Vibro");
VirtualNode Acous = pad.getVirtualNode("Acous");
VirtualNode CheckConvergency = pad.getVirtualNode("CheckConvergency");

// it's not necessary to activate manually each Virtual Node because it's done
// when creating the MPISpmd object with the Virtual Node

// create MPISpmd objects from Virtual Nodes
MPISpmd vibToAc = MPI.newMPISpmd(VibToAc);
MPISpmd acToVib = MPI.newMPISpmd(AcToVib);
MPISpmd vibro = MPI.newMPISpmd(Vibro);
MPISpmd acous = MPI.newMPISpmd(Acous);

// create two different MPISpmd objects from a <emphasis role="bold"> same Virtual Node </emphasis>
MPISpmd checkVibro = MPI.newMPISpmd(<emphasis role="bold">CheckConvergency);</emphasis>
MPISpmd checkAcous = MPI.newMPISpmd(<emphasis role="bold">CheckConvergency);</emphasis>

 // create MPIResult object for each MPISpmd object
MPIResult vibToAcRes, acToVibRes, vibroRes, acousRes, checkVibroRes, checkAcousRes;

boolean convergence = false;
boolean firstLoop = true;

While (!convergence)
{
	//  trigger execution of vibToAc and acToVib MPISpmd object
	if (firstLoop){
		vibToAcRes = vibToAc.<emphasis role="bold">startMPI();</emphasis>
		acToVibRes = acToVib.<emphasis role="bold">startMPI();</emphasis>
	}else{
		vibToAcRes = vibToAc.<emphasis role="bold">reStartMPI();</emphasis>
		acToVibRes = acToVib.<emphasis role="bold">reStartMPI();</emphasis>
	}
	
	// good termination?
	if (( vibToACRes.<emphasis role="bold">getReturnValue()</emphasis> &lt; 0 ) || ( acToVibRes.<emphasis role="bold">getReturnValue()</emphasis> &lt; 0 ))
		System.exit(-1);
   
	//  trigger execution of vibro and acous MPISpmd object
	if (firstLoop){
		vibroRes = vibro.<emphasis role="bold">startMPI();</emphasis>
		acousRes = acous.<emphasis role="bold">startMPI();</emphasis>
	}else{
		vibroRes = vibro.<emphasis role="bold">reStartMPI();</emphasis>
		acousRes = acous.<emphasis role="bold">reStartMPI();</emphasis>
	}

	
	// good termination?
	if (( vibroRes.<emphasis role="bold">getReturnValue()</emphasis> &lt; 0 ) || ( acousRes.<emphasis role="bold">getReturnValue()</emphasis> &lt; 0 ))
		System.exit(-1);
	
		
	// Check convergency of acoustic part and structure part
	if (firstLoop){
		// modify argument  
		checkVibro.<emphasis role="bold">setCommandArguments("oldVibro.res newVibro.res");</emphasis>
		checkAcous.<emphasis role="bold">setCommandArguments("oldAcous.res newAcous.res");</emphasis>
		checkVibroRes = checkVibro.<emphasis role="bold">startMPI();</emphasis>
		checkAcousRes = checkAcous.<emphasis role="bold">startMPI();</emphasis>
	}else{
		checkVibroRes = checkVibro.<emphasis role="bold">reStartMPI();</emphasis>
		checkAcousRes = checkAcous.<emphasis role="bold">reStartMPI();</emphasis>
	}

	
	// Convergency?
	if (( checkVibroRes.<emphasis role="bold">getReturnValue()</emphasis> == 0 ) || ( checkAcousRes.<emphasis role="bold">getReturnValue() </emphasis>== 0 ))
	{
		convergence = true;
	}
	firstLoop = false;
}

	
// free resources
VibToAc.killAll(false);
AcToVib.killAll(false);
Vibro.killAll(false);
Acous.killAll(false);
CheckConvergency.killAll(false);

				</screen>

			</sect1>

	<sect1 >
		<title>
			Design and Implementation</title>


		<sect2 >
			<title>
				Simple wrapping</title>

			<sect3 >
				<title>
					Structural Design</title>

				<para>
					<figure>
						<title> Proxy Pattern</title>
						<mediaobject>
							<imageobject>
								<imagedata fileref="mpi_files/Design.png" format="PNG" width="6in" />
							</imageobject>
						</mediaobject>
					</figure>

				</para>


				<itemizedlist>
					<listitem><para>
						The proxy has the role of a smart reference that performs additional actions 
						when the MPISpmdImpl Active Object is accessed. Especially the proxy forwards requests to the Active Object if the current
status of this Active Object is in an appropriate state, otherwise an IllegalMPIStateException is thrown.
						</para>

					</listitem>
				</itemizedlist>
			</sect3>
			<sect3 >
				<title>
					Infrastructure of processes</title>
				<para>
					<figure>
						<title> Process Package Architecture</title>
						<mediaobject>
							<imageobject>
								<imagedata fileref="mpi_files/architecture.png" format="PNG" width="6in" />
							</imageobject>
						</mediaobject>
					</figure>

				</para>

				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">DependentListProcess and IndependentListProcess (left part on the picture)</emphasis>
						</para>
						<para>The <emphasis role="bold">SequentialListProcess </emphasis>relative classes are defined in the <emphasis role="bold">org.objectweb.proactive.core.process</emphasis> package.
The two classes share the same caracteristic: 
both contain a <emphasis role="bold">list of processes which have to be executed sequentially</emphasis>.
This dependent constraint has been integrated in order to satisfy the MPI process requirement. Indeed, the DependentListProcess class specifies
a list of processes which have to extend the <emphasis role="bold">DependentProcess interface</emphasis>, unless the header process which is a simple allocation resources process.
It provides user to be sure that the dependent process will be executed if and only if this dependent process gets back parameters from which it is 
dependent.
 			</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">MPIDependentProcess (right part on the picture)</emphasis>
						</para>
						<para> The <emphasis role="bold">MPI</emphasis> relative classes are defined in the <emphasis role="bold">org.objectweb.proactive.core.process.mpi</emphasis> package.
MPI process preliminary requires a list of hosts for job execution. 
Thus, this process has to implement the <emphasis role="bold">Dependent Process</emphasis> interface.
See section <emphasis role="bold">11.7. Infrastructure and processes (part III)</emphasis> for more details on processes.
 			</para>
					</listitem>

				</itemizedlist>


			</sect3>

		</sect2>
	</sect1>


</chapter>