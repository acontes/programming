/*
 * ################################################################
 *
 * ProActive: The Java(TM) library for Parallel, Distributed,
 *            Concurrent computing with Security and Mobility
 *
 * Copyright (C) 1997-2005 INRIA/University of Nice-Sophia Antipolis
 * Contact: proactive@objectweb.org
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
 * USA
 *
 *  Initial developer(s):               The ProActive Team
 *                        http://www.inria.fr/oasis/ProActive/contacts.html
 *  Contributor(s):
 *
 * ################################################################
 */
package org.objectweb.proactive.core.mop;

import java.io.ByteArrayInputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.util.Iterator;
import java.util.LinkedList;

import org.apache.log4j.Logger;
import org.objectweb.proactive.core.body.UniversalBody;
import org.objectweb.proactive.core.component.request.ComponentRequest;
import org.objectweb.proactive.core.component.request.Shortcut;
import org.objectweb.proactive.core.exceptions.manager.ExceptionHandler;
import org.objectweb.proactive.core.util.ObjectToByteConverter;
import org.objectweb.proactive.core.util.log.Loggers;
import org.objectweb.proactive.core.util.log.ProActiveLogger;

import sun.rmi.server.MarshalInputStream;


/**
 * Instances of this class represent method calls performed on reified
 * objects. They are generated by a <I>stub object</I>, whose role is to act
 * as a representative for the reified object.
 *
 * @author Julien Vayssi&egrave;re
 */
public class MethodCall implements java.io.Serializable, Cloneable {
    // COMPONENTS added a field for the Fractal interface name 
    // (the name of the interface containing the method called)
    private String componentInterfaceName = null;
    private boolean isComponentMethodCall;
    protected static Logger componentLogger = null;

    // shortcuts have to be put in the method call, as only the method call is transferred 
    // when crossing membranesof composite components
    protected Shortcut shortcut = null;
    protected short priority; // non functional component requests priority

    //
    // --- STATIC MEMBERS -----------------------------------------------------------------------
    //

    /**
     * The hashtable that caches Method/isAsynchronousCall
     * This dramatically improves performances, since we do not have to call
     * isAsynchronousCall for every call, but only once for a given method
     */
    private static transient java.util.Hashtable REIF_AND_EXCEP = new java.util.Hashtable();
    static Logger logger = ProActiveLogger.getLogger(Loggers.MOP);

    /**
     *        The size of the pool we use for recycling MethodCall objects.
     */
    private static int RECYCLE_POOL_SIZE = 30;

    /**
     * The pool of recycled methodcall objects
     */
    private static MethodCall[] recyclePool;

    /**
     * Position inside the pool
     */
    private static int index;

    /**        Indicates if the recycling of MethodCall object is on. */
    private static boolean recycleMethodCallObject;
    private static java.util.Hashtable reifiedMethodsTable = new java.util.Hashtable();

    /**
     * Initializes the recycling of MethodCall objects to be enabled by default.
     */
    static {
        MethodCall.setRecycleMethodCallObject(true);
    }

    //
    // --- PRIVATE MEMBERS -----------------------------------------------------------------------
    //

    /**
     * The array holding the arguments of the method call
     */
    private Object[] effectiveArguments;

    /**
     * The list of tags for barrier
     */
    private LinkedList tagsForBarrier = null;

    /**
     * The method corresponding to the call
     */
    private transient Method reifiedMethod;

    /**
     * The internal ID of the methodcall
     */
    private long methodCallID;
    private String key;

    /**
     * Actually only used for exceptions.
     */
    private MethodCallMetadata metadata;

    /**
     * byte[] to store effectiveArguments. Requiered to optimize multiple serialization
     * in some case (such as group communication) or to create a stronger
     * asynchronism (serialization of parameters then return to the thread of
     * execution before the end of the rendez-vous).
     */
    private byte[] serializedEffectiveArguments = null;

    /**
     * transform the effectiveArguments into a byte[]
     * */
    public void transformEffectiveArgumentsIntoByteArray() {
        if ((serializedEffectiveArguments == null) &&
                (effectiveArguments != null)) {
            try {
                //                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
                //
                //                //  ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
                //                MarshalOutputStream objectOutputStream = new MarshalOutputStream(byteArrayOutputStream);
                //                objectOutputStream.writeObject(effectiveArguments);
                //                objectOutputStream.flush();
                //                objectOutputStream.close();
                //                byteArrayOutputStream.close();
                //                serializedEffectiveArguments = byteArrayOutputStream.toByteArray();
                serializedEffectiveArguments = ObjectToByteConverter.convert(effectiveArguments);
            } catch (Exception e) {
                e.printStackTrace();
            }
            effectiveArguments = null;
        }
    }

    /**
     * Sets recycling of MethodCall objects on/off. Note that turning the recycling
     * off and on again results in the recycling pool being flushed, thus damaging
     * performances.
     * @param value        sets the recycling on if <code>true</code>, otherwise turns it off.
     */
    public static synchronized void setRecycleMethodCallObject(boolean value) {
        if (recycleMethodCallObject == value) {
            return;
        } else {
            recycleMethodCallObject = value;
            if (value) {
                // Creates the recycle poll for MethodCall objects
                recyclePool = new MethodCall[RECYCLE_POOL_SIZE];
                index = 0;
            } else {
                // If we do not want to recycle MethodCall objects anymore,
                // let's free some memory by permitting the reyclePool to be
                // garbage-collecting
                recyclePool = null;
            }
        }
    }

    /**
     * Indicates if the recycling of MethodCall objects is currently running or not.
     *
     * @return                        <code>true</code> if recycling is on, <code>false</code> otherwise
     */
    public static synchronized boolean getRecycleMethodCallObject() {
        return MethodCall.recycleMethodCallObject;
    }

    /**
     *        Factory method for getting MethodCall objects
     *
     *        @param reifiedMethod a <code>Method</code> object that represents
     *        the method whose invocation is reified
     *        @param effectiveArguments   the effective arguments of the call. Arguments
     *        that are of primitive type need to be wrapped
     *         within an instance of the corresponding wrapper
     *  class (like <code>java.lang.Integer</code> for
     *  primitive type <code>int</code> for example).
     *        @return        a MethodCall object representing an invocation of method
     *        <code>reifiedMethod</code> with arguments <code>effectiveArguments</code>
     */
    public synchronized static MethodCall getMethodCall(Method reifiedMethod,
        Object[] effectiveArguments, MethodCallMetadata metadata) {
        metadata = MethodCallMetadata.optimize(metadata);

        if (MethodCall.getRecycleMethodCallObject()) {
            // Finds a recycled MethodCall object in the pool, cleans it and
            // eventually returns it
            if (MethodCall.index > 0) {
                // gets the object from the pool
                MethodCall.index--;
                MethodCall result = MethodCall.recyclePool[MethodCall.index];
                MethodCall.recyclePool[MethodCall.index] = null;
                // Refurbishes the object
                result.reifiedMethod = reifiedMethod;
                result.effectiveArguments = effectiveArguments;
                result.key = buildKey(reifiedMethod);
                result.metadata = metadata;
                return result;
            }
        }
        return new MethodCall(reifiedMethod, effectiveArguments, metadata);
    }

    public synchronized static MethodCall getMethodCall(Method reifiedMethod,
        Object[] effectiveArguments) {
        MethodCallMetadata metadata = ExceptionHandler.getMetadataForCall(reifiedMethod);
        return getMethodCall(reifiedMethod, effectiveArguments, metadata);
    }

    /**
     * Returns a MethodCall object with extra info for component calls (the
     * possible name of the functional interface invoked).
     * @param reifiedMethod
     * @param effectiveArguments
     * @param interfaceName fractal interface name
     * @param priority default is to 3 (strict FIFO)
     * @return MethodCall
     */
    public synchronized static MethodCall getComponentMethodCall(
        Method reifiedMethod, Object[] effectiveArguments,
        String interfaceName, short priority) {
        MethodCall mc = getMethodCall(reifiedMethod, effectiveArguments);
        if (MethodCall.componentLogger == null) {
            MethodCall.componentLogger = ProActiveLogger.getLogger(Loggers.COMPONENTS_REQUESTS);
        }
        mc.isComponentMethodCall = true;
        mc.componentInterfaceName = interfaceName;
        mc.priority = priority;
        mc.shortcut = null;
        return mc;
    }

    public synchronized static MethodCall getComponentMethodCall(
        Method reifiedMethod, Object[] effectiveArguments,
        String interfaceName) {
        return MethodCall.getComponentMethodCall(reifiedMethod,
            effectiveArguments, interfaceName,
            ComponentRequest.STRICT_FIFO_PRIORITY);
    }

    /**
     *        Tells the recyclying process that the MethodCall object passed as parameter
     *        is ready for recycling. It is the responsibility of the caller of this
     *        method to make sure that this object can safely be disposed of.
     */
    public synchronized static void setMethodCall(MethodCall mc) {
        if (MethodCall.getRecycleMethodCallObject()) {
            // If there's still one slot left in the pool
            if (MethodCall.recyclePool[MethodCall.index] == null) {
                // Cleans up a MethodCall object
                // It is prefereable to do it here rather than at the moment
                // the object is picked out of the pool, because it allows
                // garbage-collecting the objects referenced in here
                mc.componentInterfaceName = null;
                mc.isComponentMethodCall = false;
                mc.reifiedMethod = null;
                mc.effectiveArguments = null;
                mc.tagsForBarrier = null;
                mc.key = null;
                mc.metadata = null;
                // Inserts the object in the pool
                MethodCall.recyclePool[MethodCall.index] = mc;
                MethodCall.index++;
                if (MethodCall.index == RECYCLE_POOL_SIZE) {
                    MethodCall.index = RECYCLE_POOL_SIZE - 1;
                }
            }
        }
    }

    /**
     * Builds a new MethodCall object.
     * Please, consider use the factory method  <code>getMethodCall</code>
     * instead of build a new MethodCall object.
     */

    // This constructor is private to this class
    // because we want to enforce the use of factory methods for getting fresh
    // instances of this class (see <I>Factory</I> pattern in GoF).
    public MethodCall(Method reifiedMethod, Object[] effectiveArguments,
        MethodCallMetadata metadata) {
        this.reifiedMethod = reifiedMethod;
        this.effectiveArguments = effectiveArguments;
        this.key = buildKey(reifiedMethod);
        this.metadata = MethodCallMetadata.optimize(metadata);
    }

    public MethodCall(Method reifiedMethod, Object[] effectiveArguments) {
        this(reifiedMethod, effectiveArguments, null);
    }

    /**
     * Builds a new MethodCall object. This constructor is a copy constructor.
     * Fields of the object are also copied.
     * Please, consider use the factory method  <code>getMethodCall</code>
     * instead of build a new MethodCall object.
     * @param mc - the MethodCall object to copy
     */
    public MethodCall(MethodCall mc) {
        try {
            this.componentInterfaceName = mc.getComponentInterfaceName();
            this.reifiedMethod = mc.getReifiedMethod();
            this.isComponentMethodCall = mc.isComponentMethodCall;
            if (mc.serializedEffectiveArguments == null) {
                serializedEffectiveArguments = null;
            } else {
                // array copy
                byte[] source = mc.serializedEffectiveArguments;
                serializedEffectiveArguments = new byte[source.length];
                for (int i = 0; i < serializedEffectiveArguments.length; i++) {
                    serializedEffectiveArguments[i] = source[i];
                }
            }
            if (mc.effectiveArguments == null) {
                effectiveArguments = null;
            } else {
                effectiveArguments = (Object[]) Utils.makeDeepCopy(mc.effectiveArguments);
            }
            this.key = MethodCall.buildKey(mc.getReifiedMethod());
            this.metadata = mc.metadata;
            // methodcallID?
        } catch (java.io.IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Builds a new MethodCall object.
     */
    protected MethodCall() {
        this.reifiedMethod = null;
        this.effectiveArguments = null;
        this.serializedEffectiveArguments = null;
        this.metadata = null;
    }

    /**
     *        Executes the instance method call represented by this object.
     *
     * @param targetObject        the Object the method is called on
     * @throws MethodCallExecutionFailedException thrown if the reflection of the
     * call failed.
     * @throws InvocationTargetException thrown if the execution of the reified
     * method terminates abruptly by throwing an exception. The exception
     * thrown by the execution of the reified method is placed inside the
     * InvocationTargetException object.
     * @return the result of the invocation of the method. If the method returns
     * <code>void</code>, then <code>null</code> is returned. If the method
     * returned a primitive type, then it is wrapped inside the appropriate
     * wrapper object.
     */
    public Object execute(Object targetObject)
        throws InvocationTargetException, MethodCallExecutionFailedException {
        // A test at how non-public methods can be reflected
        if ((serializedEffectiveArguments != null) &&
                (effectiveArguments == null)) {
            try {
                ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serializedEffectiveArguments);

                //ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
                MarshalInputStream objectInputStream = new MarshalInputStream(byteArrayInputStream);
                effectiveArguments = (Object[]) objectInputStream.readObject();
                objectInputStream.close();
                byteArrayInputStream.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
            serializedEffectiveArguments = null;
        }
        if (logger.isDebugEnabled()) {
            logger.debug("MethodCall.execute() name = " + this.getName());
            logger.debug("MethodCall.execute() reifiedMethod = " +
                reifiedMethod);
            logger.debug(
                "MethodCall.execute() reifiedMethod.getDeclaringClass() = " +
                reifiedMethod.getDeclaringClass());
            logger.debug("MethodCall.execute() targetObject " + targetObject);
        }
        if (reifiedMethod.getParameterTypes().length > 0) {
            reifiedMethod.setAccessible(true);
        }
        try {
            return reifiedMethod.invoke(targetObject, effectiveArguments);
        } catch (IllegalAccessException e) {
            throw new MethodCallExecutionFailedException(
                "Access rights to the method denied: " + e);
        } catch (IllegalArgumentException e) {
            throw new MethodCallExecutionFailedException(
                "Arguments for the method " + this.getName() +
                " are invalids: " + e);
        } /*catch (InvocationTargetException e) {
        throw new MethodCallExecutionFailedException(
        "Target for invocation of " + this.getName() +
        " is invalid: " + e);
        }*/}

    protected void finalize() {
        MethodCall.setMethodCall(this);
    }

    public Method getReifiedMethod() {
        return reifiedMethod;
    }

    /**
     * Returns the name of the method
     * @return the name of the method
     */
    public String getName() {
        return reifiedMethod.getName();
    }

    public int getNumberOfParameter() {
        return this.effectiveArguments.length;
    }

    public Object getParameter(int index) {
        return this.effectiveArguments[index];
    }

    public Object[] getParameters() {
        return this.effectiveArguments;
    }

    public void setEffectiveArguments(Object[] o) {
        effectiveArguments = o;
    }

    public Object[] getEffectiveArguments() {
        return effectiveArguments;
    }

    /**
     * Make a deep copy of all arguments of the constructor
     */
    public void makeDeepCopyOfArguments() throws java.io.IOException {
        effectiveArguments = (Object[]) Utils.makeDeepCopy(effectiveArguments);
    }

    /**
     * accessor for the name ot the invoked Fractal interface
     * @return the name of the invoked Fractal interface
     */
    public String getComponentInterfaceName() {
        return componentInterfaceName;
    }

    /**
     * setter for the functional name of the invoked Fractal interface
     * @param string the functional name of the invoked Fractal interface
     */
    public void setComponentInterfaceName(String string) {
        componentInterfaceName = string;
    }

    //
    // --- PRIVATE METHODS -----------------------------------------------------------------------
    //
    private Class[] fixBugRead(FixWrapper[] para) {
        Class[] tmp = new Class[para.length];
        for (int i = 0; i < para.length; i++) {
            //	System.out.println("fixBugRead for " + i + " value is " +para[i]);
            tmp[i] = para[i].getWrapped();
        }
        return tmp;
    }

    private FixWrapper[] fixBugWrite(Class[] para) {
        FixWrapper[] tmp = new FixWrapper[para.length];
        for (int i = 0; i < para.length; i++) {
            //	System.out.println("fixBugWrite for " + i + " out of " + para.length + " value is " +para[i] );	
            tmp[i] = new FixWrapper(para[i]);
        }
        return tmp;
    }

    private static String buildKey(Method reifiedMethod) {
        StringBuffer sb = new StringBuffer();
        sb.append(reifiedMethod.getDeclaringClass().getName());
        sb.append(reifiedMethod.getName());
        Type[] parameters = reifiedMethod.getGenericParameterTypes();
        for (int i = 0; i < parameters.length; i++) {
            sb.append(parameters[i].toString());
        }
        return sb.toString();
    }

    //
    // --- PRIVATE METHODS FOR SERIALIZATION --------------------------------------------------------------
    //
    private void writeObject(java.io.ObjectOutputStream out)
        throws java.io.IOException {
        this.writeTheObject(out);
    }

    protected void writeTheObject(java.io.ObjectOutputStream out)
        throws java.io.IOException {
        out.defaultWriteObject();
        // The Method object needs to be converted
        out.writeObject(reifiedMethod.getDeclaringClass());
        out.writeObject(reifiedMethod.getName());
        out.writeObject(fixBugWrite(reifiedMethod.getParameterTypes()));
    }

    private void readObject(java.io.ObjectInputStream in)
        throws java.io.IOException, ClassNotFoundException {
        this.readTheObject(in);
    }

    protected void readTheObject(java.io.ObjectInputStream in)
        throws java.io.IOException, ClassNotFoundException {
        in.defaultReadObject();
        reifiedMethod = (Method) reifiedMethodsTable.get(key);
        if (reifiedMethod == null) {
            // Reads several pieces of data that we need for looking up the method
            Class declaringClass = (Class) in.readObject();
            String simpleName = (String) in.readObject();
            Class[] parameters = this.fixBugRead((FixWrapper[]) in.readObject());

            // Looks up the method
            try {
                reifiedMethod = declaringClass.getMethod(simpleName, parameters);
                reifiedMethodsTable.put(key, reifiedMethod);
            } catch (NoSuchMethodException e) {
                throw new InternalException("Lookup for method failed: " + e +
                    ". This may be caused by having different versions of the same class on different VMs. Check your CLASSPATH settings.");
            }
        } else { //added to avoid an ibis bug
            in.readObject();
            in.readObject();
            in.readObject();
        }
        if ((serializedEffectiveArguments != null) &&
                (effectiveArguments == null)) {
            try {
                ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serializedEffectiveArguments);

                //	    ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
                MarshalInputStream objectInputStream = new MarshalInputStream(byteArrayInputStream);
                effectiveArguments = (Object[]) objectInputStream.readObject();
                objectInputStream.close();
                byteArrayInputStream.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
            serializedEffectiveArguments = null;
        }
    }

    /**
     * Returns a boolean saying whether the method is one-way or not.
     * Being one-way method is equivalent to <UL>
     * <LI>having <code>void</code> as return type
     * <LI>and not throwing any checked exceptions</UL>. If the caller asks
     * for a RuntimeException or a NFE, then the call is not one way.
     * @return true if and only if the method call is one way
     */
    public boolean isOneWayCall() {
        return this.getReifiedMethod().getReturnType().equals(java.lang.Void.TYPE) &&
        (this.getReifiedMethod().getExceptionTypes().length == 0) &&
        !this.getMetadata().isRuntimeExceptionHandled();
    }

    /* Used in the REIF_AND_EXCEP cache */
    static class ReifiableAndExceptions {
        boolean reifiable; // Is the method return type reifiable ?
        boolean exceptions; // Does the method throws exceptions ? 
    }

    /**
     * Checks if the <code>Call</code> object can be
     * processed with a future semantics, i-e if its returned object
     * can be a future object.
     *
     * Two conditions must be met : <UL>
     * <LI> The returned object is reifiable
     * <LI> The invoked method does not throw any exceptions or they are catched asynchronously
     * </UL>
     * @return true if and only if the method call is asynchronous
     */
    public boolean isAsynchronousWayCall() {
        Method m = this.getReifiedMethod();
        ReifiableAndExceptions cached = (ReifiableAndExceptions) REIF_AND_EXCEP.get(m);
        if (cached == null) {

            /* void is reifiable even though the check by the MOP would tell otherwise */
            boolean reifiable = m.getReturnType().equals(java.lang.Void.TYPE);
            if (!reifiable) {
                try {
                    MOP.checkClassIsReifiable(m.getReturnType());
                    reifiable = true;
                } catch (ClassNotReifiableException e) {

                    /* Not reifiable, we already know :) */
                }
            }

            boolean exceptions = m.getExceptionTypes().length != 0;
            cached = new ReifiableAndExceptions();
            cached.reifiable = reifiable;
            cached.exceptions = exceptions;
            REIF_AND_EXCEP.put(m, cached);
        }

        return cached.reifiable &&
        (!cached.exceptions || getMetadata().isExceptionAsynchronously());
    }

    /**
     * Set the tags for barrier to the method call (by copy)
     * @param barrierTags the list of tags
     */
    public void setBarrierTags(LinkedList barrierTags) {
        this.tagsForBarrier = new LinkedList();
        Iterator it = barrierTags.iterator();
        while (it.hasNext()) {
            this.tagsForBarrier.add(new String((String) it.next()));
        }
    }

    /**
     * Get the tags for barrier to the method call (by copy)
     * @return the list of barrier tags
     */
    public LinkedList getBarrierTags() {
        return this.tagsForBarrier;
    }

    public MethodCallMetadata getMetadata() {
        if (metadata == null) {
            return MethodCallMetadata.DEFAULT;
        }

        return metadata;
    }

    //
    // --- INNER CLASSES -----------------------------------------------------------------------
    //
    public class FixWrapper implements java.io.Serializable {
        public boolean isPrimitive;
        public Class encapsulated;

        public FixWrapper() {
        }

        /**
         * Encapsulate primitives types into Class
         */
        public FixWrapper(Class c) {
            if (!c.isPrimitive()) {
                encapsulated = c;
                return;
            }
            isPrimitive = true;
            if (c.equals(Boolean.TYPE)) {
                encapsulated = Boolean.class;
            } else if (c.equals(Byte.TYPE)) {
                encapsulated = Byte.class;
            } else if (c.equals(Character.TYPE)) {
                encapsulated = Character.class;
            } else if (c.equals(Double.TYPE)) {
                encapsulated = Double.class;
            } else if (c.equals(Float.TYPE)) {
                encapsulated = Float.class;
            } else if (c.equals(Integer.TYPE)) {
                encapsulated = Integer.class;
            } else if (c.equals(Long.TYPE)) {
                encapsulated = Long.class;
            } else if (c.equals(Short.TYPE)) {
                encapsulated = Short.class;
            }
        }

        /**
         * Give back the original class
         */
        public Class getWrapped() {
            if (!isPrimitive) {
                return encapsulated;
            }
            if (encapsulated.equals(Boolean.class)) {
                return Boolean.TYPE;
            }
            if (encapsulated.equals(Byte.class)) {
                return Byte.TYPE;
            }
            if (encapsulated.equals(Character.class)) {
                return Character.TYPE;
            }
            if (encapsulated.equals(Double.class)) {
                return Double.TYPE;
            }
            if (encapsulated.equals(Float.class)) {
                return Float.TYPE;
            }
            if (encapsulated.equals(Integer.class)) {
                return Integer.TYPE;
            }
            if (encapsulated.equals(Long.class)) {
                return Long.TYPE;
            }
            if (encapsulated.equals(Short.class)) {
                return Short.TYPE;
            }
            throw new InternalException("FixWrapper encapsulated class unkown " +
                encapsulated);
        }

        public String toString() {
            return "FixWrapper: " + encapsulated.toString();
        }
    }

    public Shortcut getShortcut() {
        return shortcut;
    }

    public void shortcutNotification(UniversalBody sender,
        UniversalBody intermediate) {
        if (shortcut == null) {
            // store only first sender?
            shortcut = new Shortcut(getComponentInterfaceName(), sender,
                    intermediate);
        } else {
            shortcut.updateDestination(intermediate);
            if (componentLogger.isDebugEnabled()) {
                componentLogger.debug(
                    "added shortcut : shortcutCounter is now " +
                    shortcut.length());
            }
        }
    }

    public boolean isComponentMethodCall() {
        return isComponentMethodCall;
    }

    public boolean isComponentMethodCallOnComponent() {
        return (isComponentMethodCall && (componentInterfaceName == null));
    }

    public short getPriority() {
        return priority;
    }

    // end inner class FixWrapper
}
