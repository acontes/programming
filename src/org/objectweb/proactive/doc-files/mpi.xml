<?xml version="1.0" encoding="UTF-8"?>
<chapter id="WrappingMpiAndLegacyCode">
	<title>Wrapping MPI and Legacy code</title>

	<sect1 remap="h2">
		<title>
			<anchor id="dbdoclet.id.dbdoclet.id.MPI_html_Overview" />Simple wrapping - Overview</title>

		<para>The <emphasis role="bold">Message Passing Interface (MPI)</emphasis> is a widely adopted communication 
library for parallel and distributed computing. This work aims at making it easier to wrap and deploy MPI legacy code
within ProActive.</para>

		<para>The <emphasis role="bold">simple wrapping</emphasis> allows an MPI cluster application to be embedded 
within  ProActive in a problem-solving environment. It permits users to develop 
conventional stand-alone Java applications that use a <emphasis role="bold">native MPI application</emphasis> on 
cluster systems. Primary objective is <emphasis role="bold">to hide coupling application deployment</emphasis> on several clusters.
This document exposes a simple wrapping architecture designed to <emphasis role="bold">automatically deploy MPI application</emphasis> on a cluster through the use of deployment descriptor.</para>

		<para>This work can also <emphasis role="bold">be combined with the ProActive Fractal component 
model</emphasis> in order to write application as component tasks in a dataflow-style task graph.
The idea is to encapsulate simulation codes into components and let 
them communicate through ProActive. In fact, ProActive provides a communication layer 
so that components can be distributed on different computing resources within a 
Computational Grid. </para>
		<para>
			<emphasis role="bold">However</emphasis> the simple wrapping method 
do not let SPMD processes associated with one code communicate with the SPMD 
processors associated with another simulation code. We are currently studying this 
last point in the <emphasis role="bold">interacting wrapping context</emphasis>.</para>
	</sect1>

	<sect1 remap="h2">
		<title>
			<anchor id="dbdoclet.id.dbdoclet.id.MPI_html_Infrastructure_Model" />Simple Wrapping - Infrastructure Model</title>

		<para>The goal of this work is mainly to deploy automatically and transparently 
MPI parallel applications on cluster. Transparency means that user
does not know what particular resources provides computer power. So the user should just have to carry out the deployment 
descriptor file and get back the result of the application without worrying about resources
selection, resource location and type, or mapping process on resources.
	</para>

		<para>
			<figure>
				<title>File transfer and asking for resources</title>
				<mediaobject>
					<imageobject>
						<imagedata fileref="mpi_files/deployment.png" format="PNG" width="6in" />
					</imageobject>
				</mediaobject>
			</figure>
		</para>

		<itemizedlist>

			<listitem>
				<para>
					<emphasis role="bold">(1) File Transfer</emphasis>
				</para>

				<para>As we said before, the primary objective is to provide user an automatic deployment of his application 
through a file deployment descriptor. In fact, ProActive provides support for File Transfer. In this way, user can
transfer MPI application <emphasis role="bold">input data</emphasis> and/or MPI <emphasis role="bold">application code</emphasis> to the remote host. The File Transfer happens before the user launches his application.
For more details about File Transfer click <link linkend="FileTransfer_html_intro">here</link>.
		</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">(2) Asking for resources</emphasis>
				</para>
				<para>User describes MPI job requirements in the file deployment descriptor.
He gets back a Virtual Node corresponding to the remote available hosts for the MPI Job execution.
For more details (or usage example) about resources booking, have a look to section: <emphasis role="bold">"Using the Simple Wrapping Infrastructure" </emphasis>.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">(3) Control MPI process using the MPI API</emphasis>
				</para>
				<para>After deployment, user obtains the Virtual Node containing resources required for the MPI job.
<emphasis role="bold">An MPI job is referenced within a Virtual Node as an MPI Process. </emphasis>
For more details about MPI Process, have a look to section: <emphasis role="bold">"Design and Implementation" </emphasis>.
The MPI API provides user to create an <emphasis role="bold">MPISpmd object</emphasis> from the Virtual Node obtained, or directly from an MPI process associated with the Virtual Node object. 
In that way user is able to control the MPI program, that is: trigger the job execution, kill the job, synchronize the job, get the object status/result etc..).
This API is detailed in the next chapter.
 			</para>
			</listitem>
		</itemizedlist>

	</sect1>
	<sect1 remap="h2">
		<title>
			<anchor id="dbdoclet.id.dbdoclet.id.MPI_html_MPI_API" />MPI Wrapping API</title>


		<sect2 remap="h3">
			<title>
				<anchor id="dbdoclet.id.dbdoclet.id.MPI_html_Simple_Wrapping_API" />Simple wrapping</title>

			<sect3 remap="h4">
				<title>
					<anchor id="dbdoclet.id.dbdoclet.id.MPI_html_API_Definition" />MPI API Definition</title>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">What is an MPISpmd object ?</emphasis>
						</para>
						<para>
An MPISpmd object is regarded as an MPI code wrapper. It has the following features : </para>
						<itemizedlist>
							<listitem>
								<para>
									<emphasis role="bold">It references an MPI Process</emphasis> (pre-defined in a Virtual Node)
								</para>
							</listitem>
							<listitem>
								<para>
									<emphasis role="bold">It holds a state</emphasis> (which can take different status)
								</para>
							</listitem>
							<listitem>
								<para>
									<emphasis role="bold">It can be controlled through an API</emphasis> (presented in next section)
								</para>
							</listitem>
						</itemizedlist>

					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">MPISpmd object creation methods</emphasis>
						</para>
						<screen>import org.objectweb.proactive.mpi;

static public void <emphasis role="bold">MPI.createMPISPMDObject</emphasis>(VirtualNode virtualNode);
static public void <emphasis role="bold">MPI.createMPISPMDObject</emphasis>(ExternalProcess mpiProcess, String name);</screen>
						<para>These methods are used to create an <emphasis role="bold">MPISpmd object</emphasis> from a Virtual Node which
 references an MPI process, or directly from an MPI process and its name. 
</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">MPISpmd object control methods</emphasis>
						</para>
						<screen>public void <emphasis role="bold">startMPI</emphasis>();</screen>
						<para> Triggers the process execution represented by the MPISpmd object on the resources previously allocated.
						</para>
						<screen>public void <emphasis role="bold">reStartMPI</emphasis>();</screen>
						<para> Restarts the process represented by the MPISpmd object on the same resources. This process has to be previously been started once,
						 this method throws an exception otherwise.
						</para>
						<screen>public void <emphasis role="bold">killMPI</emphasis>();</screen>
						<para> Stops the process represented by the MPISpmd object if it's running, this method throws an exception otherwise.
						</para>
						<screen>public void <emphasis role="bold">waitFor</emphasis>();</screen>
						<para>Causes the process represented by the MPISpmd object to wait, if necessary, until it has terminated.
						The method returns immediately if the process has already terminated. 
						If the process has not yet terminated, application will be blocked until the process exits.
						</para>
						<screen>public int <emphasis role="bold">getReturnValue</emphasis>();</screen>
						<para> Returns the exit value of the process represented by the MPISpmd object if the process has finished, 
						this method throws an exception otherwise.
						By convention, the value 0 indicates normal termination.
						</para>
						<screen>public String <emphasis role="bold">getStatus</emphasis>();</screen>
						<para> Returns the current status of the MPISpmd object. The different status are listed in the next item.
						</para>
						<screen>public String <emphasis role="bold">setCommandArguments</emphasis>(String arguments);</screen>
						<para> Add or modify existing MPI command parameters. It permits to use a same MPI code within two MPISpmd object.
							For an example please refer to the chapter: <emphasis role="bold">Usage example with several codes</emphasis>.
						 </para>

					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">MPISpmd object status</emphasis>
						</para>

						<screen>import org.objectweb.proactive.mpi;

<emphasis role="bold">MPIConstants.MPI_UNSTARTED</emphasis>; // default status - after MPISpmd object creation
<emphasis role="bold">MPIConstants.MPI_RUNNING</emphasis>;   // after MPISpmd object has been started or restarted
<emphasis role="bold">MPIConstants.MPI_KILLED</emphasis>;    // after MPISpmd object has been killed
<emphasis role="bold">MPIConstants.MPI_FINISHED</emphasis>;  // after MPISpmd object has finished</screen>
						<para> Each status defines the current state of the MPISpmd object, that is the state of the MPI Process it references.
 It provides the guarantee of application consistency and a better control of the application
 in case of multiple MPISpmd objects.</para>

					</listitem>
				</itemizedlist>
			</sect3>
			<sect3 remap="h4">
				<title>
					<anchor id="dbdoclet.id.dbdoclet.id.MPI_html_USE_API" />How to use the API</title>
				<para>

					<figure>
						<title>Status sketch</title>
						<mediaobject>
							<imageobject>
								<imagedata fileref="mpi_files/status.png" format="PNG" width="6in" />
							</imageobject>
						</mediaobject>
					</figure>
				</para>
				<para> Import the package <emphasis role="bold">package org.objectweb.proactive.mpi; </emphasis>. In order to keep application consistency, the MPISpmd object makes use of status.
It garantees that either the method call on object is coherent or an exception is thrown. 
Especially the exception is an <emphasis role="bold">IllegalStateException</emphasis> that signals that a method has been invokated at an illegal or inappropriate time.
In other words, application is not in an appropriate state for the requested operation.
Your application do not require to declare in its throws clause because IllegalStateException is a subclasse of RuntimeException.
Therefore this exception can be thrown during the execution of the method but cannot be caught.
To make it easier to write your application, you should follow the sketch above.</para>


				<para>
					<emphasis role="bold">Sample of code: </emphasis> 
These few lines of code show how to execute an MPI job and get its return value once finished. 

				</para>
				<screen>
import org.objectweb.proactive.ProActive;
import org.objectweb.proactive.core.ProActiveException;
import org.objectweb.proactive.core.config.ProActiveConfiguration;
import org.objectweb.proactive.core.descriptor.data.ProActiveDescriptor;
import org.objectweb.proactive.core.descriptor.data.VirtualNode;

...
// load the file desciptor 
ProActiveDescriptor pad = ProActive.getProactiveDescriptor('file:descriptor.xml');

// get the Virtual Node which references the MPI code you want to execute
VirtualNode vnCpi = pad.getVirtualNode('CPI');

// activate Virtual Node (it's not mandatory, the createMPISMPDObject method does it automatically if it has not been already done)
vnCpi.activate();

// create the MPISpmd object with the Virtual Node
MPISpmd my_spmd = <emphasis role="bold">MPI.createMPISPMDObject(vnCpi);</emphasis>

// trigger MPI code execution
my_spmd.<emphasis role="bold">startMPI();</emphasis>

// print current status
System.out.println("Current status: "+my_spmd.<emphasis role="bold">getStatus()</emphasis>);

// wait for the MPI code to finish
my_spmd.<emphasis role="bold">waitFor();</emphasis>

// get return value
System.out.println("Return value: "+my_spmd.<emphasis role="bold">getReturnValue()</emphasis>);

// print the MPISpmd object
System.out.println(<emphasis role="bold">my_spmd</emphasis>);

...

				</screen>
			</sect3>
		</sect2>
	</sect1>


	<sect1 remap="h2">
		<title>
			<anchor id="dbdoclet.id.dbdoclet.id.MPI_html_Using_Infrastructure" />Using the Simple Wrapping Infrastructure</title>
		<para>
	 Resources booking is specified using ProActive Descriptors.
	We explain the operation with the example included in the release. The entire file is available <ulink url="mpi_files/MPIRemote-descriptor.xml">here</ulink>.
</para>
		<itemizedlist>
			<listitem>
				<para>
					<emphasis role="bold">File Transfer: </emphasis> specify all the files which
 have to be transferred on the remote host like <emphasis role="bold">binary code</emphasis> and <emphasis role="bold">input data</emphasis>. 
In the following example, "cpi" is the mpi progam name. 
				</para>
				<screen>&lt;componentDefinition&gt;
   &lt;virtualNodesDefinition&gt;
    &lt;virtualNode name='CPI' /&gt;
   &lt;/virtualNodesDefinition&gt;
  &lt;/componentDefinition&gt;
  &lt;deployment&gt;
   ...
  &lt;/deployment&gt;
  &lt;FileTransferDefinitions&gt;
   &lt;FileTransfer id='<emphasis role="bold">mpiCodeTransfer</emphasis>'&gt;
    &lt;file src='cpi' dest='cpi' /&gt;
   &lt;/FileTransfer&gt;
  &lt;/FileTransferDefinitions&gt;
</screen>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">Resources allocation:</emphasis> define all processes for connecting
remote host and also processes for resources reservation.
				</para>
				<para>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis role="bold">SSHProcess:</emphasis>
first define the process to connect the remote host. Link the reference id
 of the file transfer with the FileTransfer previously defined and link the
 reference id to the DependentProcessSequence process defined below.</para>

							<screen>&lt;processDefinition id='sshProcess'&gt;
   &lt;sshProcess class='org.objectweb.proactive.core.process.ssh.SSHProcess' hostname='nef.inria.fr' username='smariani'&gt;
    &lt;processReference refid='<emphasis role="bold">dependentProcessCPI</emphasis>'  /&gt;
	&lt;FileTransferDeploy refid='<emphasis role="bold">mpiCodeTransfer</emphasis>'&gt;
	  &lt;copyProtocol&gt;scp&lt;/copyProtocol&gt;
	   &lt;sourceInfo prefix=<emphasis role="bold">'/user/smariani/home/ProActive/src/org/objectweb/proactive/examples/mpi'</emphasis> /&gt;
	   &lt;destinationInfo prefix=<emphasis role="bold">'/home/smariani/MyApp'</emphasis> /&gt;
	&lt;/FileTransferDeploy&gt;
   &lt;/sshProcess&gt;
  &lt;/processDefinition&gt;
</screen>
						</listitem>
						<listitem>
							<para>
								<emphasis role="bold">Dependent Process Sequence:</emphasis>
 define the process to express the MPI process dependency towards PBS process. 
				</para>
							<screen>
&lt;processDefinition id=<emphasis role="bold">'dependentProcessCPI'</emphasis>&gt;
   &lt;<emphasis role="bold">dependentProcessSequence</emphasis> class='<emphasis role="bold">org.objectweb.proactive.core.process.DependentListProcessDecorator</emphasis>'&gt;
	&lt;processReference refid=<emphasis role="bold">'pbsProcess'</emphasis> /&gt;
	&lt;processReference refid=<emphasis role="bold">'mpiProcess'</emphasis> /&gt;
   &lt;<emphasis role="bold">/dependentProcessSequence</emphasis>&gt;
  &lt;/processDefinition&gt;
</screen>
						</listitem>
						<listitem>
							<para>
								<emphasis role="bold">PBS Process:</emphasis>
 note: you can use any services defined in ProActive to allocate resources instead of the PBS one.
				</para>
							<screen>
&lt;processDefinition id=<emphasis role="bold">'pbsProcess'</emphasis>&gt;
  &lt;pbsProcess class='org.objectweb.proactive.core.process.pbs.PBSSubProcess'&gt;
	&lt;processReference refid=jvmProcess' /&gt;
	&lt;commandPath value='/opt/torque/bin/qsub' /&gt;
	&lt;pbsOption&gt;
	 &lt;hostsNumber&gt;16&lt;/hostsNumber&gt;
	 &lt;processorPerNode&gt;1&lt;/processorPerNode&gt;
	 &lt;bookingDuration&gt;00:02:00&lt;/bookingDuration&gt;
	 &lt;scriptPath&gt;
	  &lt;absolutePath value='/home/smariani/pbsStartRuntime.sh' /&gt;
	 &lt;/scriptPath&gt;
	&lt;/pbsOption&gt;
  &lt;/pbsProcess&gt;
 &lt;/processDefinition&gt;
</screen>
						</listitem>
					</itemizedlist>
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">MPI process: </emphasis> define the MPI process and its attributes. 
It is possible to pass a command option to mpirun by filling the attribute <emphasis role="bold">mpiCommandOptions</emphasis>.
Specify hosts number you whish the application to be deployed and at least the MPI code local path.
The local path is the path from which you start the application.
In the case of remote application, if the remote path field is not set, the host file will not be sent to remote host
and MPI process will raise an error.

				</para>
				<screen>&lt;processDefinition id=<emphasis role="bold">'mpiProcess'</emphasis>&gt;
 &lt;<emphasis role="bold">mpiProcess</emphasis> class='<emphasis role="bold">org.objectweb.proactive.core.process.mpi.MPIDependentProcess</emphasis>' mpiFileName='cpi'&gt;
  &lt;commandPath value='/usr/src/redhat/BUILD/mpich-1.2.6/bin/mpirun' /&gt;
  &lt;mpiOptions&gt;
   &lt;processNumber&gt;<emphasis role="bold">16</emphasis>&lt;/processNumber&gt;
   &lt;localRelativePath&gt;
    &lt;relativePath origin='user.home' value=<emphasis role="bold">'/ProActive/scripts/unix'</emphasis> /&gt;
   &lt;/localRelativePath&gt;
   &lt;remoteAbsolutePath&gt;
    &lt;absolutePath value=<emphasis role="bold">'/home/smariani/MyApp'</emphasis> /&gt;
   &lt;/remoteAbsolutePath&gt;
  &lt;/mpiOptions&gt;
 &lt;<emphasis role="bold">/mpiProcess</emphasis>&gt;
&lt;/processDefinition&gt;</screen>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 remap="h2">
		<title>
			<anchor id="dbdoclet.id.dbdoclet.id.MPI_html_Multiple_code" />Usage example with several codes</title>

Let's assume we have several MPI codes that we want to interconnect together
with the same workflow that on the following picture. Each module (VibroToAcous, AcousToVibro, Vibro, Acous, CheckConvergency)
is a parallel MPI code. 
	<para>
			<figure>
				<title> Vibro-acoustic numerical simulation</title>
				<mediaobject>
					<imageobject>
						<imagedata fileref="mpi_files/MPI_Component.png" format="PNG" width="6in" />
					</imageobject>
				</mediaobject>
			</figure>

		</para>


	</sect1>

	<para>Here is an example of the API usage with several codes. 
Also, it shows principle of using two MPISpmd objects with a same MPI code.</para>

	<screen>
import org.objectweb.proactive.ProActive;
import org.objectweb.proactive.core.ProActiveException;
import org.objectweb.proactive.core.config.ProActiveConfiguration;
import org.objectweb.proactive.core.descriptor.data.ProActiveDescriptor;
import org.objectweb.proactive.core.descriptor.data.VirtualNode;

...
// load the file desciptor 
ProActiveDescriptor pad = ProActive.getProactiveDescriptor('file:descriptor.xml');

// get the Virtual Nodes which references all the MPI code we want to use
VirtualNode VibToAc = pad.getVirtualNode('VibToAc');
VirtualNode AcToVib = pad.getVirtualNode('AcToVib');
VirtualNode Vibro = pad.getVirtualNode('Vibro');
VirtualNode Acous = pad.getVirtualNode('Acous');
VirtualNode CheckConvergency = pad.getVirtualNode('CheckConvergency');

// it's not necessary to activate manually each Virtual Node because it's done
// when creating the MPISpmd object with the Virtual Node

// create all the MPISpmd objects with corresponding Virtual Nodes
MPISpmd vibToAc = MPI.createMPISPMDObject(VibToAc);
MPISpmd acToVib = MPI.createMPISPMDObject(AcToVib);
MPISpmd vibro = MPI.createMPISPMDObject(Vibro);
MPISpmd acous = MPI.createMPISPMDObject(Acous);

// create two different MPISpmd objects from a <emphasis role="bold"> same Virtual Node </emphasis>
MPISpmd checkVibro = MPI.createMPISPMDObject(<emphasis role="bold">CheckConvergency);</emphasis>
MPISpmd checkAcous = MPI.createMPISPMDObject(<emphasis role="bold">CheckConvergency);</emphasis>

boolean convergence = false;
boolean firstLoop = true;

While (!convergence)
{
	// Accordingly two the sketch above, trigger execution of vibToAc and acToVib MPISpmd object
	if (firstLoop){
		vibToAc.<emphasis role="bold">startMPI();</emphasis>
		acToVib.<emphasis role="bold">startMPI();</emphasis>
	}else{
		vibToAc.<emphasis role="bold">reStartMPI();</emphasis>
		acToVib.<emphasis role="bold">reStartMPI();</emphasis>
	}
	
	// First Synchronisation point
	vibToAC.<emphasis role="bold">waitFor();</emphasis>
	acToVib.<emphasis role="bold">WaitFor();</emphasis>

	// good termination?
	if (( vibToAC.<emphasis role="bold">getReturnValue()</emphasis> &lt; 0 ) || ( acToVib.<emphasis role="bold">getReturnValue()</emphasis> &lt; 0 ))
		System.exit(-1);
   
	...	
	[ Use the File Transfer API to send and retrieve files generated by the MPI codes] 
	...

	// Accordingly two the sketch, trigger execution of vibro and acous MPISpmd object
	if (firstLoop){
		vibro.<emphasis role="bold">startMPI();</emphasis>
		acous.<emphasis role="bold">startMPI();</emphasis>
	}else{
		vibro.<emphasis role="bold">reStartMPI();</emphasis>
		acous.<emphasis role="bold">reStartMPI();</emphasis>
	}

	// Second synchronisation point
	vibro.<emphasis role="bold">waitFor();</emphasis>
	acous.<emphasis role="bold">WaitFor();</emphasis>

	// good termination?
	if (( vibro.<emphasis role="bold">getReturnValue()</emphasis> &lt; 0 ) || ( acous.<emphasis role="bold">getReturnValue()</emphasis> &lt; 0 ))
		System.exit(-1);
	
	...
	[ Use the File Transfer API to send and retrieve files generated by the MPI codes] 
	...
	
	// Check convergency of acoustic part and structure part
	if (firstLoop){
		// modify argument  
		checkVibro.<emphasis role="bold">setCommandArguments("oldVibro.res newVibro.res");</emphasis>
		checkAcous.<emphasis role="bold">setCommandArguments("oldAcous.res newAcous.res");</emphasis>
		checkVibro.<emphasis role="bold">startMPI();</emphasis>
		checkAcous.<emphasis role="bold">startMPI();</emphasis>
	}else{
		checkVibro.<emphasis role="bold">reStartMPI();</emphasis>
		checkAcous.<emphasis role="bold">reStartMPI();</emphasis>
	}

	// Third synchronisation point
	vibro.<emphasis role="bold">waitFor();</emphasis>
	acous.<emphasis role="bold">WaitFor();</emphasis>

	// Convergency?
	if (( checkVibro.<emphasis role="bold">getReturnValue()</emphasis> == 0 ) || ( checkAcous.<emphasis role="bold">getReturnValue() </emphasis>== 0 ))
	{
		convergence = true;
	}
	firstLoop = false;
}

	...	
	[ Use the File Transfer API to send and retrieve files generated by the MPI codes] 
	...

// free resources
VibToAc.killAll(false);
AcToVib.killAll(false);
Vibro.killAll(false);
Acous.killAll(false);
CheckConvergency.killAll(false);

				</screen>



	<sect1 remap="h2">
		<title>
			<anchor id="dbdoclet.id.dbdoclet.id.MPI_html_Design_Implementation" />Design and Implementation</title>


		<sect2 remap="h3">
			<title>
				<anchor id="dbdoclet.id.dbdoclet.id.MPI_html_Simple_Wrapping" />Simple wrapping</title>

			<para>
				<figure>
					<title> Process Package Architecture</title>
					<mediaobject>
						<imageobject>
							<imagedata fileref="mpi_files/architecture.png" format="PNG" width="6in" />
						</imageobject>
					</mediaobject>
				</figure>

			</para>

			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold">DependentListProcess and IndependentListProcess (blue part on the picture)</emphasis>
					</para>
					<para>The <emphasis role="bold">Sequential List processes </emphasis>relative classes are defined in the <emphasis role="bold">org.objectweb.proactive.core.process</emphasis> package.
The two classes share the same caracteristic: 
both contain a <emphasis role="bold">list of processes which have to be executed sequentially</emphasis>.
This dependent constraint has been integrated in order to satisfy the MPI process requirement. Indeed, the DependentListProcess class specifies
a list of processes which have to extend the <emphasis role="bold">DependentProcess interface</emphasis>, unless the header process which is a simple allocation resources process.
It provides user to be sure that the dependent process will be executed if and only if this dependent process gets back parameters from which it is 
dependent. On the other hand the <emphasis role="bold">IndependentListProcess</emphasis> provides user to launch process sequentially but we do not use this last functionality for 
the MPI process case.
 			</para>
				</listitem>
				<listitem>
					<para>
						<emphasis role="bold">MPI Dependent Process (red part on the picture)</emphasis>
					</para>
					<para> The <emphasis role="bold">MPI</emphasis> relative classes are defined in the <emphasis role="bold">org.objectweb.proactive.core.process.mpi</emphasis> package.
As we explain item above, MPI process preliminary requires a list of hosts for job execution. 
Thus it is considered as a <emphasis role="bold">Dependent Process</emphasis>, dependent on process which sends back a list of hosts on which MPI could be deployed.
 			</para>
				</listitem>

			</itemizedlist>



		</sect2>
	</sect1>


</chapter>