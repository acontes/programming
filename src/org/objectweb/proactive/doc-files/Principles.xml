<?xml version="1.0" encoding="UTF-8"?>
<chapter id="Principles">
  <title>Principles</title>

  <!--  File: /home/irosenbe/PA_new_doc/docbook-tuto/Principles.html  -->

  <sect1 remap="h2">
    <title><anchor id="Principles_html_intro" />Seamless sequential,
    multithreaded and distributed</title>

    <para>Most of the time, activities and distribution are not known at the
    beginning, and change over time. <emphasis role="bold">Seamless implies
    reuse, smooth and incremental transitions</emphasis>.</para>

    <para><figure>
        <title>Different computing deployment paradigms</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/proActiveModelColor.png" format="PNG"
                        />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>A huge gap yet exists between multithreaded and distributed Java
    applications which forbids code reuse in order to build distributed
    applications from multithreaded applications. Both JavaRMI and JavaIDL, as
    examples of distributed object libraries in Java, put a heavy burden on
    the programmer because they require deep modifications of existing code in
    order to turn local objects into remote accessible ones. In these systems,
    remote objects need to be accessed through some specific interfaces. As a
    consequence, these distributed objects libraries do not allow polymorphism
    between local and remote objects. This feature is our first requirement
    for a metacomputing framework. It is strongly required in order to let the
    programmer concentrate first on modeling and algorithmic issues rather
    than lower-level tasks such as object distribution, mapping and load
    balancing.</para>
  </sect1>

  <sect1 remap="h2">
    <title><anchor id="Principles_html_active" />Active objects: Unifying
    threads and remote objects</title>

    <para>Given a standard object, we provide the ability to give it:</para>

    <itemizedlist>
      <listitem>
        <para>location transparency</para>
      </listitem>

      <listitem>
        <para>activity transparency</para>
      </listitem>

      <listitem>
        <para>synchronization</para>
      </listitem>
    </itemizedlist>

    <sect2 remap="h3">
      <title>==&gt; only with modifications of the instanciation code
      !</title>

      <para>Three ways to transform a standard object into an active
      one:</para>
    </sect2>

    <sect2 remap="h3">
      <title>Class-based</title>

      <blockquote>
        <para><screen>
Object[] params = new Object[] { new Integer (26), 'astring' };
A a = (A) ProActive.newActive('example.A', params, node); </screen></para>
      </blockquote>
    </sect2>

    <sect2 remap="h3">
      <title>Instantiation-based</title>

      <blockquote>
        <para><screen>
public class AA extends A implements Active {}
Object[] params = new Object[] { new Integer (26), 'astring' };
A a = (A) ProActive.newActive('example.AA', params, node); </screen></para>
      </blockquote>
    </sect2>

    <sect2 remap="h3">
      <title>Object-based</title>

      <para>Allows to turn active and remote objects for which you do not have
      the source code; a necessary feature in the context of code
      mobility.</para>

      <blockquote>
        <para><screen>
A a = new A (26, 'astring');
a = (A) ProActive.turnActive(a, node) ; </screen></para>
      </blockquote>

      <para><emphasis role="bold">Notes:</emphasis><emphasis>Node allows to
      control the mapping</emphasis></para>
    </sect2>
  </sect1>

  <sect1 remap="h2">
    <title><anchor id="Principles_html_model" />Model of Computation: Based on
    previous works and studies</title>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Heterogeneous model</emphasis> both
        passive and active objects</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Systematic asynchronous communications
        towards active objects</emphasis></para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">No shared passive object</emphasis> ,
        Call-by-value between active objects</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Automatic continuations</emphasis> , a
        transparent delegation mechanism</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">wait-by-necessity</emphasis> , automatic
        and transparent futures</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Centralized and explicit
        control</emphasis> , libraries of Abstractions</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 remap="h2">
    <title><anchor id="Principles_html_reuse"
    xreflabel="Reuse and Seamless: why and how do we achieve  better reuse?" />Reuse
    and Seamless: why and how do we achieve better reuse?</title>

    <para>Two key features:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Wait-by-necessity: inter-objects
        synchronization</emphasis></para>
      </listitem>
    </itemizedlist>

    <para>Systematic, implicit and transparent futures. Ease the programming
    of synchronization and reuse of existing methods</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Polymorphism between standard and active
        objects</emphasis></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para>Type compatibility for classes and not just for interface</para>
      </listitem>

      <listitem>
        <para>Needed and done for the future objects as well</para>
      </listitem>

      <listitem>
        <para>Dynamic mechanism (dynamically achieve if needed)</para>
      </listitem>
    </itemizedlist>

    <para><figure>
        <title>Polymorphism</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/polymorphism.png" format="PNG"
                        />
          </imageobject>
        </mediaobject>
      </figure></para>
  </sect1>

  <sect1 id="TinyHelloWorld" remap="h2">
    <title>Hello world ! (tiny example)</title>

    <para>This example implements the smallest program in ProActive. This is
    the easiest program you could write, using the Active Object concept. This
    is just to show quickly how code can be written, with minimal knowledge of
    the API.</para>

    <para>You can get a more complete 'hello world' example, with deployment
    on a remote host, <link linkend="HelloWorld">further on</link> in the
    manual.</para>

    <para>A client object displays a <literal>String</literal> received from
    elsewhere (the original VM). This illustrates the creation of an Active
    Object.</para>

    <para>Only one class is needed: we have put the main method inside the
    class, which when deployed will be an Active Object.</para>

    <sect2 remap="h3">
      <title>The TinyHello class</title>

      <para>This class can be used as an Active Object, serving requests. Its
      creation involves the following steps:</para>

      <itemizedlist>
        <listitem>
          <para>Provide an implementation for the required server-side
          functionalities</para>
        </listitem>

        <listitem>
          <para>Provide an empty, no-arg constructor</para>
        </listitem>

        <listitem>
          <para>Write a <literal>main</literal> method in order to instantiate
          one server object.</para>
        </listitem>
      </itemizedlist>

      <para>Here is a possible implementation for the
      <literal>TinyHello</literal> class:</para>

      <screen>
package org.objectweb.proactive.examples.hello;
import org.apache.log4j.Logger;
import org.objectweb.proactive.ProActive;
import org.objectweb.proactive.core.util.log.*;
import org.objectweb.proactive.core.util.wrapper.StringMutableWrapper;
import java.net.UnknownHostException;
/** 
 * A stripped-down Active Object example.
 * The object has only one public method, sayHello()
 * The object does nothing but reflect the host its on. 
 */
public class TinyHello implements java.io.Serializable {
    static Logger logger = ProActiveLogger.getLogger(Loggers.EXAMPLES);
    private final String message = 'Hello World!';
    /** ProActive compulsory no-args constructor */
    public TinyHello() {
    }
    /** The Active Object creates and returns information on its location
     * @return a StringWrapper which is a Serialized version, for asynchrony */
    public StringMutableWrapper sayHello()
 {
        return new StringMutableWrapper(
            this.message + '\n from ' + getHostName() + '\n at ' +
            new java.text.SimpleDateFormat('dd/MM/yyyy HH:mm:ss').format(new java.util.Date()));
    }
    /** finds the name of the local machine */
    static String getHostName() {
        try {
            return java.net.InetAddress.getLocalHost().toString();
        } catch (UnknownHostException e) {
            return 'unknown';
        }
    }
    /** The call that starts the Acive Objects, and displays results.
     * @param args must contain the name of an xml descriptor */
    public static void main(String[] args)
        throws Exception {
        // Creates an active instance of class Tiny on the local node
        TinyHello tiny = (TinyHello) ProActive.newActive(
                TinyHello.class.getName(), 
// the class to deploy
                null 
// the arguments to pass to the constructor, here none
            );  
        // get and display a value 
        StringMutableWrapper received = 
tiny.sayHello();
 // possibly remote call
        logger.info('On ' + getHostName() + ', a message was received: ' + received); // potential wait-by-necessity 
    }
}
</screen>
    </sect2>

    <sect2 remap="h3">
      <title>Implement the required functionalities</title>

      <para>Implementing any remotely-accessible functionality is simply done
      through normal Java methods in a normal Java class, in exactly the same
      manner it would have been done in a non-distributed version of the same
      class. Here, the only method is <literal>sayHello</literal></para>
    </sect2>

    <sect2 remap="h3">
      <title>Creating the <literal>Hello</literal> Active Object</title>

      <para>Now that we know how to write the class that implements the
      required server-side functionalities, let us see how to create the
      server object. We want this active object to be created on the current
      node, which is why we use <literal>newActive</literal> with only two
      parameters (done in the <literal>main</literal> method).</para>

      <para>The code snippet which instantiates the
      <literal>TinyHello</literal> in the same VM is the following (in the
      <literal>main</literal> method):</para>

      <screen>
        TinyHello tiny = (TinyHello) ProActive.newActive(
                TinyHello.class.getName(), // the class to deploy
                null // the arguments to pass to the constructor, here none
            ); // which jvm should be used to hold the Active Object
</screen>
    </sect2>

    <sect2 remap="h3">
      <title>Invoking a method on a remote object and printing out the
      message</title>

      <para>This is exactly like invoking a method on a local object of the
      same type. The user does not have to deal with catching
      distribution-related exceptions.</para>

      <para>As already stated, the only modification brought to the code by
      ProActive is located at the place where active objects are created. All
      the rest of the code remains the same, which fosters software reuse. So
      the way to call the <literal>sayHello</literal> method in this example
      is the following (in the <literal>main</literal> method):</para>

      <screen>
        StringMutableWrapper received = tiny.sayHello(); // possibly remote call
        logger.info('On ' + getHostName() + ', a message was received: ' + received); // potential wait-by-necessity 
</screen>
    </sect2>

    <sect2 remap="h3">
      <title>Launching</title>

      <para>To launch the example, you may type:</para>

      <para><literal>linux&gt; java
      -Djava.security.policy=scripts/proactive.java.policy
      -Dlog4j.configuration=file:scripts/proactive-log4j
      org.objectweb.proactive.examples.hello.TinyHello windows&gt; java
      -Djava.security.policy=scripts\proactive.java.policy
      -Dlog4j.configuration=file:scripts\proactive-log4j
      org.objectweb.proactive.examples.hello.TinyHello</literal></para>

      <para>There are also scripts in the <literal>scripts</literal> directory:</para>

      <para><literal>linux&gt; cd scripts/unix/ linux&gt; tinyHello.sh
      windows&gt; cd scripts/windows windows&gt;
      tinyHello.bat</literal></para>

      <sect3 remap="h4">
        <title>The output</title>

        <screen>
[apple unix]tinyhello.sh
--- Hello World tiny example ---------------------------------
&gt; This ClassFileServer is reading resources from classpath
ProActive Security Policy (proactive.runtime.security) not set. Runtime Security disabled
Created a new registry on port 1099
//apple.inria.fr/Node628280013 successfully bound in registry at //apple.inria.fr/Node628280013
Generating class: pa.stub.org.objectweb.proactive.examples.hello.Stub_TinyHello
Generating class: pa.stub.org.objectweb.proactive.core.util.wrapper.Stub_StringMutableWrapper
On apple/138.96.218.62, a message was received: Hello World!
  from apple/138.96.218.62
  at 03/11/2005 14:25:32
</screen>
      </sect3>
    </sect2>
  </sect1>
</chapter>