package org.objectweb.proactive.extensions.structuredp2p.core.overlay.can;import java.util.ArrayList;import java.util.Random;/** * Coordinate of type lexicographic. The lexicographical order is a natural order structure of the * Cartesian product of two ordered sets. *  * @author Filali Imen */@SuppressWarnings("serial")public class LexicographicCoordinate extends Coordinate {    /**     * Constructor.     *      * @param value     */    public LexicographicCoordinate(String value) {        super(value);    }    /**     * Compute the position of the decimal separator. The position is given by the coordinate that     * has the shortest string length     *      * @param coord1     *            the first coordinate.     * @param coord2     *            the second coordinate.     * @return the position of the decimal separator     */    public long getIndexOfDecimalSeparator(Coordinate coord1, Coordinate coord2) {        return (Math.min(coord1.getValue().length(), coord2.getValue().length()));    }    /**     * Returns the pairwise sum of the code points values.If the two code point lists do not have     * the same size the remaining elements of the longest list are append at the end.     *      * @param codePtsStr1     *            unicode code point list of characters in the first string.     * @param codePtsStr2     *            unicode code point list of characters in the second string.     * @return the sum of unicode code point values.     */    public static ArrayList<Integer> sumUnicodeCodePoints(ArrayList<Integer> codePtsStr1,            ArrayList<Integer> codePtsStr2) {        ArrayList<Integer> sumCodePoints = new ArrayList<Integer>();        int minLen = Math.min(codePtsStr1.size(), codePtsStr2.size());        int maxL = Math.max(codePtsStr1.size(), codePtsStr2.size());        for (int i = 0; i < minLen; i++) {            sumCodePoints.add(codePtsStr1.get(i) + codePtsStr2.get(i));        }        ArrayList<Integer> currentCodePtsStr = codePtsStr2;        if (codePtsStr1.size() > codePtsStr2.size()) {            currentCodePtsStr = codePtsStr1;        }        sumCodePoints.addAll(sumCodePoints.size(), currentCodePtsStr.subList(minLen, maxL));        return (sumCodePoints);    }    /**     * Returns the middle coordinate of two Lexicographic Coordinates.     *      * @param coord1     *            the first coordinate.     * @param coord2     *            the second coordinate.     * @return the middle coordinate.     */    public Coordinate getMiddleWith(Coordinate coord2) {        ArrayList<Integer> codePtsStr1 = LexicographicCoordinate.fromCoordinateToUnicode(this);        System.out.println( printInformation(codePtsStr1) ) ;        ArrayList<Integer> codePtsStr2 = LexicographicCoordinate.fromCoordinateToUnicode(coord2);        System.out.println( printInformation(codePtsStr2) ) ;        ArrayList<Integer> sumCodePoints = LexicographicCoordinate.sumUnicodeCodePoints(codePtsStr1,                codePtsStr2);        // Computes the middle code point value for each character element        ArrayList<Integer> middleChrCodePts = LexicographicCoordinate.getMiddleUnicodes(sumCodePoints);        System.out.println( printInformation(middleChrCodePts) ) ;        return (new LexicographicCoordinate(LexicographicCoordinate.fromUnicodeToCoordinate(middleChrCodePts)));    }    /**     * Returns the unicode code points values for the specified coordinate.     *      * @param coord     *            the lexicographic coordinate.     * @return the list of unicode code points values of characters belonging to the lexicographic     *         coordinate.     */    public static ArrayList<Integer> fromCoordinateToUnicode(Coordinate coord) {        ArrayList<Integer> codePtArray = new ArrayList<Integer>();        for (int i = 0; i < coord.getValue().length(); i++) {            int codePt = coord.getValue().codePointAt(i);            codePtArray.add(codePt);        }        return (codePtArray);    }    /**     * Returns the string value from the unicode code point values.     *      * @param codePoints     *            the middle code point arrays value.     * @return the string value from the unicode code point values.     */    public static String fromUnicodeToCoordinate(ArrayList<Integer> codePoints) {        StringBuffer buf = new StringBuffer("");        for (int i = 0; i < codePoints.size(); i++) {            int c = codePoints.get(i);            buf.append((char) c);        }        return buf.toString();    }    /**     * Returns the middle of elements in the unicode code point list. If the remainder is not     * <code>null</code>, it will be concatenated with the next element if it exists otherwise it     * will be appended at the end. This list will be used to retrieve the string value of the     * middle coordinate from its code point values.     *      * @param codePoints     *            the code points values.     * @return the unicode code points list.     */    public static ArrayList<Integer> getMiddleUnicodes(ArrayList<Integer> codePoints) {        ArrayList<Integer> middleChrCodePts = new ArrayList<Integer>();        int cp;        for (int j = 0; j < codePoints.size(); j++) {            cp = codePoints.get(j);            int d = cp / 2;            int remainder = cp % 2;            middleChrCodePts.add(d);            if (remainder != 0) {                // Shift the remainder to the next element                if ((j + 1) < codePoints.size()) {                    String s = remainder + "" + codePoints.get(j + 1);                    int newCodePoint = Integer.parseInt(s);                   codePoints.set(j + 1, newCodePoint);                   // codePoints.set(j+1,codePoints.get(j+1)+remainder) ;                } else {                   middleChrCodePts.add(d);                }            }        }        return (middleChrCodePts);    }    /**     * {@inheritDoc}     */    public int compareTo(Coordinate coord) {        return super.getValue().compareTo(coord.getValue());    }    /**     * Generate a random {@link LexicographicCoordinate}.     *      * @param length     *            the length of the coordinate.     * @return the generated {@link LexicographicCoordinate}.     */    public static LexicographicCoordinate random(int length) {        Random rand = new Random();        String chars = "abcdefghijklmnopqrstuvwxy";        StringBuffer generatedString = new StringBuffer();        for (int x = 0; x < length; x++) {            // Create random index            int i = rand.nextInt(chars.length());            generatedString.append(chars.charAt(i));        }        return new LexicographicCoordinate(generatedString.toString());    }    /**     *      * @param l     * @return     */    public String printInformation(ArrayList<?> l) {        String s = "|";        for (int i = 0; i < l.size(); i++) {            s += l.get(i) + "|";        }        return (s);    }    /**     *  generate a random string     * @param length  the length of the string     * @return  the generated string     */    public  static String generate(int length) {	    String chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";	    String StringToLookFor = "";	    for(int x=0;x<length;x++)   {	    	// create random index	       int i = (int)Math.floor(Math.random() * chars.length() -1); 	       StringToLookFor += chars.charAt(i);	    }	    System.out.println(StringToLookFor);	    return StringToLookFor;}    /**     * Test many successive splits.     *      * @param args     */    public static void main(String[] args) {        Coordinate coord1;        Coordinate middleCoord = new LexicographicCoordinate("a");        Coordinate coord2 = new LexicographicCoordinate("z");        int nbOfSplit = 10;        while (nbOfSplit > 0) {            coord1 = new LexicographicCoordinate(middleCoord.getValue());            middleCoord = middleCoord.getMiddleWith(coord2);            System.out.println("[" + coord1.getValue() + "," + middleCoord.getValue() + "[" + ",[" +                middleCoord.getValue() + "," + coord2.getValue() + "[");            nbOfSplit--;        } //    LexicographicCoordinate.generate(8) ;    }   }