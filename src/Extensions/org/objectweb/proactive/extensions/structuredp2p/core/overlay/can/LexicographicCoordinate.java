package org.objectweb.proactive.extensions.structuredp2p.core.overlay.can;import java.util.ArrayList;/** *  * @author Filali Imen */@SuppressWarnings("serial")public class LexicographicCoordinate extends Coordinate {    /**     * Constructor.     *      * @param value     */    public LexicographicCoordinate(String value) {        super(value);    }    /**     * Compute the position of the decimal separator. The position is given by the coordinate that     * has the shortest string length     *      * @param coord1     *            the first coordinate.     * @param coord2     *            the second coordinate.     * @return the position of the decimal separator     */    public long getIndexOfDecimalSeparator(Coordinate coord1, Coordinate coord2) {        return (Math.min(coord1.getValue().length(), coord2.getValue().length()));    }    /**     * Returns the pairwise sum of the code points values.If the two code point lists do not have     * the same size the remaining elements of the longest list are append at the end.     *      * @param codePtsStr1     *            unicode code point list of characters in the first string.     * @param codePtsStr2     *            unicode code point list of characters in the second string.     * @return the sum of unicode code point values.     */    public static ArrayList<Integer> sumUnicodeCodePoints(ArrayList<Integer> codePtsStr1,            ArrayList<Integer> codePtsStr2) {        ArrayList<Integer> sumCodePoints = new ArrayList<Integer>();        int minLen = Math.min(codePtsStr1.size(), codePtsStr2.size());        int maxL = Math.max(codePtsStr1.size(), codePtsStr2.size());        for (int i = 0; i < minLen; i++) {            sumCodePoints.add(codePtsStr1.get(i) + codePtsStr2.get(i));        }        // TODO refactor        if (codePtsStr1.size() > codePtsStr2.size()) {            sumCodePoints.addAll(sumCodePoints.size(), codePtsStr1.subList(minLen, maxL));        } else {            sumCodePoints.addAll(sumCodePoints.size(), codePtsStr2.subList(minLen, maxL));        }        return (sumCodePoints);    }    /**     * Returns the middle coordinate of two Lexicographic Coordinates.     *      * @param coord1     *            the first coordinate.     * @param coord2     *            the second coordinate.     * @return the middle coordinate.     */    public Coordinate getMiddleWith(Coordinate coord2) {        ArrayList<Integer> codePtsStr1 = LexicographicCoordinate.fromCoordinateToUnicode(this);        ArrayList<Integer> codePtsStr2 = LexicographicCoordinate.fromCoordinateToUnicode(coord2);        ArrayList<Integer> sumCodePoints = LexicographicCoordinate.sumUnicodeCodePoints(codePtsStr1,                codePtsStr2);        // computes the middle code point value for each character element        ArrayList<Integer> middleChrCodePts = LexicographicCoordinate.getMiddleUnicodes(sumCodePoints);        return (new LexicographicCoordinate(LexicographicCoordinate.fromUnicodeToCoordinate(middleChrCodePts)));    }    /**     * It returns the unicode code points values for the specified coordinate.     *      * @param Coord     *            the lexicographic coordinate.     * @return the list of unicode code points values of characters belonging to the lexicographic     *         coordinate.     */    public static ArrayList<Integer> fromCoordinateToUnicode(Coordinate coord) {        ArrayList<Integer> codePtArray = new ArrayList<Integer>();        for (int i = 0; i < coord.getValue().length(); i++) {            int codePt = coord.getValue().codePointAt(i);            codePtArray.add(codePt);        }        return (codePtArray);    }    /**     * Returns the string value from the unicode code point values.     *      * @param middleChrCodePts     *            middle code point arrays value.     * @return the coordinate string value.     */    public static String fromUnicodeToCoordinate(ArrayList<Integer> codePoints) {        String s = "";        for (int i = 0; i < codePoints.size(); i++) {            int c = codePoints.get(i);            s += (char) c;        }        return s;    }    /**     * Returns the middle of elements in the unicode code point list. If the remainder is not     * <code>null</code>, it will be concatenated with the next element if it exists otherwise it     * will be appended at the end. This list will be used to retrieve the string value of the     * middle coordinate from its code point values.     *      * @param codePoints     *            the code points values.     * @return the unicode code points list.     */    public static ArrayList<Integer> getMiddleUnicodes(ArrayList<Integer> codePoints) {        ArrayList<Integer> middleChrCodePts = new ArrayList<Integer>();        int cp;        for (int j = 0; j < codePoints.size(); j++) {            cp = codePoints.get(j);            int d = cp / 2;            int remainder = cp % 2;            middleChrCodePts.add(d);            if (remainder != 0) {                // shift the remainder to the next element                if ((j + 1) < codePoints.size()) {                    String s = remainder + "" + codePoints.get(j + 1);                    int newCodePoint = Integer.parseInt(s);                    codePoints.set(j + 1, newCodePoint);                    // codePoints.set(j+1,codePoints.get(j+1)+remainder) ;                } else {                    middleChrCodePts.add(d);                }            }        }        return (middleChrCodePts);    }    /**    *     *     */    public String printInformation(ArrayList<?> l) {        String s = "|";        for (int i = 0; i < l.size(); i++) {            s += l.get(i) + "|";        }        return (s);    }    public int compareTo(Coordinate coord) {        return super.getValue().compareTo(coord.getValue());    }    // public static ArrayList<Integer> getUnicodeCodePoints(LexicographicCoordinate coord) {    // ArrayList<Integer> codePtArray = new ArrayList<Integer>();    // for (int i = 0; i < coord.getValue().length(); i++) {    // int codePt = coord.getValue().codePointAt(i);    // codePtArray.add(codePt);    // }    // return (codePtArray);    // }    // private static String middleCoordinateValue(ArrayList<Integer> middleChrCodePts) {    // String s = "";    // for (int i = 0; i < middleChrCodePts.size(); i++) {    // int c = middleChrCodePts.get(i);    // s += (char) c;    // }    // return s;    // }    public static void main(String[] args) {        // test successive splitting        Coordinate coord1;        Coordinate coord2 = new LexicographicCoordinate("m");        Coordinate middleCoord = new LexicographicCoordinate("a");        int nbOfSplit = 3;        while (nbOfSplit > 0) {            coord1 = new LexicographicCoordinate(middleCoord.getValue());            middleCoord = middleCoord.getMiddleWith(coord2);            System.out.println("[" + coord1.getValue() + "," + middleCoord.getValue() + "[" + ",[" +                middleCoord.getValue() + "," + coord2.getValue() + "[");            nbOfSplit--;        }    }}