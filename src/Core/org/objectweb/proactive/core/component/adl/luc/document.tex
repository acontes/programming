%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass{article}



\usepackage{listings}
\lstset{numbers=left}
\lstset{numberstyle=\footnotesize}

\usepackage{url}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\xml}[1]{\textsl{#1}}
\newcommand{\urll}[1]{\begin{center}\url{#1}\end{center}}


\title{A new factory for Fractal/GCM}
\author{}
\begin{document}
\maketitle

{\footnotesize
\tableofcontents
}
\newpage


The aim of this document is to provide developers and users with sufficient documentation for the new Fractal/GCM factory
for a seemles

\section{Introduction}

\subsection{Context}

In a few words, this work consists in the design and implementation of a new component factory for
the GCM component-based grid architecture, which is a extension of the Fractal specification, and whose
ProActive constitutes the only implementation available today.


\subsubsection{Fractal}

According to its authors, Fractal is a modular, extensible and programming language agnostic component model  that can be used to design, implement, deploy and reconfigure systems and applications, from operating systems to middleware platforms and to graphical user interfaces.
\urll{http://fractal.ow2.org/}
Fractal is mostly a Research system which gathers a large community of people working on various aspect of the component-oriented
paradigm.



\subsubsection{ProActive}

According to its authors (OASIS Research team)
ProActive is a GRID Java library for parallel, distributed, and concurrent computing, also featuring mobility and security in a uniform framework.
ProActive runs on Local Area Network (LAN), on clusters of workstations, or on Internet Grids.
\urll{http://proactive.inria.fr/}

\subsubsection{GCM}

GCM is\ldots

\subsubsection{ADL and the component factory}


ADL stands for Architecture Description Language. Altought its semantic incorrectness, one usually refers to
ADL as \textit{architecture description}.

The ADL enables the description of a component system. In the particular case of Fractal,
the component system is a tree, hence the adequation of XML (note that Fractal's ADL supposedly do
 not depend on XML).

The XML dialect introduced with Fractal as its ADL makes use of a variety of
elements and attributes. 
A basic tutorial for ADL syntax can be found at the following web URL:
\urll{http://fractal.ow2.org/tutorials/adl/index.html}

Basically, an ADL description looks like that:
\begin{tiny}
\begin{lstlisting}
<definition name="luc.demo.ExampleComponent">
  <interface name="r" role="server" signature="luc.demo.ExampleComponent"/>
  <component name="impl">
    <interface name="s" role="server" signature="luc.demo.ExampleComponent"/>
    <content class="luc.demo.BasicExampleComponent"/>
  </component>
  <binding client="this.r" server="impl.s" />
</definition>
\end{lstlisting}
\end{tiny}


Fractal assumes that the ADL description
is not stored in a file but in a Java resource, whereas it should be stored in a standard file,
at least for the sake
of independance to Java. In spite of it, Fractal's way of referring to an ADL resource is to
call it an \textit{ADL file}.


The component factory of Fractal is a piece of code within Fractal whose the role  is to build a component out of its XML
description. 
GCM comes with its own factory which is an extension of the Fractal factory.

The implementation of the Fractal factory is cumbersome: it consists of  about 150 Java classes and configuration files.
organized in numerous packages.
Besides, in order to implement is own extensions, GCM adds about 40 classes and description files.


\subsection{Description of the problem}
The Fractal factory (and its derivative) suffer from a number of problems, 
which lead to high frustration when it comes to deal with it.
\begin{itemize}
  \item its design involves way more concepts than necessary, most often these concepts are imprecise;
  \item its design is made of numerous anti-intuitive constructs;
  \item its implementation code is made of many tricks;
  \item it comes with no documentation, be it at the level of the code or at the level of the conception.
\end{itemize} 

The objective of the new factory is then to make a factory that is shorter, cleaner,
easier to understand/modify, and faster than the original Fractal/GCM factory. It particular, in order to avoid confusion,
we intend to use as little concepts as they are stricly necessary. Also, we plan to
document it so as a new user involved in its development/extension will have a minimal amount of stress getting into the code.


\subsection{Compliance with previous work}

On the one hand, the new factory must be able to load ADL files as they are described by the Fractal and GCM specifications.
It must also take into account extensions which are not part of official standard but which are of interest 
for the Oasis Research team. Non-official extensions which are not of interest for Oasis should not be
considered, unless the new factory is foreseen as a replacement of the default factory within Fractal.
In such case, the authors of these extensions should be asked a contribution to porting their code.

On the other hand, the new factory may introduce constructs which constitute improvements over the GCM ADL in its current version.
As such, ADL definitions tailored for the new factory may not be loadable by the default GCM factory.

Also  the new factory may expose a different API that than the default GCM factory, considering that the new API
suits better its very purpose.


\section{Design of the new factory}
The new factory is object-oriented (which does not mean that everything in it is object). Its design objective is to use an adequate tradeoff between {\em modularity} (which
leads to large architectures) and {\em simplicity} (which often leads to a lack of modularity)


\subsection{Input format}


The input of the factory comes in the form of files on the disk.

This constitute a difference with the original factory which requests as input 
an ADL file as well as a \textit{context} aimed at stored unspecified information.


\subsubsection{Passing arguments to the factory}
%The arguments values are described in a file as a set of $key=value$ pairs. The format
%of the argument file is then:
%\begin{center}
%$k_1 = v_1$ \\
%$k_2 = v_2$ \\
%...  \\
%$k_n = v_n$
%\end{center}
%Java programmers will notice that the syntax is the one used for \textit{properties} files.

%The name of the argument files is passed to the factory \code{newComponent()} method.

\subsubsection{Deployment descriptor}


\subsection{Architecture}


\subsubsection{Files}

The new factory is made of 8 Java source files, organized in 2 packages.

\begin{description}
\item[\code{xmlheader.txt}] \dotfill the header of the XML file, which includes the DTD specification. This header will be
	automatically inserted at the beginning of the XML text right before parsing.

\item[\code{NewFactory.java}] \dotfill This is where everything happens. If you want to extend behavior, you need to derive this class.

\item[\code{description/AttributeDescription.java}]  \dotfill Attr description
\end{description}

\subsubsection{Lexical analysis: from XML to DOM}

XML parsing to DOM is done by the parser built-in into the Java Development Kit.
Because DOM structures are not handy to manipulate, the parsing process goes a little
further: it converts the DOM structure into a  lightweight custom tree structure whose the
basic signature is:

\begin{lstlisting}
class XMLNode
{
	String getName();
	Map<String, String> getAttributes();
	List<XMLNode> getChildrenNodes();
}
\end{lstlisting}
which is more convenient to use than the general purpose DOM data structure.

\subsubsection{Semantic analysis: from DOM to semantic description}

Each XML element type into the ADL description is represented by a  \code{Description} class.
Because every XML element declaration refer to a specific concept, each of these concept is represented
as a specific sub-class of the \code{Description} class.
Then at runtime, each XML element is represented as an instance of a sub-class of the class  \code{Description}, as follows:
\begin{description}
\item[\xml{definition} and \xml{component}] respectively describe  the root component of the component tree;
and a sub-component of a given component; they are both represented by the class \code{ComponentDescription};
\item[\xml{interface}] describes an interface of a given component, it is represented by the class \code{InterfaceDescription};
\item[\xml{binding}] describes an interface binding involving two interfaces of two parent/child components;
it is represented by the class \code{BindingDescription};
\item[\xml{attributes}] describes attributes in a given components; it is represented by the class \code{AttributesDescription};
\item[\xml{content}] describes the content class for the implementation code of a given component. It is
{\em not} represented by any description. Instead it is represented as a field into the class \code{ComponentDescription}.
\end{description}

The creation of the description is carried on by static methods in the sub-class of the class \code{Description}.
Each of these static method is in charge of creating the description object for the host class.

\subsubsection{Component creation: from semantic description to components}

The creation of the component out of the semantic description of the component system is done
using Fractal and GCM APIs. Because of this, components created by the new factory are of the very same
nature than those created by the original factory. They can perfectly interoperate.

All the code is located in the class \code{NewFactory}.


\section{Proposals for a better ADL}

The ADL as it comes from the Fractal specifications presents a number of weaknesses and imprecisions.
For example, it is not clear that the \xml{definition} element is intrinsiquely different from the \xml{component} one.
Also, the usefulness of the \xml{arguments} attribute within a \xml{definition} element is to be discussed.
This section addresses these imprecisions and proposes a number of enhancements of the ADL.


\subsection{The DTD declaration is no longer required}

It is not the responsibility of the XML file to declare which piece of software
will be in charge of validating it.
Instead the parser is aware of the structure constraints of the XML code.

\subsection{Storing the ADL in files rather than in Java resources}

CGM is implemented in Java. This said, the implementation language of a given software
should remain a detail to the user. In Fractal, the input data (the ADL file) is expected
to be a Java resource, making Fractal applications dependant of Java, even at the user-level. This somehow breaks the rule
that Fractal is a specification intended to be implemented in any language.

Instead, the input data should be expected to be a file.


\subsection{the \xml{definition} XML element}

A component is described by the use of the \xml{component} element, except at the root-level
where the component is to be referred as a  \xml{definition}. This choice probably comes
from the fact, reinforced by the use of a DTD, that the \xml{definition} element allows
extra attributes that the \xml{component} element does not. The \xml{arguments}  
attribute might be of these.


\subsection{the \xml{arguments} attribute}

Suppressing the \xml{arguments} attribute into component description element.

\subsection{the \xml{content} XML element}

In the description of a component, only one \xml{content} element is allowed, and this element accepts
only one attribute, the \xml{class} attribute. 

\begin{lstlisting}
<component name="boh">
	...
	<content class="java.util.ArrayList" />
	...
</component>
\end{lstlisting}


Instead, the content information for a component should be expressed as
an attribute in the \texttt{component} description.

\begin{lstlisting}
<component name="boh" content="java.util.ArrayList">
	...
</component>
\end{lstlisting}

\section{How to\ldots}

\subsection{Perform a new verification}

Verifications are all performed in the \code{check()} method of the \code{Description}
class. Depending on the description you want to perform the verification (component, interface, etc),
you will have to look into the corresponding description class (respectively \code{ComponentDescription},
\code{IntefaceDescription}, etc).

Adding a new verification consists in adding a line to the \code{check()} method. Typically, such line
is in the form:

\begin{lstlisting}
if (!condition)
	throw new ADLException("condition failed");
\end{lstlisting}

For convenience purpose, the use of the following construct is encouraged:

\begin{lstlisting}
Assertions.ensure(condition, "condition failed");
\end{lstlisting}



\subsection{Add a new attribute to an existing XML element}

As described in Section \ref{}, each element type is represented by a \code{description} class.
In turn, each attribute of the element is represented as a field into its corresponding \code{description} class.
Adding a new attribute consists then in adding a new field in this class.

In order to make the new attribute need to be considered by the semantic analyser, you need
to add a line of code into the corresponding method.



\subsection{Add a new XML element}

XML elements have a semantic corresponding description. To add a new XML element, you need to define such a description.

\begin{itemize}
  \item Mandatory attributes have no default value. They must be assigned at construction time.
  \item Optional attributes have a default value. They are reassigned only if they are explicity given by the user.
\end{itemize}

\subsubsection{Example: the interface element}

Mandatory attributes must be provided at construction time:
\begin{tiny}
\begin{lstlisting}
String name  = n.getAttributes().get("name");
Role role = n.getAttributes().get("role").equals("client") ? Role.CLIENT : Role.SERVER;
Class<?> signature = Clazz.findClassOrFail(n.getAttributes().get("signature"));
InterfaceDescription id = new InterfaceDescription(name, role, signature);
\end{lstlisting}
\end{tiny}


Optional elements are set right after construction, if the user provided a value of them:
\begin{tiny}
\begin{lstlisting}
if (n.getAttributes().get("contigency") != null)
{
	id.setContingency(n.getAttributes().get("contigency").equals("mandatory")
		? Contingency.MANDATORY : Contingency.OPTIONAL);
}
\end{lstlisting}
\end{tiny}


\subsection{Modify the way attributes values are processed}

XML attribute values are parsed by the method:

\code{String replaceArgument(String v, Map<String, String> argumentValues)}

method in the \code{Attributes} class.
Its default behavior is to replace the pattern \code{\$\{name\}} by the value of the $name$ argument by its value
found in the associative map \code{argumentValues}.

Override it to get the behavior you want.



\section{Features}
\subsection{Already supported}

The following features are already supported by the new factory:
\begin{itemize}
  \item component interfaces (singleton);
  \item component attributes;
  \item interface bindings;
  \item sub-components;
  \item ADL inheritance;
  \item ADL arguments (plus extra features);
\end{itemize}

\subsection{Under progress}
The following lists the features that are currently under development.
\begin{itemize}
  \item support for componentized membranes (Paul Naoumenko's topic);
  \item support for collection interfaces;
\end{itemize}

\subsection{Will be suppored in the future}
The following lists the features that are will be developed in the near future, ordered by importance.
\begin{enumerate}
  \item support for collection components (Amine Rouini's topic);
  \item support for shared components;
  \item support for bindings to web-services;
\end{enumerate}

\section{Conclusion and future works}



\end{document}
