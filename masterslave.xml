<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<chapter id="masterslave">
	<title>Master/Slave API</title>

	<para>The outline of this short handbook:</para>

	<orderedlist>
		<listitem>
			<para>
				<link linkend="ms_overview">Introduction</link>
			</para>
		</listitem>

		<listitem>
			<para>
				<link linkend="ms_principle">Principle and Usage</link>
			</para>
		</listitem>

		<listitem>
			<para>
				<link linkend="ms_api">The API Description</link>
			</para>
		</listitem>

		<listitem>
			<para>
				<link linkend="ms_example">A Simple Example</link>
			</para>
		</listitem>
		
	</orderedlist>

	<sect1 id="ms_overview">
		<title>Overview</title>

		<para>
			Master/Slave computations are the most common case of
			distributed computations. They are often described as
			"embarassingly parallel problems", which means that no
			particular effort is needed to segment the problem into a
			very large number of parallel tasks, and there is no
			essential dependency (or communication) between those
			parallel tasks.
		</para>

		<para>
			The main goal of this Master/Slave API is to provide an
			easy to use framework to parallelize these embarassingly
			parallel applications.
		</para>

		<para>The main features are:</para>

		<itemizedlist>
			<listitem>
				<para>
					Automatic scheduling of tasks to the slaves.
				</para>
			</listitem>

			<listitem>
				<para>
					Automatic load-balancing between the slaves.
				</para>
			</listitem>

			<listitem>
				<para>
					Automatic fault-tolerance mechanism (i.e. when a
					slave is missing, the task is rescheduled).
				</para>
			</listitem>

			<listitem>
				<para>
					Very simple mechanism of solution gathering.
				</para>
			</listitem>

			<listitem>
				<para>
					All internal concepts of ProActive are hidden from
					the user.
				</para>
			</listitem>

			<listitem>
				<para>Open API for extensions.</para>
			</listitem>
		</itemizedlist>

	</sect1>

	<sect1 id="ms_principle">
		<title>The Master/Slave API Principles and Usage</title>

		<para>
			The usage of the Master/Slave API is simple and it consists
			basically of three steps:
		</para>
		<orderedlist>
			<listitem>
				<para>Deployment of the master/slave framework.</para>
			</listitem>

			<listitem>
				<para>Task definition and submission.</para>
			</listitem>

			<listitem>
				<para>Results gathering.</para>
			</listitem>
		</orderedlist>

		<sect2 id="ms_principle_deployment">
			<title>Deployment of the master/slave framework</title>

			<para>
				<figure>
					<title>
						Deployment of the master/slave framework
					</title>

					<mediaobject>
						<imageobject>
							<imagedata
								fileref="images/MasterSlave1.png" format="PNG"
								contentwidth="100" width="6in" />
						</imageobject>
					</mediaobject>
				</figure>
			</para>

			<para>
				The deployment of the Master/Slave framework relies on
				the ProActive deployment mechanism. In order to allow
				the master to deploy some slaves you will need to
				provide him either:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						A ProActive deployment descriptor : in this case
						the framework will use the descriptor to deploy
						its resources.
					</para>
				</listitem>
				<listitem>
					<para>
						Already deployed Proactive resources (a
						VirtualNode object or a Collection of Node
						objects).
					</para>
				</listitem>
			</itemizedlist>
		</sect2>
		<sect2 id="ms_principle_submission">
			<title>Tasks definition and submission</title>

			<para>
				<figure>
					<title>Tasks definition and submission</title>

					<mediaobject>
						<imageobject>
							<imagedata
								fileref="images/MasterSlave2.png" format="PNG"
								contentwidth="100" width="6in" />
						</imageobject>
					</mediaobject>
				</figure>
			</para>

			<para>
				In order to submit tasks to the Master, the Task
				interface from the Master/Slave API needs to be
				implemented. In this interface, the unique method "run"
				will correspond to the code being executed remotely.
				After tasks have been submitted to him, the master will
				dispatch tasks automatically to the slaves.
			</para>
		</sect2>
		<sect2 id="ms_principle_gathering">
			<title>Results gathering</title>

			<para>
				<figure>
					<title>Results gathering</title>

					<mediaobject>
						<imageobject>
							<imagedata
								fileref="images/MasterSlave3.png" format="PNG"
								contentwidth="100" width="6in" />
						</imageobject>
					</mediaobject>
				</figure>
			</para>

			<para>
				Results will be collected by the master when the
				calculations are complete. The user will collect the
				results from the master directly. Two modes are
				available for collecting the results :
				<itemizedlist>
					<listitem>
						<para>
							Unordered mode : in this mode, the user will
							collect the results in an unspecified order,
							depending on tasks completion order.
						</para>
					</listitem>
					<listitem>
						<para>
							Ordered mode : in this mode, the user will
							collect the results in the same order as the
							order used during task submission.
						</para>
					</listitem>
				</itemizedlist>

				The figures below explain the two different modes :
				<figure>
					<title>Unordered mode</title>

					<mediaobject>
						<imageobject>
							<imagedata fileref="images/MSResult1.png"
								format="PNG" contentwidth="100" width="6in" />
						</imageobject>
					</mediaobject>
				</figure>
				<figure>
					<title>Ordered mode</title>

					<mediaobject>

						<imageobject>
							<imagedata fileref="images/MSResult2.png"
								format="PNG" contentwidth="100" width="6in" />
						</imageobject>
					</mediaobject>
				</figure>
			</para>
		</sect2>
	</sect1>

	<sect1 id="ms_api">
		<title>The API Details</title>
		
		<sect2>
			<title>Master creation and deployment</title>		
			
<programlisting lang="java">    /**
     * Creates a master with a collection of nodes
     * @param nodes
     */
    public ProActiveMaster(Collection&lt;Node&gt; nodes);

    /**
     * Creates a master with a descriptorURL and an array of virtual node names
     * @param descriptorURL
     * @param virtualNodeNames
     */
    public ProActiveMaster(URL descriptorURL, String virtualNodeName);

    /**
     * Creates a master with the given virtual node
     * @param virtualNode
     */
    public ProActiveMaster(VirtualNode virtualNode);</programlisting>
			<para>
				This allows to create a master and deploy it using different schemes (through a Descriptor, through already deployed ProActive resources,etc ...).
			</para>
		</sect2>

		<sect2>
			<title>Task Definition</title>
			
<programlisting lang="java">public interface Task&lt;R extends Serializable&gt; extends Serializable {
    /**
     * A task to be executed
     * @param memory access to the slave memory
     * @return the result
     * @throws Exception
     */
    public R run(SlaveMemory memory) throws Exception;
}</programlisting>

			<para>
				A user needs only to implement the
				<emphasis role="bold">Task</emphasis>
				interface to define his task. The <emphasis role="bold">SlaveMemory</emphasis> parameter can allow an user to store some data in the slave directly. Another task can then retreive the same data later on. This is useful, for example, when one wants to reuse a database connection and save starting a new connection over and over again.   
			</para>
		</sect2>

		<sect2>
			<title>Task submission</title>	
			
<programlisting lang="java">    /**
     * Adds a collection of tasks to be solved by the master
     * Note that is a collection of tasks is submitted in one mode, it's impossible to submit tasks in a different mode until all the results have been retrieved (i.e. the master is empty)<br/>
     * @param tasks collection of tasks
     * @param ordered do we want to collect the results in the same order ?
     * @throws IllegalArgumentsException if the mode is changed or if a task is submitted twice
     */
    public void solve(Collection&lt;T&gt; tasks, boolean ordered)
        throws IllegalArgumentException;</programlisting>
			<para>
				For task submission, one single method is used. The ordered or unordered mode is chosen when tasks are submitted and can't be changed afterwards (subsequent calls to solve need to keep the same mode).
				When all results have been gathered from one serie of tasks and the master becomes "empty", the mode can then be set differently.
			</para>
		</sect2>
		
		<sect2>
			<title>Collecting results</title>
			
<programlisting lang="java">    /**
     * Wait for all results, will block until all results are computed
     * The ordering of the results depends on the mode used when submitted
     * @return a collection of objects containing the result
     * @throws IllegalStateException if no task have been submitted
     * @throws TaskException if a task threw an Exception
     */
    public Collection&lt;R&gt; waitAllResults()
        throws IllegalStateException, TaskException;
    /**
     * Wait for the first result available
     * Will block until at least one Result is available.
     * Note that in ordered mode, the method will block until the next result in submission order is available
     * @return an object containing the result
     * @throws IllegalStateException if no task have been submitted
     * @throws TaskException if the task threw an Exception
     */
    public R waitOneResult() throws IllegalStateException, TaskException;

    /**
     * Tells if all results are available
     * @return the answer
     * @throws IllegalStateException if no task have been submitted
     */
    public boolean areAllResultsAvailable() throws IllegalStateException;

    /**
     * Tells if there's any result available
     * Note that if the gathering mode is set to "ordered", the method will answer true if and only if the next task in the serie is available.
     * @return the answer
     * @throws IllegalStateException if no task have been submitted
     */
    public boolean isOneResultAvailable() throws IllegalStateException;
    
    /**
     * Tells if the master has no more results to provide (useful in conjunction with waitOneResult)
     * @return the answer
     */
    public boolean isEmpty();</programlisting>
			<para>
				Five methods can be used in order to collect results:
				<itemizedlist>
					<listitem>
						<para>
						The first two method will block the current thread until the corresponding result(s) is(are) available.
						If an exception occurs during the execution of one task, this exception will be thrown back to the user by the wait methods.  
						</para>
					</listitem>
					<listitem>
						<para>
						The second two methods will give indications on results availability but will not block the user thread.
						</para>
					</listitem>
					<listitem>
						<para>
						The last method will tell when the master have given back all the results from the tasks that have been submitted.
						</para>
					</listitem>  
				</itemizedlist>
			</para>
		</sect2>
		
		<sect2>
			<title>Terminating the master</title>
			<programlisting lang="java">
    /**
     * Terminates the master and (eventually free every resources) <br/>
     * @param freeNodeResources tells if the master should as well free the node resources
     * @return success
     */
    public void terminate(boolean freeResources);</programlisting>
			<para>
			One single method is used to terminate the master. A boolean parameter tells the master to free resources or not (i.e. terminate remote JVMs).  
			</para>
		</sect2>		
	</sect1>

	<sect1 id="ms_example">
		<title>A Simple Example</title>

		<para>
			This very simple example tells if a number is prime or not. 
			
			the complete example is available, along with more complex ones under package:
		</para>
		<screen>org.objectweb.proactive.examples.masterslave</screen>
		
		<para>
			First the task class definition, it tests if any number of a given interval divides the prime candidate 
		</para>
<programlisting lang="java">    public static class FindPrimeTask implements Task&lt;Boolean&gt; {
        private long begin;
        private long end;
        private long prime;

        public FindPrimeTask(long prime, long begin, long end) {
            this.begin = begin;
            this.end = end;
            this.prime = prime;
        }

        /* (non-Javadoc)
         * @see org.objectweb.proactive.extra.masterslave.interfaces.Task#run(org.objectweb.proactive.extra.masterslave.interfaces.SlaveMemory)
         */
        public Boolean run(SlaveMemory memory) {
            for (long divider = begin; divider &lt; end; divider++) {
                if ((prime % divider) == 0) {
                    return new Boolean(false);
                }
            }
            return new Boolean(true);
        }
    }</programlisting>
    
		<para>
			Then the main method, first the command_line parameters are interpreted and the master is created using a deployment descriptor :
		</para>
		
<programlisting lang="java">    public static void main(String[] args)
        throws TaskException, MalformedURLException {
        NativeExample instance = new NativeExample();
        //   Getting command line parameters
        instance.init(args, 2, " prime_to_find number_of_intervals");

        //      Creating the Master
        ProActiveMaster&lt;FindPrimeTask, Boolean&gt; master = new ProActiveMaster&lt;FindPrimeTask, Boolean&gt;(instance.descriptor_url,
                instance.vn_name);</programlisting>
        <para>
			Then the tasks are created and submitted to the master.
		</para> 

<programlisting lang="java">        // Creating the tasks to be solved
        List&lt;FindPrimeTask&gt; tasks = new ArrayList&lt;FindPrimeTask&gt;();
        long square_root_of_candidate = (long) Math.ceil(Math.sqrt(
                    prime_to_find));
        for (int i = 0; i &lt; number_of_intervals; i++) {
            tasks.add(new FindPrimeTask(prime_to_find,
                    square_root_of_candidate / (number_of_intervals / i),
                    square_root_of_candidate / (number_of_intervals / (i + 1))));
        }
        long startTime = System.currentTimeMillis();
        // Submitting the tasks
        master.solveAll(tasks, false);</programlisting>
        
        <para>
			Then the results are gathered and some statistics are displayed.
		</para> 

<programlisting lang="java">        // Collecting the results
        Collection&lt;Boolean&gt; results = master.waitAllResults();
        long endTime = System.currentTimeMillis();
        
        // Post processing, calculates the statistics
        boolean prime = true;

        for (Boolean result : results) {
            prime = prime && result;
        }

        long effective_time = (int) (endTime - startTime);
        //      Displaying the result
        System.out.println("" + prime_to_find +
            (prime ? " is prime." : " is not prime."));

        System.out.println("Calculation time (ms): " + effective_time);</programlisting>
        
        <para>
			Finally, the master is terminated (all resources are freed) and the program exits.
		</para> 

<programlisting lang="java">         //   Terminating the Master
        master.terminate(true);

        System.exit(0);
    }</programlisting>
	</sect1>
</chapter>