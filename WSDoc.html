
<html>
<head>
<title>Exporting Active Objects as web services</title>
<link rel="stylesheet" href="ProActive.css">
</head>
<body bgcolor="white">


<table width="100%">
<tr>
<td align="left" valign="middle">
    <table cellpadding="2" cellspacing="0" border="1">
    <tr>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="../../../../overview-summary.html">back to API</a>&nbsp;&nbsp;</td>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="index.html">back to index</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="MOP.html">prev</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="guided_tour/index.html">next</a>&nbsp;&nbsp;</td>
    </tr>
    </table>
</td>
<td  align="right" valign="top">
<img src="ProActiveLogo200x34.gif"/>
</td>
</tr>
</table>
<hr>
<!-- Link to index : end -->

<h1>Exporting Active Objects and components as web services</h1>


<h2>Overview</h2>
 <p class="textNormal">

This feature allows the call and monitoring of active objects and ProActive components  from any client written in any foreign language. <br>
Indeed, applications written in C#, for example, cannot communicate with
ProActive applications. 
We choose the web services technology that enable interoperability
because they are based on XML and HTTP.  Thus, any active object or
component can be accessible from any enabled web service language.


<h2>Principles </h2> 
 <p class="textNormal">

A <b>web service</b> is a software entity, providing one or several
functionnalities, that can be exposed, discovered and
accessed over the network. Moreover, web services technology allows
heterogenous applications to communicate and exchange data in a
remotely way.  

In our case, the usefull elements, of web services are :
<ul>

<li> <b> The SOAP Message  </b> <br> 
The SOAP message is used to exchange XML based data over the
internet. It can be sent via HTTP and provides a serialization format
for communicating over a network.

</li>

<li> <b> The HTTP Server </b> <br> 
HTTP is the standard web protocol generally used over the 80 port. In order to receive
SOAP messages you need to install an HTTP server that will be
responsible of the data transfer. This server is not sufficient to
treat a SOAP request.</li>


<li> <b> The SOAP Engine </b> <br>
A SOAP Engine is the mechanism responsible of making transparent the
unmarshalling of the request and the marshalling of the
response. Thus, the service developer doesn't have to worry with SOAP. In our
case, we use Apache SOAP which is installed on a Jakarta Tomcat web
server. Moreover, Apache SOAP contains a web based administration tool
that permit to list, deploy and undeploy services.
</li>

<li> <b> The client</b> <br>
Client's role is to consume a web service. It is the producer of the
SOAP message. The client developer doesn't have to worry about how the service
is implemented.
</li>

</ul>

<br>
<img align="center" width="500" heigth="300" src="webservices/provider_en.gif" />
<center>
 <p class="textNormal">
<i>This figure shows the steps when a active object is called via SOAP.</i>
</center>


<h2>Pre-requisite : Installing the Web Server and the SOAP engine</h2>
 <p class="textNormal">
First of all, you need to install the Jakarta Tomcat web server here
and install it. You can find some documentation about it <a
href="http://apache.crihan.fr/dist/jakarta/tomcat-4/v4.1.31/bin/"> here </a>. <br>
You don't really have to do a lot of installation. Just
uncompress the archive.<br>
To start and stop the server, launch the start and the shutdown scripts in the bin directory. 

 <p class="textNormal">
We also use a SOAP engine which is the Apache SOAP engine, available
<a href="http://www.apache.org/dyn/closer.cgi/ws/soap/"> here </a>. This SOAP engine will be responsible of
locating and calling the service.<br>
To install Apache SOAP refer to <a href="http://ws.apache.org/soap/docs/install/index.html">the server-side instructions.</a>
 <p class="textNormal">
The SOAP Engine is now installed ! You can verify, after starting the
server that you access to the welcome page of Apache SOAP at : <a href="http://localhost:8080/soap/index.html">
http://localhost:8080/soap/index.html</a>.
 <p class="textNormal">
Now we have to install ProActive into this SOAP engine. For that, follow these steps :
<ul>
<li> Copy the ProActive.jar file into the $APACHE-SOAP/WEB-INF/lib/ </li>
<li> Replace the  $TOMCAT/webapps/soap/WEB-INF/web.xml by <a 
href="web.xml" > this one </a> </li>
</ul>


 <p class="textNormal">
<h2>Steps to expose an active object or a component as a web services</h2> 
 <p class="textNormal">
The steps for exporting and using  an active object as a web service are the
following :
<ul>
<li> Write your active object or your component in a classic way; for example:  
<pre>
A a = (A)ProActive.newActive("A", new Object [] {});
</pre>
</li>

<li> Once the element is created and activated, deploy it onto a web
server by using :
 <ul> 
   <li> For an active object : 
   <pre> <b>
ProActive.exposeAsWebService(Object o, 
                             String url, 
			     String urn, 
			     String [] methods);
			     </b>
   </pre>
   where :
   <ul>
   <li> <b> o </b>  is the active object </li>
   <li> <b> url </b> is the url of the web server; typically 
   http://localhost:8080.
   <li> <b> urn </b> is the service name which identify the active
   object on the server.
   <li> <b> methods </b> a String array containing the methods name
   you want to make accessible. If this parameter is null, all the
   public methods will be exposed.
   </ul>

   </li>
   
   <li> For a component :  
<pre>
  <b> Proactive.exposeComponentAsWebService(Component component,
	                                          String url, 
						  String
	                                          componentName);
						  </b>
</pre>
	where :
	<ul>
	<li><b> component </b> is the component whose interfaces will
	be exposed as web services</li>
	<li> <b> url </b> is the url of the web server; typically 
   http://localhost:8080. </li>
        <li> <b> componentName </b> is the name of the component. Each
	service available in this way will get a name composed by the
	component name followed by the interface name : <i>componentName_interfaceName</i>
	</ul>
   </li>
   
 </ul> 

</li>

</ul>


<h2> Undeploy the services </h2>
<p class="textNormal">
To undeploy an active object as a service, use the ProActive static
method :
<pre>
<b>ProActive.unExposeAsWebService ( String urn, String url ); </b>
</pre>
<p class="textNormal">
where :
<ul>
<li> <b> urn </b> is the service name </li>
<li> <b> url </b> the url of the server where the service is deployed </li> 
</ul>

<p class="textNormal"> 
To undeploy a component you have to specify the component name and the
component( needed to know the interfaces to undeploy) :
<pre>
<b>ProActive.unExposeAsWebService ( String componentName , String url,  Component component); </b>
</pre>

<h2> Accessing the services </h2>
<p class="textNormal">

Once the active object or the interfaces component  are  deployed, you can access it via any web service
enabled client ( such as C#). <br>
First of all, the client will get the WSDL file matching this
active object. This WSDL file is the "identity card" of the
service. It contains the web service public interfaces and its location.
Generally, WSDL files are used to  generate a proxy to the
service. For example, for a given service, say "compute" ,you can get the WSDL document at
<a href="http://localhost:8080/servlet/wsdl?id=compute">http://localhost:8080/servlet/wsdl?id=compute</a>.
<br>
Now that this client knows what and where to call the service, it will send a SOAP message to
the web server, the web server looks into the message and perform the
right call then returns the reply into another SOAP message to the client.

<h2> Limitations </h2>
<p class="textNormal">

Apache Soap supports all defined types in the SOAP 1.1
specification. All Java primitive types are supported but it is not
always the case for complex types. For Java Bean Objects, ProActive
register them in the Apache SOAP mapping registry, in order to use a
specific (de)serializer when such objects are exchanged. All is done
automatically, you don't have to matter about the registering of the
type mapping. 
However, if the methods attributes types or return types are Java Beans, you
have to copy the beans classes you wrote into the <code>$APACHE_SOAP_HOME/WEB_INF/classes</code>.

<h2> A simple example : Hello World </h2>
<h3>Hello World web service code </h3>
<p class="textNormal">
Let's start with a simple example, an Hello world active object
exposed as a web service :

<pre>
public class HelloWorld implements Serializable {

   public HelloWorld () {}

   public String helloWorld (String name) {
      return "Hello world !";
   }

   public static void main (String [] args) {
    
    try {
        HelloWorld hw = (HelloWorld)ProActive.newActive("HelloWorld", new Object []{});
	ProActive.exposeAsWebService(hw,
	"helloWorld","http://localhost:8080", new String [] { "helloWorld" }); 
   
    } catch (ActiveObjectCreationException e) {
            e.printStackTrace();
    } catch (NodeException e) {
            e.printStackTrace();
    }
   }
}
</pre>
<p class="textNormal">
The active object <code>hw</code> has been deployed as a web service on the web
server located at <code>"http://localhost:8080" </code>. The accessible service
method is <code>helloWorld</code>. <br>
Now that the server-side Web service is deployed, we can create a new
client application in Visual Studio .NET. <br>

<h3  > Access with Visual Studio </h3>
<a name="steps">  
<p class="textNormal">
In your new Visual Studio Project : 
</a>
<ul>
<li>In the Solution Explorer window, right-click References and click Add Web Reference.</li>
<li>In the address box enter the WSDL service address, for example :
<a href="http://localhost:8080/soap/servlet/wsdl?id=helloWorld">
http://localhost:8080/soap/servlet/wsdl?id=helloWorld </a>.When
clicking the "add reference" button, this will
get the service's WSDL and creates the specific proxy to the service.</li>
<li> Once the web reference is added, you can use the helloWorld
service as an object and perform calls on it :
<pre>
...
localhost.helloWorld hw = new localhost.helloWorld();
string s = hw.helloWorld ();
...
</pre>
</li>
</ul> 

<h2> C# interoperability : an example with C3D </h2>

<h3> Overview </h3>
 <p class="textNormal">
<a href="http://www-sop.inria.fr/oasis/ProActive/apps/c3d.html"> C3D
</a> is a Java benchmark application that measures the performance of
a 3D raytracer renderer distributed over several Java virtual machines
using ProActive. C3D is composed of several parts : the distributed
engine (renderers) and the dispatcher that is an active objet. This
dispactcher permits users to see the 3D scene and to
collaborate. Users can send messages and render command to this
dispatcher.
This enhancement of C3D is to send commands to the dispatcher from any
language. To perform such an enhancement, the Dispatcher object must
be exposed as a web service in order to a C# client for example 
controls it. Only one instruction  has been added in the main method :
<pre>

ProActive.exposeAsWebService (dispatcher, "C3DDispatcher",
                    "http://localhost:8080",  new String [] {
                    "rotateRight", "getPicture", "rotateLeft", "rotateUp",
                    "rotateDown", "getPixels", "getPixelMax", "waitForImage",
                    "spinClock", "spinUnclock", "addRandomSphere", "resetScene",
                    "registerWSUser", "unregisterWSUser"
                });
</pre>
 <p class="textNormal">
Once the dispatcher is deployed as a web service, we have a WSDL url :
                    <a
                    href="http://localhost:8080/soap/servlet/id=C3DDispactcher"
                    >
                    http://localhost:8080/soap/servlet/id=C3DDispactcher </a>
It will be usefull to construct the dispatcher client.

<h3> Access with a C# client </h3>
<p class="textNormal">
First of all, we have to generate the service proxy following <a
href="#steps"> the
steps</a> described for the hello world access. </br>
All the SOAP calls will be managed by the generated proxy
<code>localhost.C3DDispatcher </code>. 

<img align="center"  src="webservices/dispatcher_en.gif"/> 
<h3> Dispatcher methods calls and callbacks</h3>
 <p class="textNormal">
C# client registers to the C3D dispatcher and then can send commands. 
C3D is a collaborative application. Indeed, when a client performs a
call, all others users must be advised by the dispatcher. Although
dispatcher can contact ProActive applications, it cannot communicate
with other applications (it cannot initiate the communication). In
other words, the dispacher must communicate remotely with an
application witten in another language. <br>
The answer to this problem is to use .Net web service on the C# user
machine. Such a web service is waiting for callback requests that come
from dispatcher. When receiving a request, the service sends it to the
client via a .Net Remoting shared objet. Thus, when the .Net web
service receives a callback request, the C# client is updated thanks
to propagated events. 


<p class="textNormal">
Here are screenshots of the user application :
<table align="center">
<tr>
<td> <p class="textNormal"> The first screenshot is a classic ProActive application ; </td>
<td> <img width="800" src="webservices/scc3djava.jpg"> </td>
</tr>
<tr>
<td> This is the C# application that communicates via SOAP with the same dispatcher than the ProActive user uses. </td>
<td> <p class="textNormal"> <img width="800" src="webservices/scC3dcs.JPG"> </td>
</tr>
</table>

<h3>Download the C# example </h3>
<p class="textNormal">
You can find <a href="http://www-sop.inria.fr/oasis/proactive/C3DCSharp.zip"> here </a> the whole C# Visual Studio .Net project.
N.B : In order to run this project, you must install the Microsoft IIS server.

<!--
 Footer : start 
 -->
<br><hr><div align="right" class="textSmall">Copyright &#169; April 2005 INRIA All Rights Reserved.</p>
<!-- Footer : end -->
</body>
</html>
