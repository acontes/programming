<!-- saved from url=(0022)http://internet.e-mail -->
<html>
<head>
<title>OOSPMD</title>
<link rel="stylesheet" href="ProActive.css">
</head>
<body bgcolor="white">

<!--
 Header : start 
~~~ -->
<table width="100%">
<tr>
<td align="left" valign="middle">
    <table cellpadding="2" cellspacing="0" border="1">
    <tr>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="../../../../overview-summary.html">back to API</a>&nbsp;&nbsp;</td>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="index.html">back to index</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="TypedGroupCommunication.html">prev</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="Configuration.html">next</a>&nbsp;&nbsp;</td>
    </tr>
    </table>
</td>
<td  align="right" valign="top">
<img src="ProActiveLogo200x34.gif"/>
</td>
</tr>
</table>
<hr>
<!-- Link to index : end -->

<h1>OOSPMD</h1>

<h2>OOSPMD : Introduction</h2>
<p class="textNormal">
SPMD stands for Single Program Multiple Data. Merged into an
object-oriented framework, an SPMD programming model becomes an OOSPMD
programming model.
<br>
The typed group communication system can be used to simulate MPI-style
collective communication. Contrary to MPI that requires all members of
a group to collectively call the same communication primitive, our
group communication scheme let the possibility to one activity to call
a method on the group.
<br><br>
The purpose of the our group communication is to free the programmer
from having to implement the complex communication code required for
setting identical group in each SPMD activity, group communication,
thereby allowing the focus to be on the application itself.
<br><br>
This page presents the mechanism of typed group communication as an
new alternative to the old SPMD programming model. While being
placed in an object-oriented context, this mechanism helps the
definition and the coordination of distributed activities. The
approach offers, through modest size API, a better structuring
flexibility and implementation. The automation of key communication
mechanisms and synchronization simplifies the writing of the code.
<br><br>
The main principle is rather simple: an spmd group is a group of
active objects where each one has a group referencing all the active
objects.
</p>
<br>

<h2>SPMD Groups</h2>
<p class="textNormal">
An spmd group is a ProActive typed group built with the
<b>ProSPMD.newSPMDGroup()</b> method. This method looks like the
<b>ProActiveGroup.newGroup()</b>; they have similar behavior (and
overloads). The difference is that each members of an spmd group
have a reference to a group containing all the others members and
itself (i.e. a reference to the spmd group itself).
<br><br>

Given a standard Java class:
</p>
<blockquote><pre>
class A { 
  public A() {}
  public void foo (...) {...}
  public void bar (...) {...}
  ...
}
</pre></blockquote>

<p class="textNormal">
The spmd group is built as follow:
</p>
<blockquote><pre>
  Object[][] params = {{...} , {...} , ... }; 
  Node[] nodes  = { ... , ..., ... }; 

  A agroup = (A) ProSPMD.newSPMDGroup("A", params[], nodes); 
</pre></blockquote>

<p class="textNormal">
Object members of an spmd group are aware about the whole group. They
can obtain some informations about the spmd group they belong to such
as the size of the group, their rank in the group, and a reference to
the group in order to get more informations or to communicate with
method invocations. Those informations are respectively obtained using
the static methods <b>getMySPMDGroupSize()</b>, <b>getMyRank()</b>,
and <b>getSPMDGroup() </b> of the <b>ProSPMD</b> class.
</p>
<br>

<h2>Barrier : Introduction</h2>
<p class="textNormal">
ProActive provides three kinds of barrier to synchronize activities.
The feature is specially useful in a SPMD programming style. A barrier
stops the activity of the active object that invokes it until a special
condition is satisfied. Notice that, as the opposite of MPI or such
libraries, the ProActive barriers do not stop the current activity
immediately (when the <b>barrier</b> method is encountered).
The current method actually keeps on executing until the end. The barrier
will be activated at the end of the service: no other service will be
started until all the AOs involved in the barrier are at that same point.
<br><br>

The three barriers are named:</p>
<ul>
  <li>the <b>Total Barrier</b></li>
  <li>the <b>Neighbor Barrier</b></li>
  <li>the <b>Method-based Barrier</b></li>
</ul>

<p class="textNormal">Here is a presentation about how to use those barriers.</p>
<br>


<h2>Total Barrier</h2>
<p class="textNormal">

Total barrier directly involves the spmd group. A call to <b>barrier(String)</b>
will block until all the members in the spmd group have themselves reach and
called the identical <b>ProSPMD.barrier()</b> primitive. A call
communicates with all the members of the spmd group. The barrier is
released when the Active Object has received a <i>barrier message</i>
from all other members of the spmd group (including itself).
<br><br>

The string parameter is used as unique identity name for the barrier.
It is the programmer responsibility to ensure that two (or more)
different barriers with the same id name are not invoked simultaneously.
<br><br>

Let us take a Java class that contains a method calling a total
barrier, here the method <b>foo</b>:
</p>
<blockquote><pre>
class A { 
  public A() {}
  public void foo (...) {
    ...
    ProSPMD.barrier("MyBarrier");
  }
  public void bar (...) {...}
  ...
}
</pre></blockquote>

<p class="textNormal">
Note that usually, strings used as unique ID are more complex; they can be
based on the full name of the class or the package
(<b>org.objectweb.proactive.ClassName</b>), for example.

The spmd group is built as follow:
</p>
<blockquote><pre>
  Object[][] params = {{...} , {...} , ... }; 
  Node[] nodes  = { ... , ..., ... }; 

  A agroup = (A) ProSPMD.newSPMDGroup("A", params[], nodes); 
</pre></blockquote>

<p class="textNormal">Here the main method of our application:</p>
<blockquote><pre>
  agroup.foo();
  agroup.bar();
</pre></blockquote>

<p class="textNormal">
The call to <b>barrier</b> launched by all members (in the invocation
of <b>foo</b>) ensures that no one will initiate the <b>bar</b> method
before all the <b>foo</b> methods end.
<br><br>

The programmer have to ensure that <b>all the members of an spmd group
call the barrier method</b> otherwise the members of the group may
indefinitely wait.
</p>
<br>

<h2>Neighbor barrier</h2>
<p class="textNormal">

The Neighbor barrier is a kind of light weighted barrier,
involving not all the member of an spmd group, but only the Active
Objects specified in a given group.
<br><br>

<b>barrier(String,group)</b> initiates a barrier only with the objects
of the specified group. Those objects, that contribute to the end of
the barrier state, are called <i>neighbors</i> as they are usually
local to a given topology, An object that invoke the Neighbor barrier
HAVE TO BE IN THE GROUP given as parameter. The <i>barrier message</i>
is only sent to the group of neighbors.
<br><br>

The programmer has to explicitly build this group of neighbors. The topology API
can help him or her to build such group. Topologies are groups. They 
just give special access to their members or (sub)groups members. For
instance, a matrix fits well with the topology <b>Plan</b> that provides
methods to get the reference of neighbor members (<b>left</b>, <b>right</b>,
<b>up</b>, <b>down</b>). See the javadoc of the
<a href="../../../../org/objectweb/proactive/core/group/topology/package-summary.html">
topology package</a> for more informations.
<br><br>

Like for the Total barrier, the string parameter represents a unique
identity name for the barrier. The second parameter is the group of
neighbors built by the programmer. Here is an example:</p>

<blockquote><pre>
   ProSPMD.barrier("MyString", neighborGroup);
</pre></blockquote>

<p class="textNormal">
Refer to the <i>Jacobi</i> example to see a use of the Neighbor
barrier. Each submatrix needs only to be synchronized with the
submatrixes which it is in contact.
<br><br>

This barrier increases the asynchronism and reduce the amount of
exchanged messages.
</p>
<br>


<h2>Method Barrier</h2>

<p class="textNormal">
The Method barrier does no more involve extra messages to communicate
(i.e. the <i>barrier messages</i>). Communications between objects to
release a barrier are achieved by the standard method call and request
reception of ProActive.
<br><br>

The method <b>barrier(String[])</b> stops the active object that calls
it, and wait for a request on the specified methods to resume. The array
of string contains the name of the awaited methods. The order of the
methods does not matter. For example :
</p>

<blockquote><pre>
   ProSPMD.barrier({"foo", "bar", "gee"});
</pre></blockquote>

<p class="textNormal">
The caller will stop and wait for the three methods. bar or gee can
came first, then foo. If one wants wait for foo, then wait for bar,
then wait for gee, three calls can be successively done:</p>

<blockquote><pre>
   ProSPMD.barrier({"foo"});
   ProSPMD.barrier({"bar"});
   ProSPMD.barrier({"gee"});
</pre></blockquote>

<p class="textNormal">
A method barrier is used without any group (spmd or not).


To learn more, browse the <a href="../../../../index.html">JavaDoc</a>.
</p>
<!--
 Footer : start 
~~~ -->
<br><hr><div align="right" class="textSmall">Copyright &#169; April 2005 INRIA All Rights Reserved.</p>
<!-- Footer : end -->
</body>
</html>
