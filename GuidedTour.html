<html>
<head>
<title>Hello world ! example</title>
<link rel="stylesheet" href="ProActive.css">
</head>
<body bgcolor="white">

<!--
 Header : start 
~~~ -->
<table width="100%">
<tr>
<td align="left" valign="middle">
    <table cellpadding="2" cellspacing="0" border="1">
    <tr>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="../../../../overview-summary.html">back to API</a>&nbsp;&nbsp;</td>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="index.html">back to index</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="HelloWorld.html">prev</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="ProActiveBasis.html">next</a>&nbsp;&nbsp;</td>
    </tr>
    </table>
</td>
<td  align="right" valign="top">
<img src="ProActiveLogo200x34.gif"/>
</td>
</tr>
</table>
<hr>
<!-- Link to index : end -->

<h1>Tutorial</h1>
<p class="textNormal">
This example implements a very simple client-server application. A client object display a <code>String</code> got from a remote server.
We will see how to write classes from which active and remote objects can be created, how to find a remote object and how to invoke methods on remote objects.
</p>
<h2>The two classes</h2>
<p class="textNormal">
Only two classes are needed: one for the server object <code>Hello</code> and one for the client that accesses it <code>HelloClient</code>.
</p>
<h3>The Hello class</h3>
<p class="textNormal">
This class implements server-side functionalities. Its creation involves the following steps:
</p>
<ul class="listWithSpace">
<li class="textNormal">Provide an implementation for the required server-side functionalities</li>
<li class="textNormal">Provide an empty, no-arg constructor</li>
<li class="textNormal">Write a <code>main</code> method in order to instantiate one server object and register it with an URL.</li>
</ul>
<p class="textNormal">
Here is a possible implementation for the <code>Hello</code> class:
</p>
<br></br>
<table align="center" width="96%" border="1" cellpadding="5" cellspacing="0">
<tbody>
<tr>
<th align="center" bgcolor="#ccccff">Hello.java</th>
</tr>
<tr>
<td>
<pre>
public class Hello {

  private String name;
  private String hi = "Hello world";
  private java.text.DateFormat dateFormat = new java.text.SimpleDateFormat("dd/MM/yyyy HH:mm:ss");

  public Hello() {
  }

  public Hello(String name) {
    this.name = name;
  }

  public String sayHello() {
    return hi + " at " + dateFormat.format(new java.util.Date());
  }

  public static void main(String[] args) {
    // Registers it with an URL
    try {
      // Creates an active instance of class HelloServer on the local node
      Hello hello = (Hello)org.objectweb.proactive.ProActive.newActive(Hello.class.getName(), new Object[]{"remote"});
      java.net.InetAddress localhost = java.net.InetAddress.getLocalHost();
      org.objectweb.proactive.ProActive.register(hello, "//" + localhost.getHostName() + "/Hello");
    } catch (Exception e) {
      System.err.println("Error: " + e.getMessage());
      e.printStackTrace();
    }
  }
}
</pre>
</td>
</tr>
</tbody>
</table>
<br></br>


<h4>Implement the required functionalities</h4>
<p class="textNormal">
Implementing any remotely-accessible functionality is simply done through normal Java
methods in a normal Java class, in exactly the same manner it would have been done in a non-distributed version of the same class. This
has to be contrasted with the RMI approach, where several more steps are needed:
<ul class="listWithSpace">
<li class="textNormal">Define a remote interface for declaring the remotely-accessible methods.</li>
<li class="textNormal">Rewrite the class so that it inherits from <code>java.rmi.server.UnicastRemoteObject</code>, which is the root class of all remote objects.</li>
<li class="textNormal">Add remote exceptions handling to the code.</li>
</ul>
</p>

<h4>Why an empty no-arg constructor ?</h4>
<p class="textNormal">
You may have noticed that class <code>Hello</code> has a constructor with no parameters and an empty implementation. The presence of this empty no-arg
constructor is imposed by ProActive and is actually a side-effect of ProActive's implementation of transparent of active remote objects (as a matter of fact, this
side-effect is caused by ProActive being implemented on top of a 100% Java metaobject protocol). If no such constructor is provided, active objects could not be created.
<br></br>
If no constructor at all is provided, active objects can still be created because, in this specific case, all Java compilers provide
a default no-arg empty constructor. If a no-arg constructor is provided but its implementation is not empty, unwanted behavior may appear because the no-arg constructor
is always called when an active object is created, whatever code the user can write.
</p>

<h4>Creating the remote <code>Hello</code> object</h4>
<p class="textNormal">
Now that we know how to write the class that implements the required server-side functionalities, let us see how to create the server object. In ProActive, there is actually no difference
between a server and a client object as both are remote objects.Creating the active object is done through <i>instantiation-based creation</i>. We want
this active object to be created on the current node, which is why the last parameter of <code>newActive</code> is set to <code>null</code>. In
order for the client to obtain an initial reference onto this remote object, we need to register it in the registry (which is actually the well-known 
<code>rmiregistry</code>) with a valid RMI URL.
</p>

<h3>The <code>HelloClient</code> Class</h3>
The responsibility of this class is first to locate the remote server
object, then to invoke a method on it in order to retrieve a message,
and finally display that message.

<br></br>
<table align="center" width="97%" border="1" cellpadding="5" cellspacing="0">
<tbody>
<tr>
<th align="center" bgcolor="#ccccff">HelloClient.java</th>
</tr>
<tr>
<td>
<pre>
public class HelloClient {

  public static void main(String[] args) {
    Hello myServer;
    String message;
    try {
      // checks for the server's URL
      if (args.length == 0) {
        // There is no url to the server, so create an active server within this VM
        myServer = (Hello)org.objectweb.proactive.ProActive.newActive(Hello.class.getName(), new Object[]{"local"});
      } else {
        // Lookups the server object
        System.out.println("Using server located on " + args[0]);
        myServer = (Hello)org.objectweb.proactive.ProActive.lookupActive(Hello.class.getName(), args[0]);
      }
      // Invokes a remote method on this object to get the message
      message = myServer.sayHello();
      // Prints out the message
      System.out.println("The message is : " + message);
    } catch (Exception e) {
      System.err.println("Could not reach/create server object");
      e.printStackTrace();
      System.exit(1);
    }
  }
}
</pre>
</td>
</tr>
</tbody>
</table>
<br></br>



<h4>Looking up a remote object</h4>
<p class="textNormal">The operation of <i>lookup</i> simply means obtaining a reference onto an object from the URL it is
bound to. The return type of method <code>Proactive.lookupActive()</code> is <code>Object</code>, then we need to cast it down into the type of the
variable that holds the reference (<code>Hello</code> here). If no object is found at this URL, the call to <code>Proactive.lookupActive()</code> returns
<code>null</code>.
</p>

<h4>Invoking a method on a remote object</h4>
<p class="textNormal">
This is exactly like invoking a method on a local object of the same type. The user does not have to deal with catching
distribution-related exceptions like, for example, when using RMI or CORBA. Future versions of ProActive PDC will provide an
exception handler mechanism in order to process these exceptions in a separate place than the functional code. As class <code>String</code> is 
<code>final</code>, there cannot be any asynchronism here since the object returned from the call cannot be replaced by a
future object (this restriction on <code>final</code> classes is imposed by ProActive's implementation).
</p>

<h4>Printing out the message</h4>
<p class="textNormal">
As already stated, the only modification brought to the code by
ProActive PDC is located at the place where active objects are
created. All the rest of the code remains the same, which fosters
software reuse.
</p>

<h3>Hello World within the same VM</h3>
<p class="textNormal">
In order to run both the client and server in the same VM, the
client creates an active object in the same VM if it doesn't find
the server's URL. The code snippet which instantiates the Server
in the same VM is the following:
</p>

<pre>
if (args.length == 0) {
  // There is no url to the server, so create an active server within this VM
  myServer = (Hello)org.objectweb.proactive.ProActive.newActive(Hello.class.getName(), new Object[]{"local"});
}
</pre>

<p class="textNormal">
To launch the Client and the Server, just type:
</p>
<pre>
> java org.objectweb.proactive.examples.hello.Client &
</pre>

<h3>Hello World from another VM on the same host</h3>
<h4>Starting the server</h4>
Just start the <code>main</code> method in the <code>Hello</code> class.
<pre>
> java org.objectweb.proactive.examples.hello.Hello &
</pre>

<h4>Launching the client</h4>
<pre>
> java org.objectweb.proactive.examples.hello.HelloClient //localhost/Hello
</pre>

<h3>Hello World from abroad: another VM on a different host</h3>
<h4>Starting the server</h4>
Log on to the server's host, and launch the <code>Hello</code> class.
<pre>
remoteHost> java org.objectweb.proactive.examples.hello.Hello &
</pre>

<h4>Launching the client</h4>
Log on to the client Host, and launch the client
<pre>
clientHost> java org.objectweb.proactive.examples.hello.HelloClient //remoteHost/Hello
</pre>

<!--
 Footer : start 
~~~ -->
<br><hr><div align="right" class="textSmall">Copyright &#169; May 2003 INRIA All Rights Reserved.</p>
<!-- Footer : end -->
</body>
</html>
