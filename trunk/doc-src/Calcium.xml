<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<chapter id="Calcium">
  <title>High Level Patterns -- The Calcium Skeleton Framework</title>

  <sect1>
    <title>Introduction</title>

    <sect2>
      <title>About Calcium</title>

      <para>Calcium is part of the ProActive Grid Middleware for programming
      structured parallel and distributed applications. The framework provides
      a basic set of structured patterns (skeletons) that can be nested to
      represents more complex patterns. Skeletons are considered a high level
      programming model because all the parallelisms details are hidden from
      the programmer. In Calcium, distributed programming is achieved by using
      ProActive deployment framework and active object model.</para>
    </sect2>

    <sect2>
      <title>The Big Picture</title>

      <para>The following steps must be performed for programming with the
      framework.</para>

      <orderedlist>
        <listitem>
          <para>Define the skeleton structure.</para>
        </listitem>

        <listitem>
          <para>Implement the classes of the structure (the muscle
          codes).</para>
        </listitem>

        <listitem>
          <para>Create a new Calcium instance.</para>
        </listitem>

        <listitem>
          <para>Provide an input of problems to be solved by the
          framework.</para>
        </listitem>

        <listitem>
          <para>Collect the results.</para>
        </listitem>

        <listitem>
          <para>View the performance statistics.</para>
        </listitem>
      </orderedlist>

      <para>Problems inputed into the framework are treated as tasks. The
      tasks are interpreted by the remote skeleton interpreters as shown in
      the following Figure:</para>

      <figure>
        <title>Task Flow in Calcium</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/CalciumTaskFlow.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <indexterm></indexterm>
    </sect2>
  </sect1>

  <sect1>
    <title>Quick Example</title>

    <para>In this example we will implement skeleton that finds prime numbers
    for an interval of numbers using a naive approach.</para>

    <sect2>
      <title>Define the skeleton structure</title>

      <para>The approach we will use corresponds to dividing the original
      search space into several smaller search spaces. Therefore, the most
      suitable pattern corresponds to Divide and Conquer.</para>

      <screen><emphasis role="bold">// Dac(&lt;Divide&gt;,&lt;Condition&gt;,&lt;Skeleton&gt;,&lt;Conquer&gt;)
Skeleton</emphasis>&lt;Challenge,Primes&gt; root = new <emphasis role="bold">DaC</emphasis>&lt;Challenge,Primes&gt;( new ChallengeDivide(1),
                           new ChallengeDivideCondition(2), 
                           new <emphasis role="bold">Seq</emphasis>&lt;Challenge,Primes&gt;(new SolveChallenge(3)),
                           new ConquerChallenge(4));
        </screen>
    </sect2>

    <sect2>
      <title>Implementing the Muscle</title>

      <para>We will call the problem as <emphasis
      role="bold">Challenge</emphasis> and we will represent it using the
      following class.</para>

      <screen>class <emphasis role="bold">Challenge</emphasis> implements Serializable{

public int max, min, solvableSize;

    public Vector&lt;Integer&gt; primes;

    /**
     * Creates a new challenge for finding primes.
     * @param min  The minimum of the interval.
     * @param max  The maximum of the interval.
     * @param solvableSize The size of the problems to be solved.
     */
    public Challenge(int min, int max, int solvableSize){
        this.min=min;
        this.max=max;
        this.solvableSize=solvableSize;
        primes=new Vector&lt;Integer&gt;();
    }
}</screen>

      <para>The primes that are found will be stored in a <emphasis
      role="bold">Primes</emphasis> class.</para>

      <screen>public class <emphasis role="bold">Primes</emphasis> implements Serializable {

    public Vector&lt;Integer&gt; primes;

    public Primes(){
        primes=new Vector&lt;Integer&gt;();
    }
}</screen>

      <sect3>
        <title>Divide</title>

        <para>The divition of a Challenge into smaller internavls is handled
        by a <emphasis role="bold">ChallengeDivide</emphasis> class:</para>

        <screen>public class ChallengeDivide <emphasis role="bold">implements Divide</emphasis>&lt;Challenge, Challenge&gt;{
    
    public <emphasis role="bold">Vector&lt;Challenge&gt; divide(Challenge param)</emphasis> {
        
        Challenge ttUp = new Challenge(1+param.min+(param.max-param.min)/2,param.max,param.solvableSize);

        Challenge ttDown = new Challenge(param.min,param.min+(param.max-param.min)/2, param.solvableSize);
        
        Vector&lt;Challenge&gt; v = new Vector&lt;Challenge&gt;();
        v.add(ttUp);
        v.add(ttDown);
        
        return v;
    }
}</screen>
      </sect3>

      <sect3>
        <title>Condition</title>

        <para>The class <emphasis
        role="bold">ChallengeDivideCondition</emphasis> is used to determine
        if a Challenge must be subdivided or not.</para>

        <screen>public class ChallengeDivideCondition <emphasis role="bold">implements Condition&lt;Challenge&gt;</emphasis>{
    
    public <emphasis role="bold">boolean evalCondition(Challenge params)</emphasis> {
        
        return params.max-params.min &gt; params.solvableSize;
    }
}</screen>
      </sect3>

      <sect3>
        <title>Skeleton</title>

        <para>The SolveChallenge class performes the actual findinf of primes.
        This class wil recieve a Challenge and return </para>

        <screen>public class <emphasis role="bold">SolveChallenge implements Execute&lt;Challenge,Primes&gt;</emphasis>{

    public <emphasis role="bold">Primes execute(Challenge param) </emphasis>{
        Primes primes = new Primes();

        for(int i=param.min;i&lt;=param.max;i++){
            if(isPrime(i)){
                primes.add(new Integer(i));
            }
        }
        
        return primes;
    }
    //...
}</screen>
      </sect3>

      <sect3>
        <title>Conquer</title>

        <para>The ConquerChallenge class consolidates the result of the sub
        challenges into a single result.</para>

        <screen>public class ConquerChallenge <emphasis role="bold">implements Conquer&lt;Primes,Primes&gt;</emphasis>{
    
    public <emphasis role="bold">Primes conquer(Vector&lt;Primes&gt; p)</emphasis> {
            
        for(Challenge param:p){
            parent.max=Math.max(parent.max, param.max);
            parent.min=Math.min(parent.min, param.min);
            parent.primes.addAll(param.primes);
        }

        Collections.sort(parent.primes);
        return parent;
    }
}</screen>
      </sect3>
    </sect2>

    <sect2>
      <title>Create a new Calcium Instance</title>

      <para>The instantiation of the framework is performed in the following
      way</para>

      <screen>Skeleton&lt;Challenge&gt; root = ...; //Step 1
<emphasis role="bold">ResourceManager</emphasis> manager= new <emphasis
          role="bold">ProActiveManager</emphasis>(descriptor, "local");
<emphasis role="bold">Calcium</emphasis> calcium = new <emphasis role="bold">Calcium</emphasis>(manager);</screen>
    </sect2>

    <sect2>
      <title>Provide an input of problems to be solved by the
      framework</title>

      <para></para>

      <screen><emphasis role="bold">Stream</emphasis>&lt;Challenge, Primes&gt; stream = calcium.<emphasis
          role="bold">newStream</emphasis>(root);

Vector&lt;Future&lt;Primes&gt;&gt; futures = new Vector&lt;Future&lt;Primes&gt;&gt;();
futures.add(stream.input(new Challenge(1,6400,300)));
futures.add(stream.input(new Challenge(1,100,20)));
futures.add(stream.input(new Challenge(1,640,64)));

calcium.<emphasis role="bold">boot</emphasis>(); //begin the evaluation</screen>
    </sect2>

    <sect2>
      <title>Collect the results</title>

      <screen>for(Future&lt;Primes&gt; future:futures){
    Primes res=future.get();
    System.out.print(res);
}

calcium.<emphasis role="bold">shutdown</emphasis>(); //release the resources</screen>
    </sect2>

    <sect2>
      <title>View the performance statistics</title>

      <para></para>

      <screen><emphasis role="bold">Stats</emphasis> stats=future.get(0).<emphasis
          role="bold">getStats</emphasis>(res);
System.out.println(stats);</screen>
    </sect2>
  </sect1>

  <sect1>
    <title>Supported Patterns</title>

    <para>Skeletons can be composed in the following way:</para>

    <screen>S := farm(S)|pipe(S1,S2)|if(cond,S1,S2)|while(cond,S)|for(i,S)|D&amp;C(cond,div,S,conq)|map(div, S, conq)|fork(div, S1...SN, conq)|Seq(f)</screen>

    <para>Each skeleton represents a different parallelism described as
    follows:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Farm</emphasis> , also known as <emphasis
        role="bold">Master-Slave</emphasis>, corresponds to the task
        replication pattern where a specific function must be executed over a
        set of slaves.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Pipe</emphasis> corresponds to computation
        divided in stages were the stage n+1 is always executed after the n-th
        stage.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">If</emphasis> corresponds to a decision
        pattern, were a choice must be made between executing two
        functions.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">While</emphasis> corresponds to a pattern
        were a function is executed while a condition is met.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">For</emphasis> corresponds to a pattern
        were a function is executed a specific number of times.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Divide and Conquer</emphasis> corresponds
        to a pattern were a problem is divided into several smaller problems
        while a condition is met. The tasks are solved and then solutions are
        then conquered into a single final solution for the original
        problem.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Map</emphasis> corresponds to a pattern
        were the same function is applied to several parts of a problem:
        single instruction multiple data.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Fork</emphasis> models multiple data
        multiple instruction.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1>
    <title>Choosing a Resource Manager</title>

    <para>In Calcium, remote resources are acquired using ProActive's
    deployment framework in the following way:</para>

    <screen>ResourceManager manager = new <emphasis role="bold">ProActiveManager</emphasis>("descriptor/path/to/file.xml", "virtualNodeName");</screen>

    <para>Additionally, for debugging purposes, two other resource managers
    are available: MonoThreaded and MultiThreaded:</para>

    <screen>ResourceManager manager = new MonoThreadedManager();

//or

ResourceManager manager = new MultiThreadedManager(2); //Two threads</screen>
  </sect1>

  <sect1>
    <title>Performance Statistics</title>

    <para>There are two ways to obtain performance statistics.</para>

    <sect2>
      <title>Global Statistics</title>

      <para>These statistics refer to the global state of the framework by
      providing state information. The tasks can be in three different states:
      <emphasis role="bold">ready</emphasis> for execution, <emphasis
      role="bold">processing</emphasis>, <emphasis
      role="bold">waiting</emphasis> for other tasks to finish, and <emphasis
      role="bold">finished</emphasis> (ready to be collected by the user). The
      statistics corresponding to these states are:</para>

      <itemizedlist>
        <listitem>
          <para>Number of tasks on each state.</para>
        </listitem>

        <listitem>
          <para>Average time spent by the tasks on each state.</para>
        </listitem>
      </itemizedlist>

      <para>Statistics for a specific moment can be directly retrieved from
      the Calcium instance:</para>

      <screen>StatsGlobal statsGlobal = calcium.getStatsGlobal()</screen>

      <para>An alternative is to create a monitor that can be performe
      functions based on the statistics. In the following example we activate
      a simple logger monitor that prints the statistics every 5
      seconds.</para>

      <screen>Monitor monitor= new SimpleLogMonitor(<emphasis role="bold">calcium</emphasis>, 5);

monitor.start();
...
monitor.stop();</screen>
    </sect2>

    <sect2>
      <title>Result Statistics</title>

      <para>This statistics are specific for each result obtained from the
      framework. They provide information on how the result was
      obtained:</para>

      <itemizedlist>
        <listitem>
          <para>Execution time for each muscle of the skeleton.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>Time spent by this task in the <emphasis
          role="bold">ready</emphasis>, <emphasis
          role="bold">processing</emphasis>, <emphasis
          role="bold">waiting</emphasis> and <emphasis
          role="bold">executing</emphasis> state. Also, the wallclock and
          computation time are provided.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>Data parallelism achieved: tree size, tree depth, number of
          elements in the tree.</para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>