<?xml version="1.0" encoding="UTF-8"?>
<chapter><title>Exception Handling</title>
<!--  File: /home/irosenbe/PA_new_doc/docbook-tuto/doc-files/exceptions.html  -->
  
    <sect1 remap="h2">
      <title><anchor id="dbdoclet.id.exceptions_html_presentation"/>Exceptions and Asynchrony</title>
      <para>In the asynchronous environment provided by ProActive, exceptions cannot be
 handled the same as in a sequential environment. Let&#39;s see the problem with exceptions and
 asynchrony in a piece of code:</para>
      <screen>
1  
<emphasis role="bold">try</emphasis> {
2     Result r = someAO.someMethodCall(); // Asynchronous method call that \
can throw an exception
3     // ...
4     doSomethingWith(r);
5 } 
<emphasis role="bold">catch</emphasis> (SomeException se) {
6     doSomethingWithMyException(se);
7 }
      </screen>
      <para>In this piece of code, as the method call in line 2 is asynchronous, we
 don&#39;t wait for its completion and continue the execution. So, it&#39;s possible the control
 flow exits the <emphasis role="bold">try</emphasis>. In this case, if the method call ends up with an
 exception, we cannot throw it anymore back in the code because we are no more in the <emphasis role="bold">try</emphasis> block. That&#39;s why, by default, ProActive method calls with potential
 exceptions are handled synchronously.</para>
      <sect2 remap="h3">
        <title>Barriers around <emphasis role="bold">try</emphasis> blocks</title>
        <para>The ProActive solution to this problem is to put barriers around <emphasis role="bold">try</emphasis>/<emphasis role="bold">catch</emphasis> blocks. This way, the control flow cannot exit the
 block, the exception can be handled in the appropriate <emphasis role="bold">catch</emphasis> block, and the
 call is asynchronous within the block.</para>
        <para>With this configuration, the potential exception can be throw for several
 points:</para>
        <itemizedlist>
          <listitem>
            <para> When accessing a future</para>
          </listitem>
          <listitem>
            <para> In the barrier</para>
          </listitem>
          <listitem>
            <para> Using the provided API (see after)</para>
          </listitem>
</itemizedlist>
        <para>Let&#39;s reuse the previous example to see how to use these barriers</para>
        <screen>
1    
<emphasis role="bold">ProActive.tryWithCatch(SomeException.class);</emphasis>
2    
<emphasis role="bold">try</emphasis> {
3       Result r = someAO.someMethodCall(); // Asynchronous method call tha\
t can throw an exception
4       // ...
5       doSomethingWith(r);
6       
<emphasis role="bold">ProActive.endTryWithCatch();</emphasis>
7    } 
<emphasis role="bold">catch</emphasis> (SomeException se) {
8       doSomethingWithMyException(se);
9    } 
<emphasis role="bold">finally {</emphasis>
10      
<emphasis role="bold">ProActive.removeTryWithCatch();</emphasis>
11   
<emphasis role="bold">}</emphasis>
        </screen>
        <para>With this code, the call in line 3 will be asynchronous, and the exception
 will be handled in the correct <emphasis role="bold">catch</emphasis> block. Even if this implies waiting at
 the end of the <emphasis role="bold">try</emphasis> block for the completion of the call.</para>
        <para>Let&#39;s see in detail the needed modifications to the code:</para>
        <itemizedlist>
          <listitem>
            <para> ProActive.tryWithCatch() call right before the <emphasis role="bold">try</emphasis> block. The parameter
 is either the caught exception class or an array of these classes if there are many</para>
          </listitem>
          <listitem>
            <para> ProActive.endWithTry() at the end of the <emphasis role="bold">try</emphasis> block</para>
          </listitem>
          <listitem>
            <para> ProActive.removeTryWithCatch() at the beginning of the <emphasis role="bold">finally</emphasis> block,
 so the block becomes mandatory</para>
          </listitem>
</itemizedlist>
      </sect2>
      <sect2 remap="h3">
        <title>TryWithCatch Annotator</title>
        <para>These needed annotations can be seen as cumbersome, so we provide a tool to
 add them automatically to a given source file. It transforms the first example code in the
 second. Here is a sample session with the tool:</para>
        <screen>
$ ProActive/scripts/unix/trywithcatch.sh MyClass.java # A backup will be ma\
de in MyClass.java~
--- ProActive TryWithCatch annotator -----------------------
$ diff -u MyClass.java~ MyClass.java
--- MyClass.java~
+++ MyClass.java
@@ -1,9 +1,13 @@
 public class MyClass {
     public MyClass someMethod(AnotherClass a) {
+        ProActive.tryWithCatch(AnException.class);
         try {
             return a.aMethod();
+            ProActive.endTryWithCatch();
         } catch (AnException ae) {
             return null;
+        } finally {
+            ProActive.removeTryWithCatch();
         }
     }
 }
        </screen>
        <para>As we can see, ProActive method calls are added to make sure all calls
 within <emphasis role="bold">try</emphasis>/<emphasis role="bold">catch</emphasis> blocks are handled asynchronously.</para>
      </sect2>
      <sect2 remap="h3">
        <title>Additional API</title>
        <para>We have seen the 3 methods mandatory to perform asynchronous calls with
 exceptions, but the complete API includes two more calls. So far, the blocks boundaries define
 the barries. But, some control over the barrier is provided thanks to two additional methods.</para>
        <para>The first method is ProActive.throwArrivedException(). During a computation
 an exception may be raised but there is no point from where the exception can be thrown (a future
 or a barrier). The solution is to call the ProActive.throwArrivedException() method which simply
 queries ProActive to see if an exception has arrived with no opportunity of being thrown back in
 the user code. In this case, the exception is thrown by this method.</para>
        <para>The method behaviour is thus dependant on the timing. That is, calling this
 method may or may not result in an exception being thrown, depending on the time for an exception
 to come back. That&#39;s why another method is provided, this is
 ProActive.waitForPotentialException(). Unlike the previous one, this method is blocking. After
 calling this method, either an exception is thrown, or it is assured that all previous calls in
 the block completed successfully, so no exception can be thrown from the previous calls.</para>
      </sect2>
    </sect1>
    <sect1 remap="h2">
      <title><anchor id="dbdoclet.id.exceptions_html_nfe"/>Non-Functional Exceptions</title>
      <sect2 remap="h3">
        <title>Overview</title>
        <para>In the first part, we were concerned with functional exception. That is,
 exceptions originating from &quot;business&quot; code. The middleware adds its set of exceptions
 that we call Non-Functional Exceptions (NFE): network errors, ... ProActive has a mechanism for
 dealing with these exceptions.</para>
      </sect2>
      <sect2 remap="h3">
        <title>Exception types</title>
        <para>We have classified the non functional exceptions in two categories: those
 on the proxy, and those on the body. So, exceptions concerning the proxy are in the
 org.objectweb.proactive.core.exceptions.proxy package and inherits from the
 ProxyNonFunctionalException package.</para>
      </sect2>
      <sect2 remap="h3">
        <title>Exception handlers</title>
        <para>The NFE mechanism in ProActive calls user defined handlers when a NFE is
 thrown. A handler implements the following interface:</para>
        <screen>
public interface NFEListener {
    public boolean handleNFE(NonFunctionalException e);
}
        </screen>
        <para>The handleNFE method is called with the exception to handle as parameter.
 The boolean return code indicates if the handler could do something with the exception. This way,
 if no handler could do anything with a given exception, the default behavior is used.</para>
        <para>If the exception is on the proxy side, the default behaviour is to throw
 the exception which is a RuntimeException. But on the proxy side, the default behaviour is to log
 the exception with its stack trace to avoid killing an active object.</para>
        <sect3 remap="h4">
          <title>Association</title>
          <para>These handlers are associated to entities generating exceptions. These are:
 an active object proxy, a body, a JVM. Given a NFE, the handlers on the local JVM will be
 executed, then either those associated to the proxy or the body depending on the exception.</para>
          <para>Here is an example about how to add a handler to an active object on its
 side (body):</para>
          <screen>
ProActive.addNFEListenerOnAO(myAO, 
<emphasis role="bold">new</emphasis> NFEListener() {
    
<emphasis role="bold">public boolean</emphasis> handleNFE(NonFunctionalException nfe) {
        
// Do something with the exception...
        
// Return true if we were able to handle it
        
<emphasis role="bold">return true</emphasis>;
    }
});
          </screen>
          <para>Handlers can also be added to the client side (proxy) of an active object
 with</para>
          <screen>
ProActive.addNFEListenerOnProxy(ao, handler)
          </screen>
          <para>or to a JVM with</para>
          <screen>
ProActive.addNFEListenerOnJVM(handler)
          </screen>
          <para>and even to a group with</para>
          <screen>
ProActive.addNFEListenerOnGroup(group, handler)
          </screen>
          <para>These handlers can also be removed with</para>
          <screen>
ProActive.removeNFEListenerOnAO(ao, handler),
ProActive.removeNFEListenerOnProxy(ao, handler),
ProActive.removeNFEListenerOnJVM(handler)
ProActive.removeNFEListenerOnGroup(group, handler)
          </screen>
          <para>It&#39;s also possible to define an handler only for some exception types,
 for example:</para>
          <screen>
ProActive.addNFEListenerOnJVM(
<emphasis role="bold">new</emphasis> TypedNFEListener(
    SendRequestCommunicationException.
<emphasis role="bold">class</emphasis>,
    
<emphasis role="bold">new</emphasis> NFEListener() {
    
<emphasis role="bold">public boolean</emphasis> handleNFE(NonFunctionalException e) {
        
// Do something with the SendRequestCommunicationException...
        
// Return true if we were able to handle it
        
<emphasis role="bold">return true</emphasis>;
    }
}));
          </screen>
          <para>You can use NFE for example, to automatically remove dead elements from a
 ProActive group when trying to contact them. This can be achieved using the following
 construction:</para>
          <screen>
ProActive.addNFEListenerOnGroup(group, FailedGroupRendezVousException.AUTO_\
GROUP_PURGE);
          </screen>
          <para>Note that this currently works only for one-way calls.</para>
          <para></para>
          <para></para>
          <para>
  </para>
</sect3>
      </sect2>
    </sect1>
  
</chapter>
