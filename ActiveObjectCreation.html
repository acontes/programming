<html>
<head>
<title>Active Objects : creation and advanced concepts</title>
<link rel="stylesheet" href="ProActive.css">
</head>
<body bgcolor="white">

<!--
 Header : start 
~~~ -->
<table width="100%">
<tr>
<td align="left" valign="middle">
    <table cellpadding="2" cellspacing="0" border="1">
    <tr>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="../../../../overview-summary.html">back to API</a>&nbsp;&nbsp;</td>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="index.html">back to index</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="ProActiveBasis.html">prev</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="FutureObjectCreation.html">next</a>&nbsp;&nbsp;</td>
    </tr>
    </table>
</td>
<td  align="right" valign="top">
<img src="ProActiveLogo200x34.gif"/>
</td>
</tr>
</table>
<hr>
<!-- Link to index : end -->

<h1>Active Objects : creation and advanced concepts</h1>

<h2>Active Object: creation and advanced concepts</h2>
<p class="textNormal">
Active objects are created on a per-object basis: an application can contain active as well as passive instances of a given class. In the remaining part of this section, we will consider that we want to create an active instance of class <code>example.A</code>. Although almost any object can be turned in an Active Object, there are some restrictions that we will detail below.
</p>
<p class="textNormal">
Any method call <i>m</i> done on a given instance <i>a</i> of <code>A</code> would result in the invocation of the method <i>m</i> on <i>a</i> by the caller thread. By contrast, the same call done on the active object <i>aa</i> created from <code>A</code> would result into placing a request embedding the method call for <i>m</i> in the request queue of the active object <i>aa</i>. Then, later on, the active thread of <i>aa</i> would eventually pick-up and serve the request for the method <i>m</i>. That would result in the invocation of <i>m</i> on the reified object <i>a</i> by the active thread.
</p>
<p class="textNormal">
The code for creating a passive instance of <code>A</code>
could be :
</p>
<blockquote><pre>
    A a = new A(26, "astring");
</pre></blockquote>
<p class="textNormal">
In <b>ProActive</b> there are two ways to create active objects. One way is to use <code>ProActive.newActive</code> and is based on the instantiation of a new object, the other is to use <code>ProActive.turnActive</code> and is based on the use of an existing object.
</p>
<h2>Instantiation-Based Creation</h2>
<p class="textNormal">
When using instantiation based creation, any argument passed to the constructor of the reified object through <code>ProActive.newActive</code> is serialized and passed by copy to the object. This is because the model behind <b>ProActive</b> is uniform whether the active object is instantiated locally or remotely. The parameters are therefore guaranteed to be passed by copy to the constructor. When using <code>ProActive.newActive</code> you must make sure that the arguments of the constructor are <code>Serializable</code>. On the other hand, the class used to create the active object <b>does not need to be</b> <code>Serializable</code> even in the case of remotely created  active objects. Remind also that to be created properly, the reified object must have a declared empty no-args constructor.
</p>
<pre>
    A a;
    Object[] params = new Object[] { new Integer (26), "astring" };
    try {
      a = (A) ProActive.newActive("example.A", params);
    } catch (ActiveObjectCreationException e) {
      // creation of ActiveObject failed
      e.printStackTrace();
    }
    catch(NodeException ex){
    	ex.printStackTrace();
    }
</pre>
<p class="textNormal">
This code creates an active object of class <code>A</code> in the local JVM. If the invocation of the constructor of class <code>A</code> throws an exception, it is placed inside an exception of type <code>ActiveObjectCreationException</code>. When the call to <code>newActive</code> returns, the active object has been created and its active thread is started.
</p>

<h3>Possible ambiguities on the constructor</h3>
<p class="textNormal">
The first parameter of newActive is a string containing the fully-qualified name of the class we want to make active. Parameters to the constructor have to be passed as an array of Object. Then, according to the type of the elements of this array, the ProActive runtime determines which constructor of class A to call. Nevertheless, there is still room for some ambiguity in resolving the constructor because :
</p>
<ul class="listWithSpace">
<li class="textNormal">
As the arguments of the constructor are stored in an array of type <code>Object[]</code>, primitive types have to be represented by their wrappers object type. In the example above, we use an <code>Integer</code> object to wrap the <code>int</code> value 26. An ambiguity then arises if two constructor of the same class only differ by converting a primitive type to its
corresponding wrapper class. In the example below, an ambiguity exists between the first and the second constructors.
</li>
<li class="textNormal">
If one argument is null, the runtime can obviously not determine its type. This is the second source of ambiguity. In the example below, an ambiguity exists between the third and the fourth constructors if the second element of the array is <code>null</code>.
</li>
</ul>
<pre>
    public A (int i) {
        //
    }

    public A (Integer i) {
        //
    }

    public A (int i, String s) {
        //
    }

    public A (int i, Vector v) {
        //
    }
</pre>

<h3>Using a Node</h3>
<p class="textNormal">
It is possible to pass a third parameter to the call to <code>newActive</code> in order to create the new active object on a specific JVM, possibly remote. The JVM is identified using a <code><a href="../core/node/Node.html">Node</a></code> object that offers the minimum services ProActive needs on a given JVM to communicate with this JVM. If that parameter is not given,
the active object is created in the current JVM and is attached to a default Node.
</p>
<p class="textNormal">
A node is identified by a node URL which is formed using the protocol, the hostname hosting the JVM where is the node located and the name of the node. The <code><a href="../core/node/NodeFactory.html">NodeFactory</a></code> allows to create or lookup nodes. The method <code>newActive</code> can take in parameter a nodeURL as a <code>String</code> or a <code>Node</code> object that points to an existing node. Here an example :
</p>
<pre>
      a = (A) ProActive.newActive("example.A", params, "rmi://pluto.inria.fr/aNode");
  or
      Node node = NodeFactory.getNode("rmi://pluto.inria.fr/aNode");
      a = (A) ProActive.newActive("example.A", params, node);
</pre>

<h2>Object-Based Creation</h2>
<p class="textNormal">
Object-based creation is used for turning an existing passive object instance into an active one. It has been introduced in ProActive as an answer to the following problem. Consider, for example, that an instance of class A is created inside a library and returned as the result of a method call. As a consequence, we do not have access to the source code where the object is created, which prevents us for modifying it for creating an active instance of A. Even if it were possible, it may not be likely since we do not want to get an active instance of A for every call on this method.
</p>
<p class="textNormal">
When using object based creation, you create the object that is going to be reified as an active object before hand. Therefore there is no serialization involved when you create the object. When you invoke <code>ProActive.turnActive</code> on the object two cases are possible. If you create the active object locally (on a local node), it will not be serialized. If you create the active object remotely (on a remote node), the reified object will be serialized. Therefore, if the <code>turnActive</code> is done on a remote node, the class used to create the active object this way <b>has to be</b> <code>Serializable</code>. In addition, when using <code>turnActive</code>, care must be taken that no other references to the originating object are kept by other objects after the call to turnActive. A direct call to a method of the originating object without passing by a ProActive stub on this object will break the model.
</p>
<p class="textNormal">
Code for object-based creation looks like this :
</p>
<pre>
    A a = new A (26, "astring");
    a = (A) ProActive.turnActive(a);
</pre>

<p class="textNormal">
As for <code>newActive</code>, the second parameter of <code>turnActive</code>
if given is the location of the active object to be created. 
No parameter or <code>null</code> means that the active object is created locally in the current
node.
</p><p class="textNormal">
When using this method, the programmer has to make
sure that no other reference on the passive object <i>a</i> exist after the
call to turnActive. If such references were used for calling methods
directly on the passive A (without going through its body), the model
would no more be consistent and specialization of synchronization
could no more be guaranteed.
</p>


<h2>Specifying the activity of an active object</h2>
<p class="textNormal">
Customizing the activity of the active object is at the core of ProActive because it allows to specify fully the behavior of an active object. By default, an object turned into an active object serves its incoming requests in a FIFO manner. In order to specify another policy for serving the requests or to specify any other behaviors one can implement interfaces defining methods that will be automatically called by ProActive.
</p>
<p class="textNormal">
It is possible to specify what to do before the activity starts, what the activity is and what to do after it ends. The three steps are :
<ul>
<li>the initialization of the activity (done only once)</li>
<li>the activity itself</li>
<li>the end of the activity (done only once)</li>
</ul>
</p><p class="textNormal">
Three interfaces are used to define and implement each step :
<ul>
<li class="textNormal"><a href="../InitActive.html">InitActive</a></li>
<li class="textNormal"><a href="../RunActive.html">RunActive</a></li>
<li class="textNormal"><a href="../EndActive.html">EndActive</a></li>
</ul>
</p><p class="textNormal">
In case of a migration, an active object stops and restarts its activity automatically without invoking the init or ending phases. Only the activity itself is restarted.
</p>
<p class="textNormal">
Two ways are possible to define each of the three phases of an active object.
</p>
<ul>
<li class="textNormal">Implementing one or more of the three interfaces directly in the class used to create the active object</li>
<li class="textNormal">Passing an object implementing one or more of the three interfaces in parameter to the method <code>newActive</code> or <code>turnActive</code> (parameter active in those methods)</li>
</ul>
<p class="textNormal">
Note that the methods defined by those 3 interfaces are guaranted to be called by the active 
thread of the active object.
</p>

<h3>Algorithms for deciding what activity to invoke</h3>
<p class="textNormal">
The algorithms that decide for each phase what to do are the following (<code>activity</code> is 
the eventual object passed as a parameter to <code>newActive</code> or <code>turnActive</code>) :
</p>
<b>InitActive</b>
<pre>
if activity is non null and implements InitActive
  we invoke the method initActivity defined in the object activity
else if the class of the reified object implements InitActive
  we invoke the method initActivity of the reified object
else
  we don't do any initialization
</pre>

<b>RunActive</b>
<pre>
if activity is non null and implements RunActive
  we invoke the method runActivity defined in the object activity
else if the class of the reified object implements RunActive
  we invoke the method runActivity of the reified object
else
  we run the standard FIFO activity
</pre>

<b>EndActive</b>
<pre>
if activity is non null and implements EndActive
  we invoke the method endActivity defined in the object activity
else if the class of the reified object implements EndActive
  we invoke the method endActivity of the reified object
else
  we don't do any cleanup
</pre>

<h3>Implementing the interfaces directly in the class used to create the active object</h3>
<p class="textNormal">
This is the easiest solution when you do control the class that you make active. Depending on which phase in the life of the active object you want to customize, you implement the corresponding interface (one or more) amongst <code><a href="../InitActive.html">InitActive</a></code>, <code><a href="../RunActive.html">RunActive</a></code> and <code><a href="../EndActive.html">EndActive</a></code>. Here is an example that has a custom initialization and activity.
</p>
<p class="textNormal"><b>Example1: </b>
<pre>
  import org.objectweb.proactive.*;

  public class A implements InitActive, RunActive {
    	private String myName;

   	 public String getName() {
     	 return myName;
    	}

    	// -- implements InitActive
    	public void initActivity(Body body) {
      	myName = body.getName();
    	}

    	// -- implements RunActive for serving request in a LIFO fashion
   	 public void runActivity(Body body) {
      	Service service = new Service(Body);
      	while (body.isActive()) {
       	 service.blockingServeYoungest();
      	}
    	}

    	public static void main(String[] args) throws Exception {
      	A a = (A) ProActive.newActive("A",null);
      	System.out.println("Name = "+a.getName());
    	}
  }
</pre>
<p class="textNormal"><b>Example2: </b> <b>start, stop, suspend, restart</b> a simulation algorithm in runActivity method
<pre>
import org.objectweb.proactive.*;

public class Simulation implements RunActive {

      private boolean stoppedSimulation=false;
	private boolean startedSimulation=false
	private boolean suspendedSimulation=false;
	private boolean notStarted = true;

	public void startSimulation(){
	//<b>Simulation starts</b>
	notStarted = false;
	startedSimulation=true;
	}
	public void restartSimulation(){
	//<b>Simulation is restarted</b>
	startedSimulation=true;
	suspendedSimulation=false;
	}

	public void suspendSimulation(){
	//<b>Simulation is suspended</b>
	suspendedSimulation=true;
	startedSimulation = false;
	}

	public void stoppedSimulation(){
	//<b>Simulation is stopped</b>
	stoppedSimulation=true;
	}

	public void runActivity(Body body) {
     	 Service service = new Service(Body);
      	while (body.isActive()) {
      	//If the simulation is not yet started wait until startSimulation method
   	<b>if(notStarted) service.blockingServeOldest(startSimulation());</b>
       // If the simulation is started serve request with FIFO
     	<b> if(startedSimulation) service.blockingServeOldest();</b>
      	// If simulation is suspended wait until restartSimulation method
      <b>	if(suspendedSimulation) service.blockingServeOldest(restartSimulation());</b>
      	// If simulation is stopped, exit
      <b>	if(stoppedSimulation) exit();</b>
	}
}
</pre>

</p>
<h3>Passing an object implementing the interfaces when creating the active object</h3>
<p class="textNormal">
This is the solution to use when you do not control the class that you make active or when you want to write generic activities policy and reused them with several active objects. Depending on which phase in the life of the active object you want to customize, you implement the corresponding interface (one or more) amongst <code><a href="../InitActive.html">InitActive</a></code>, <code><a href="../RunActive.html">RunActive</a></code> and <code><a href="../EndActive.html">EndActive</a></code>. Here an example that has a custom activity.
</p>
<p class="textNormal">
Comparing to the solution above where interfaces are directly implemented in the reified class, there is one restriction here : you cannot access the internal state of the reified object. Using an external object should therefore be used when the implementation of the activity is generic enough not to have to access the member variables of the reified object.
</p>
<pre>
  import org.objectweb.proactive.*;
  public class LIFOActivity implements RunActive {
    // -- implements RunActive for serving request in a LIFO fashion
    public void runActivity(Body body) {
      Service service = new Service(Body);
      while (body.isActive()) {
        service.blockingServeYoungest();
      }
    }
  }

  import org.objectweb.proactive.*;
  public class A implements InitActive {
    private String myName;

    public String getName() {
      return myName;
    }

    // -- implements InitActive
    public void initActivity(Body body) {
      myName = body.getName();
    }

    public static void main(String[] args) throws Exception {
      // newActive(classname, constructor parameter (null = none), 
      //           node (null = local), active, MetaObjectFactory (null = default)
      A a = (A) ProActive.newActive("A", null, null, new LIFOActivity(), null);
      System.out.println("Name = "+a.getName());
    }
  }
</pre>




<h2>Restrictions on reifiable objects</h2>
<p class="textNormal">
Not all classes can give birth to active objects. There
exist some restrictions, most of them caused by the 100%
Java compliance, which forbids modifying the Java Virtual Machine or the compiler.
</p><p class="textNormal">
Some of these restrictions work at class-level :
<ul class="listWithSpace">
    <li class="textNormal">Final classes cannot give birth to active object</li>
    <li class="textNormal">Same thing for non-public classes</li>
    <li class="textNormal">Classes without a no-argument constructor cannot be
reified. This restriction will be softened in a later release of
ProActive</li>
</ul>
</p><p class="textNormal">
Some other happen at the level of a method in a specific class:
<ul class="listWithSpace">
    <li class="textNormal">Final methods cannot be used at all. Calling a final method on an active object leads to inconsistent behavior.</li>
    <li class="textNormal">Calling a non-public method on an active object raises an exception. This restriction disappeared with JDK 1.2.</li>
</ul>
</p>
<h2>Using the Factory Method Design Pattern</h2>
<p class="textNormal">
Creating an active object using ProActive might be a little bit cumbersome and requires more lines of code that for creating a regular object. A nice solution to this problem is through the use of the <b>factory</b> pattern. This mainly applies to class-based creation. It consists in adding a static method to class <code>pA</code> that takes care of instantiating the active object and returns it. The code is :
</p>
<pre>
  public class AA extends A {
    public static A createActiveA (int i, String s, Node node) {
      Object[] params = new Object[] {new Integer (i), s};
      try {
        return (A) ProActive.newActive("A", params, node);
      } catch (Exception e) {
        System.err.println ("The creation of an active instance of A raised an exception: "+e);
        return null;
      }
    }
  }
</pre>
<p class="textNormal">
It is up to the programmer to decide whether this method has to throw exceptions or not. We recommend that this method only throws exceptions that appear in the signature of the reified constructor (none here as the constructor of A that we call doesn't throw any exception). But the non functional exceptions induced by the creation of the active object have to be dealt with somewhere in the code.
</p>


<h2>Advanced : Customizing the Body of an Active Object</h2>
<h3>Motivations</h3>
<p class="textNormal">There are many cases where you may want to customize the body used when creating an active object. For instance, one may want to add some debug messages or some timing behavior when sending or receiving requests. The body is a non changeable object that delegates most of its tasks to helper objects called MetaObjects. Standard MetaObjects are already used by default in ProActive but one can easily replace any of those MetaObjects by a custom one.
</p>
<p class="textNormal">We have defined the <a href="../core/body/MetaObjectFactory.html">MetaObjectFactory</a> interface able to create factories for each of those MetaObjects. This interface is implemented by <a href="../core/body/ProActiveMetaObjectFactory.html">ProActiveMetaObjectFactory</a> which provides all the default factories used in ProActive.
</p>
<p class="textNormal">When creating an active object, as we saw above, it is possible to specify which <code>MetaObjectFactory</code> to use for that particular instance of active object being created. The class <a href="../ProActive.html">ProActive</a> provides extra <a href="../ProActive.html#newActive(java.lang.String, java.lang.Object[], org.objectweb.proactive.core.node.Node, org.objectweb.proactive.Active, org.objectweb.proactive.core.body.MetaObjectFactory)">newActive</a> and <a href="../ProActive.html#turnActive(java.lang.Object, org.objectweb.proactive.core.node.Node, org.objectweb.proactive.Active, org.objectweb.proactive.core.body.MetaObjectFactory)">turnActive</a> methods for that.
</p>


<h3>How to do it</h3>
<p class="textNormal">First you have to write a new MetaObject factory that inherits from <a href="../core/body/ProActiveMetaObjectFactory.html">ProActiveMetaObjectFactory</a> or directly implements <a href="../core/body/MetaObjectFactory.html">MetaObjectFactory</a> in order to redefine everything. Inheriting from <a href="../core/body/ProActiveMetaObjectFactory.html">ProActiveMetaObjectFactory</a> is a great time saver as you only redefine what you really need to. Here is an example :
</p>
<blockquote><pre>
public class MyMetaObjectFactory extends ProActiveMetaObjectFactory {

  private static final MetaObjectFactory instance = new MyMetaObjectFactory();

  protected MyMetaObjectFactory() {
    super();
  }

  public static MetaObjectFactory newInstance() {
    return instance;
  }

  //
  // -- PROTECTED METHODS -----------------------------------------------
  //

  protected RequestFactory newRequestFactorySingleton() {
    return new MyRequestFactory();
  }

  //
  // -- INNER CLASSES -----------------------------------------------
  //

  protected class MyRequestFactory implements RequestFactory, java.io.Serializable {
    public Request newRequest(MethodCall methodCall, UniversalBody sourceBody, boolean isOneWay, long sequenceID) {
      return new MyRequest(methodCall, sourceBody, isOneWay, sequenceID, server);
    }
  } // end inner class MyRequestFactory
}
</pre></blockquote>
<p class="textNormal">The factory above simply redefines the <code>RequestFactory</code> in order to make the body use a new type of request. The method <code>protected RequestFactory newRequestFactorySingleton()</code> is one convenience method that <a href="../core/body/ProActiveMetaObjectFactory.html">ProActiveMetaObjectFactory</a> to simplify the creation of factories as singleton. More explanations can be found in the javadoc of that class.
The use of that new factory is fairly simple. All you have to do is to pass an instance of the factory when creating a new active object. If we take the same example as before we have :
<pre>
  Object[] params = new Object[] {new Integer (26), "astring"};
  try {
    A a = (A) ProActive.newActive("example.AA", params, null, null, MyMetaObjectFactory.newInstance());
  } catch (Exception e) {
    e.printStackTrace() ;
  }
</pre>

In the case of a <code>turnActive</code> we would have :
<pre>
  A a = new A(26, "astring");
  a = (A) ProActive.turnActive(a, null, null, MyMetaObjectFactory.newInstance());
</pre>
</p>

<h2>Advanced : Role of the elements of an active object</h2>
<p class="textNormal">
In this section, we'll have a very close look at what happens when an active object is created. This section aims at
providing a better understanding of how the library works and where the restrictions of Proactive come from.
<br></br>
Consider that some code in an instance of class <code>A</code> creates an active object of
class <code>B</code> using a piece of code like this :
</p>
<blockquote><pre>
    B b;
    Object[] params = {<some parameters for the constructor>};
    try {
      // We create an active instance of B on the current node
      b = (B) ProActive.newActive("B", params);
    } catch (Exception e) {
      e.printStackTrace () ;
    }
</pre></blockquote>
<p class="textNormal">
If the creation of the active instance of B is successful, the graph of objects is as described in figure below (with arrows denoting references).
</p>

<br><div align="center">
<img src="activeObjectComponents.gif"/>
<br><b class="legend">
The components of an active object
</b><br></div>
<p class="textNormal">
The active instance of B is actually composed of 4 objects :
</p>
<ul class="listWithSpace">
    <li class="textNormal">a stub (<code>Stub_B</code>)</li>
    <li class="textNormal">a proxy (<code>BodyProxy</code>)</li>
    <li class="textNormal">a body (<code>Body</code>)</li>
    <li class="textNormal">an instance of <code>B</code></li>
</ul>

<h3>Role of the stub</h3>
<p class="textNormal">
The role of the class <code>Stub_B</code> is to reify all method calls that can be performed through a reference of type <code>B</code>, and only
these as calling a method declared in a subclass of <code>B</code> through downcasting would result in a runtime error). Reifying a
call simply means constructing an object (in our case, all reified calls are instance of class <code><a href="../core/mop/MethodCall.html">MethodCall</a></code>) that
represents the call, so that it can be manipulated as any other object. This reified call is then processed by the other
components of the active object in order to achieve the behavior we expect from an active object.
</p>
<p class="textNormal">
The idea of using a standard object for representing elements of the language that are not normally objects (such as method calls,
constructor calls, references, types,...) is what <i>metaobject programming</i> is all about. The metaobject protocol (MOP) ProActive is built on 
is described <a href="MOP.html">here</a> but it is not a prerequisite for understanding and using ProActive.
</p><p class="textNormal">
As one of our objectives is to provide transparent active objects, references to active objects of class <code>B</code> need to
be of the same type as references to passive instances of <code>B</code> (this feature is called <i>polymorphism</i> between passive and active
instances of the same class). This is why, by construction, <code>Stub_B</code> is a subclass of class <code>B</code>, therefore allowing instances
of class <code>Stub_B</code> to be assigned to variables of type <code>B</code>.
</p><p class="textNormal">
Class <code>Stub_B</code> redefines each of the methods inherited from its superclasses. The code of each method of class <code>Stub_B</code>
actually builds an instance of class <code>MethodCall</code> in order to represent the call to this method. This object is then passed to the
<code>BodyProxy</code>, which returns an object that is returned as the result of the method call. From the caller's point of view, everything
looks like if the call had been performed on an instance of <code>B</code>.
</p><p class="textNormal">
Now that we know how stubs work, we can understand some of the limitations of ProActive :
<ul class="listWithSpace">
<li class="textNormal">Obviously, <code>Stub_B</code> cannot redefine <code>final</code> methods
inherited from class <code>B</code>. Therefore, calls to these methods are not reified but are executed on the stub, which may lead to
unexplainable behavior if the programmer does not carefully avoid calling <code>final</code> methods on active objects.
<br>
As there are 6 final methods in the base class <Code>Object</Code>, one may wonder how to live without them. In fact, 5 out of this 6 methods deal with thread
synchronization (<code>notify()</code>, <code>notifyAll()</code> and the 3 versions of <code>wait()</code>). Those method should not be used since 
an active object provides thread synchronization. Indeed, using the standard thread synchronization mechanism and
ProActive thread synchronization mechanism at the same time might conflict and result in an absolute debugger's nightmare.
<br>
The last final method in the class <code>Object</code> is <code>getClass()</code>. When invoked on an active object, <code>getClass()</code> is not reified and therefore performed on the stub object, which returns an object of class <code>Class</code> that represents the class of the stub (<code>Stub_B</code> in our example) and not the class of the active object itself (<code>B</code> in our example). However, this method is seldom used in standard applications and it doesn't prevent the operator <code>instanceof</code> to work thanks to its polymorphic behavior. Therefore the expression <code>(foo instanceof B)</code> has the same value whether B is active or not.
</li>
<li class="textNormal">
Getting or setting instance variables directly (not through a getter or a setter) must be avoided in the case of active objects because it results in getting or setting the value on the stub object and not on the instance of the class <code>B</code>. This problem is usually worked around by using get/set methods for setting or reading attributes. This rule of strict encapsulation may also be found in JavaBeans or in most distributed object systems like RMI or CORBA.
</li>
</ul>

<h3>Role of the proxy</h3>
<p class="textNormal">
The role of the proxy is to handle asynchronism in calls to active object. More specifically, it creates future objects if possible and needed, forwards calls to bodies and returns future objects to the stubs. As this class operates on <code>MethodCall</code> objects, it is absolutely generic and does not depend at all on the type of the stub that feeds calls in through its <code>reify</code> method.
</p>

<h3>Role of the body</h3>
<p class="textNormal">
The <code>body</code> is responsible for storing calls (actually, <code><a href="../core/body/request/Request.html">Request</a></code> objects) in a queue of pending requests and processing these request according to a given synchronization policy, whose default behavior is FIFO. The Body has its own thread, which alternatively chooses a request in the queue of pending ones and executes the associated call.
</p>

<h3>Role of the instance of class B</h3>
<p class="textNormal">
This is a standard instance of class <code>B</code>. It may contain some synchronized information in its <code>live</code> method, if any. As the body executes calls one by one, there cannot be any concurrent execution of two portions of code of this object by two different threads. This enables the use of pre- and post-conditions and class invariants. As a consequence, the use of the keyword <code>synchronized</code> in class <code>B</code> should not be necessary. Any synchronization scheme that can be expressed through monitors and <code>synchronized</code> statements can be expressed using ProActive's high-level synchronization mechanism in a much more natural and user-friendly way.
</p>


<!--
 Footer : start
~~~ -->
<br><hr><div align="right" class="textSmall">Copyright &#169; October 2003 INRIA All Rights Reserved.</p>
<!-- Footer : end -->
</body>
</html>
