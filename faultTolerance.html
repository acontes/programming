<!-- saved from url=(0022)http://internet.e-mail -->
<html>
<head>
<title>Fault-Tolerance in ProActive</title>
<link rel="stylesheet" href="ProActive.css">
</head>
<body bgcolor="white">

<!--
 Header : start 
~~~ -->
<table width="100%">
<tr>
<td align="left" valign="middle">
    <table cellpadding="2" cellspacing="0" border="1">
    <tr>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="../../../../overview-summary.html">back to API</a>&nbsp;&nbsp;</td>
    <td class="smallLink1">&nbsp;&nbsp;<a class="smallLink1" href="index.html">back to index</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="Security.html">prev</a>&nbsp;&nbsp;</td>
    <td class="smallLink2">&nbsp;&nbsp;<a class="smallLink2" href="p2p.html">next</a>&nbsp;&nbsp;</td>
    </tr>
    </table>
</td>
<td  align="right" valign="top">
<img src="ProActiveLogo200x34.gif"/>
</td>
</tr>
</table>
<hr>
<!-- Link to index : end -->

<h1>Fault-Tolerance</h1>


<h2>Overview</h2>

<p class="textNormal">
ProActive can provide fault-tolerance capabilities through two differents
protocols: a Communication-Induced Checkpointing protocol (CIC) and a
pessimistic message logging protocol (PML). Making a ProActive application
fault-tolerant is <b>fully transparent</b>; active objects are turned
fault-tolerant using Java properties that can be set in the <A
href="Descriptor.html">deployment descriptor</A> . The programmer can select
<i>at deployment time</i> the most adapted protocol regarding the application
and the execution environment.
<BR>
Persistence of active objects is obtained through standard Java serialization;
a checkpoint thus consists in an object containing a serialized copy of an
active object and few informations related to the protocol. As a consequence,
a fault-tolerant active object must be serializable.
</p>


<h3>Communication Induced Checkpointing (CIC)</h3> 

<p class="textNormal">
Each active object in a CIC fault-tolerant application have to checkpoint at
least every <b>TTC</b> (Time To Checkpoint) seconds. When all the active
objects have taken a checkpoint, a <b>global state</b> is formed. If a failure
occurs, the <i>entire</i> application must restarts from such a global
state. The TTC value depends mainly on the assessed frequency of failures. A
little TTC value leads to very frequent global state creation and thus to a
little rollback in the execution in case of failure. But a little TTC value
leads also to a bigger overhead between a non-fault-tolerant and a
fault-tolerant execution. The TTC value can be set by the programmer in the
deployment descriptor.
</p>

<p class="textNormal">
The failure-free overhead induced by the CIC protocol is usually low, and this
overhead is quasi-independent from the message communication rate. The
counterpart is that the recovery time could be long since all the application
must restart after the failure of one or more active object.
</p>



<h3>Pessimistic message logging (PML)</h3> 

<p class="textNormal">
Each active object in a PML fault-tolerant application have to checkpoint at
least every TTC seconds and all the messages delivered to an active object are
logged on a stable storage. There is no need for global synchronization as
with CIC protocol, each checkpoint is independent: if a failure occurs, only
the faulty process have to recover from its latest checkpoint. As for CIC
protocol, the TTC value impact the global failure-free overhead, but the
overhead is more linked to the communication rate of the application.
</p>


<p class="textNormal">
Regarding the CIC protocol, the PML protocol induces a higher overhead on
failure-free execution, but the recovery time is lower as a single failure
does not involve all the system.
</p>



<BR>
<h2>Making a ProActive application fault-tolerant</h2>


<h3>Resource Server</h3>
<p class="textNormal">
To be able to recover a failed active object, the fault-tolerance system must
have access to a <i>resource server</i>. A resource server is able to return a
free node that can host the recovered active object.
<BR>
A resource server is implemented in ProActive in
<code>ft.servers.resource.ResourceServer</code>. This server can store free
      nodes by two differents way:
<ul>
<li> at deployment time: the user can specify in the deployment descriptor a
resource virtual node. Each node mapped on this virtual node will automaticaly
register itself as free node at the specified resource server.

<li> at execution time: the resource server can use an <A
HREF="p2p.html">underlying p2p network</A> to reclaim free nodes when a
hosting node is needed.
</ul>
</p>
<p class="textNormal">
Note that those two mechanisms can be combined. In that case, the resource
server first provides node registered at deployment time, and when no more
such nodes are available, the p2p network is used.
</p>



<h3>Fault-Tolerance servers</h3>
<p class="textNormal">
Fault-tolerance mechanism needs servers for the checkpoints storage, the
localization of the active objects, and the failure detection. Those servers
are implemented in the current version as a unique server
(<code>ft.servers.FTServer</code>), that implements the interfaces of each
server (<code>ft.servers.*.*</code>). This global server also includes a
resource server.
<BR>
This server is a classfile server for recovered active objects. It must thus
have access to all classes of the application, i.e. it must be started with
<b>all classes of the application in its classpath</b>.
</p>
<p class="textNormal">
The global fault-tolerance server can be launched using the
<code>ProActive/scripts/[unix|windows]/FT/startGlobalFTServer.[sh|bat]</code> script, with 5 optional parameters:
<ul>
<li>the protocol: <code>-proto [cic|pml]</code>. Default value is
	<code>cic</code>.
<li>the server name: <code>-name &lt;serverName&gt;</code>. The default name
	is FTServer.
<li>the port number: <code>-port &lt;portNumber&gt;</code>. The default port
	number is 1100.
<li>the fault detection period: <code>-fdperiod
	  &lt;periodInSec&gt;</code>. This value defines the time between two
	consecutive fault detection scanning. The default value is 10
	sec. Note that an active object is considered as faulty when it becomes unreachable,
	i.e. when it becomes unable to receive a message from another active
	object.

<li>the URL of a <A HREF="p2p.html">p2p service</A> that can be used by the
resource server: <code>-p2p &lt;serviceURL&gt;</code>. There is no default value for
this option.

</ul>
<p class="textNormal">
The server can also be directly launched in the java source code, using
<code>org.objectweb.proactive.core.process.JVMProcessImpl</code> class:

<blockquote><pre>
GlobalFTServer server = new JVMProcessImpl(new org.objectweb.proactive.core.process.AbstractExternalProcess.StandardOutputMessageLogger());
this.server.setClassname("org.objectweb.proactive.core.body.ft.servers.StartFTServer");
this.server.startProcess();
</pre></blockquote>
</p></p>



<p class="textNormal">
Note that if one of the servers is unreachable when a fault-tolerant
application is deploying, fault-tolerance is automatically and transparently
disabled for all the application.
</p>



<BR>





<h3><A NAME="configuration">Configure fault-tolerance for a ProActive application</A></h3> 
<p class="textNormal">
Fault-tolerance capabilities of a ProActive application are set in the
deployment descriptor, using the <code>faultTolerance</code> service. This
service is attached to <i>a virtual node</i>: active objects that are deployed
on this virtual node are turned fault-tolerant. This service must first
defines the protocol that have to be used for this application. The user can
select the appropriate protocol with the entry <code>&lt;protocol
type="[cic|pml]"/></code> in the definition of the service.
<BR>
The service also defines <b>servers URLs</b> :
</p>
<ul>
<li> <code>&lt;globalServer url="..."/&gt;</code> set the
	URL of a <i>global</i> server, i.e. a server that implements all
	needed methods for fault-tolerance mechanism (stable storage, fault
	detection, localization). If this value is set, all others URLs will be
	<i>ignored</i>.
<li> <code>&lt;checkpointServer url="..."/&gt;</code> set the
	URL of the checkpoint server, i.e. the server where checkpoints are stored.
<li> <code>&lt;locationServer url="..."/&gt;</code> set the
	URL of the location server, i.e. the server responsible for giving
	references on failed and recovered active objects.
<li> <code>&lt;recoveryProcess url="..."/&gt;</code> set the
	URL of the recovery process, i.e. the process responsible for launching the
	recovery of the application after a failure.
<li> <code>&lt;resourceServer url="..."/&gt;</code> set the
	URL of the resource server, i.e. the server responsible for providing
	free nodes that can host a recovered active object.
</ul>
<p class="textNormal">
Finally, the <b>TTC</b> value is set in fault-tolerance service, using <code>
&lt;ttc value="x"/&gt;</code>, where x is expressed in <i>seconds</i>. If not, the
default value (30 sec) is used.
</p>
<BR>




<h3>A deployment descriptor example</h3>
<p class="textNormal">
Here is an example of deployment descriptor that deploys 3 virtual nodes : one
for deploying fault-tolerant active objects, one for deploying
non-fault-tolerant active object (if needed), and one as resource for
recovery. The two fault-tolerance behaviors correspond to two fault-tolerance
services, <code>appli</code> and <code>resource</code>. Note that
non-fault-tolerant active objects can communicate with fault-tolerant active
objects as usual. Chosen protocol is CIC and TTC is set to 5 sec for all the
application.
</p>

<table width="100%">
 <tr>
	<td>
<table class="xml" align="left">
	<tr>
	<td>
    <p class="xml">
&lt;ProActiveDescriptor&gt;<br>
&nbsp;&lt;componentDefinition&gt;<br>
&nbsp;&nbsp;&lt;virtualNodesDefinition&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;virtualNode name="NonFT-Workers" property="multiple"/&gt;<br>    
&nbsp;&nbsp;&nbsp;&lt;virtualNode name="FT-Workers" property="multiple" <b>ftServiceId="appli"</b>/&gt; <br>
&nbsp;&nbsp;&nbsp;&lt;virtualNode name="Failed" property="multiple" <b>ftServiceId="resource"</b>/&gt;<br>
&nbsp;&nbsp;&lt;/virtualNodesDefinition&gt;<br>
&nbsp;&lt;/componentDefinition&gt;<br>
&nbsp;&lt;deployment&gt;<br>
&nbsp;&nbsp;&lt;mapping&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;map virtualNode="NonFT-Workers"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;jvmSet&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;vmName value="Jvm1"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/jvmSet&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;/map&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;map virtualNode="FT-Workers"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;jvmSet&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;vmName value="Jvm2"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/jvmSet&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;/map&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;map virtualNode="Failed"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;jvmSet&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;vmName value="JvmS1"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;vmName value="JvmS2"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/jvmSet&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;/map&gt;<br>
&nbsp;&nbsp;&lt;/mapping&gt;<br>
&nbsp;&nbsp;&lt;jvms&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;jvm name="Jvm1"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;creation&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;processReference refid="linuxJVM"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/creation&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;/jvm&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;jvm name="Jvm2"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;creation&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;processReference refid="linuxJVM"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/creation&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;/jvm&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;jvm name="JvmS1"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;creation&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;processReference refid="linuxJVM"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/creation&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;/jvm&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;jvm name="JvmS2"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;creation&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;processReference refid="linuxJVM"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/creation&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;/jvm&gt;<br>
&nbsp;&nbsp;&lt;/jvms&gt;<br>
&nbsp;&lt;/deployment&gt;<br>
&nbsp;&lt;infrastructure&gt;<br>
&nbsp;&nbsp;&lt;processes&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;processDefinition id="linuxJVM"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;jvmProcess class="org.objectweb.proactive.core.process.JVMNodeProcess"/&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;/processDefinition&gt;<br>
&nbsp;&nbsp;&lt;/processes&gt;<br>
&nbsp;&nbsp;&lt;services&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;<b>serviceDefinition id="appli"</b>&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;faultTolerance&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;protocol type="cic"&gt;&lt;/protocol&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;globalServer url="rmi://localhost:1100/FTServer"&gt;&lt;/globalServer&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ttc value="5"&gt;&lt;/ttc&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/faultTolerance&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;/serviceDefinition&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;<b>serviceDefinition id="resource"</b>&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;faultTolerance&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;protocol type="cic"&gt;&lt;/protocol&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;globalServer url="rmi://localhost:1100/FTServer"&gt;&lt;/globalServer&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;resourceServer url="rmi://localhost:1100/FTServer"&gt;&lt;/resourceServer&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ttc value="5"&gt;&lt;/ttc&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/faultTolerance&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;/serviceDefinition&gt;<br>
&nbsp;&nbsp;&lt;/services&gt;<br>
&nbsp;&lt;/infrastructure&gt;<br>
&lt;/ProActiveDescriptor&gt;<br>
</td>
	</tr>
</table>
</td></tr>
</table>


<BR><BR> 
<h2>Programming rules</h2>


<h3>Serializable</h3> 

<p class="textNormal">
Persistence of active objects is obtained through standard Java serialization;
a checkpoint thus consists in an object containing a serialized copy of an
active object and a few informations related to the protocol. As a
consequence, a fault-tolerant active object <i>must be serializable</i>. If a
non serializable object is activated on a fault-tolerant virtual node,
fault-tolerance is automatically and transparently disabled for this active
object.
</p>

<h3>Standard Java main method</h3>
<p class="textNormal">
Standard Java thread, typically main method, cannot be turned
fault-tolerant. As a consequence, if a standard main method interacts with
active objects during the execution, consistency after a failure can no more
be ensured: after a failure, all the active objects will roll back to the most
recent global state <i>but the main will not</i>.  

<BR><BR>So as to avoid such inconsistency on recovery, the programmer must
minimizes the use of standard main by, for example, delegating the
initialization and launching procedure to an active object.
</p>


<blockquote><pre>
...
public static void main(String[] args){
   Initializer init = (Initializer)(ProActive.newActive("Initializer.getClass.getName()", args);
   init.launchApplication();
   System.out.println("End of main thread");
}
...
</pre></blockquote>

<p class="textNormal">
The object <code>init</code> is an active object, and as such will be rolled
back if a failure occurs: the application is kept consistent.
</p>


<h3>Checkpointing occurrence</h3>
<p class="textNormal">
To keep fault-tolerance fully transparent (see <A
href="http://www-sop.inria.fr/oasis/personnel/Christian.Delbe/publis/rr5246.pdf">the
technical report</A> for more details), active objects can take a checkpoint
<i>before the service of a request</i>.


As a first consequence, if the service of a request is infinite, or at least
much greater than TTC, the active object that serves such a request can no
more take checkpoints. If a failure occurs during the execution, this object
will force the entire application to rolls back to the beginning of the
execution. The programmer must thus avoid infinite method such as

<blockquote><pre>
...
public void infiniteMethod(){
   while (true){
     this.doStuff();
   }
}
...
</pre></blockquote>


<p>
The second consequence concerns the definition of the
<code>runActivity()</code> method (see <A
HREF="http://www-sop.inria.fr/oasis/ProActive/doc/api/org/objectweb/proactive/RunActive.html"><code>runActive</code></A>).
Let us consider the following example :
</p>
    
<blockquote><pre>
...
public void runActivity(Body body) {
   org.objectweb.proactive.Service service = new org.objectweb.proactive.Service(body);
   while (body.isActive()) {
      Request r = service.blockingRemoveOldest();
      ...
      /* CODE A */
      ...
      /* CHECKPOINT OCCURRENCE */
      service.serve(r);
   }
}
...
</pre></blockquote>

<p>
If a checkpoint is triggered before the service of <code>r</code>, it
characterizes the state of the active object at the point <code>/* CHECKPOINT
OCCURRENCE */</code>. If a failure occurs, this active object is restarted by
calling the <code>runActivity()</code> method, <i>from a state in which the
code <code>/* CODE A */</code> has been already executed</i>. As a
consequence, the execution looks like if <code>/* CODE A */</code> was executed
two times.<BR> The programmer should then avoid to alter the state of an
active object in the code preceding the call to <code>service.serve(r)</code>
      when he redefines the <code>runActivity()</code> method.



</p>


<h3>Activity Determinism</h3>
<p class="textNormal">
All the activities of a fault-tolerant application must be deterministic (see
<A href="http://www-sop.inria.fr/oasis/personnel/Christian.Delbe/publis/rr5246.pdf">
the technical report</A> for more details). The programmer must then avoid the
use of non-deterministic methods such as <code>Math.random()</code>.
</p>


<h3>Limitations</h3>
<p class="textNormal">
Fault-tolerance in ProActive is still not compliant with the following
    features :
<ul>
<li> active objects exposed as <A href="WSDoc.html">Web services</A>, or reachable using http protocol,
<li> and <A href="./Security.html">security</A>, as fault-tolerance servers are implemented using standard RMI.
</ul>
</p>




<h2><A NAME="nbody">A complete example</A></h2>

<h3>Description</h3>

<p class="textNormal">
You can find in
<code>ProActive/scripts/[unix|windows]/ft/nbodyft.[sh|bat]</code> a script
that starts a fault-tolerant version of the <a
href="http://www-sop.inria.fr/oasis/ProActive/apps/nbody.html">ProActive
NBody</a> example. This script actually call the
<code>ProActive/scripts/[unix|windows]/nbody.[sh|bat]</code> script with the
option <code>-displayft</code>. The java source code is the same as the
standard version. The only difference is the "Execution Control" panel added
in the graphical interface, which allows the user to remotely kill Java
Virtual Machine so as to trigger a failure by sending a <code>killall
java</code> signal. Note that this panel will not work with Windows operating
system, since the <code>killall</code> does not exist. But a failure can be
triggered for example by killing the JVM process on one of the hosts.
</p>

<img src="./pics/nbodyft.jpg">



<p class="textNormal">
This snapshot shows a fault-tolerant execution with 8 bodies on 3 different
hosts. Clicking on the "Execute" button will trigger the failure of the host
called Nahuel and the recovery of the 8 bodies. The checkbox <i>Show trace</i>
is checked: the 100 latest positions of each body are drawn with darker
points. These traces allow to verify that, after a failure, each body finally
reach the position it had just before the failure.
</p>


<h3>Running NBody example</h3>

<p class="textNormal">
Before starting the fault-tolerant body example, you have to edit the
<code>ProActive/descriptors/FaultTolerantWorkers.xml</code> deployment
descriptor so as to deploy on your own hosts (<B>HOSTNAME</B>), as follow:
</p>

<table width="100%">
 <tr>
	<td>
<table class="xml" align="left">
	<tr>
	<td>
    <p class="xml">
...<br>
&nbsp;&lt;processDefinition id="jvmAppli1"&gt;<br>
&nbsp;&nbsp;&lt;rshProcess class="org.objectweb.proactive.core.process.rsh.RSHJVMProcess" hostname="<B>HOSTNAME</B>"&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;processReference refid="jvmProcess"/&gt;<br>
&nbsp;&nbsp;&lt;/rshProcess&gt;<br>
&nbsp;&lt;/processDefinition&gt;<br>
...<br>
</td>
	</tr>
</table>
</td></tr>
</table>
<p class="textNormal">
Of course, more than one host is needed to run this example, as failure are
triggered by killing all Java processes on the selected host.
<br>
The deployment descriptor must also specify the GlobalFTServer location as
follow, assuming that the script <code>startGlobalFTServer.sh</code> has been
started on the host <B>SERVER_HOSTAME</B>:
</p>

<table width="100%">
 <tr>
	<td>
<table class="xml" align="left">
	<tr>
	<td>
    <p class="xml">
...<br>
&nbsp;&lt;services&gt;<br>
&nbsp;&nbsp;&lt;serviceDefinition id="appli"&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;faultTolerance&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;protocol type="cic"&gt;&lt;/protocol&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;globalServer url="rmi://<B>SERVER_HOSTAME</B>:1100/FTServer"&gt;&lt;/globalServer&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;ttc value="5"&gt;&lt;/ttc&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;/faultTolerance&gt;<br>
&nbsp;&nbsp;&lt;/serviceDefinition&gt;<br>
&nbsp;&nbsp;&lt;serviceDefinition id="ressource"&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;faultTolerance&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;protocol type="cic"&gt;&lt;/protocol&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;globalServer url="rmi://<B>SERVER_HOSTAME</B>:1100/FTServer"&gt;&lt;/globalServer&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;resourceServer url="rmi://<B>SERVER_HOSTAME</B>:1100/FTServer"&gt;&lt;/resourceServer&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;ttc value="5"&gt;&lt;/ttc&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;/faultTolerance&gt;<br>
&nbsp;&nbsp;&lt;/serviceDefinition&gt;<br>
&nbsp;&lt;/services&gt;<br>
...
</td>
	</tr>
</table>
</td></tr>
</table>

<p class="textNormal">
Finally, you can start the fault-tolerant ProActive NBody and choose the
      version you want to run :
</p>

<pre>
~/ProActive/scripts/unix/FT> ./nbodyFT.sh
Starting Fault-Tolerant version of ProActive NBody...

--- N-body with ProActive ---------------------------------
 **WARNING** : $PROACTIVE/descriptors/FaultTolerantWorkers.xml MUST BE SET WITH EXISTING HOSTNAMES !
        Running with options set to 4 bodies, 3000 iterations, display true
 1 : Simplest version, one-to-one communication and master
 2 : group communication and master
 3 : group communication, odd-even-synchronization
 4 : group communication, oospmd synchronization
 5 : Barnes-Hut, and oospmd
Choose which version you want to run [12345] :
4
Thank you!
 --> This ClassFileServer is reading resources from classpath
Jini enabled
Ibis enabled
Created a new registry on port 1099
//tranquility.inria.fr/Node-157559959 successfully bound in registry at //tranquility.inria.fr/Node-157559959
Generating class : pa.stub.org.objectweb.proactive.examples.nbody.common.Stub_Displayer
************* Reading deployment descriptor: file:./../../.././descriptors/FaultTolerantWorkers.xml ********************
<pre>

<!--
 Footer : start 
~~~ -->
<br><hr><div align="right" class="textSmall">Copyright &copy; April 2005 INRIA All Rights Reserved.</p>
<!-- Footer : end -->
</body>
</html>
