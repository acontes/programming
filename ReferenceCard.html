<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>ProActive Documentation Index</title>
  <link rel="stylesheet" href="ProActive.css">
</head>
<body style="background-color: white;">
<!--
 Header : start 

<!-- Header : end -->
<table align="center" border="1" width="40%">
	<tbody>
		<tr>
		<th align="center">ProActive ReferenceCard</th>	
		</tr>
	</tbody>
</table>
<p align="center"><b><a href="http://ProActive.ObjectWeb.org">ProActive.ObjectWeb.org</a></b></p><br></br>
<p class="textNormal">
<b>ProActive</b> is a Java library for <b>parallel</b>, <b>distributed</b>,
and
<b>concurrent</b> computing, also featuring <b>mobility</b> and <b>security</b>
in a uniform framework.
<b>ProActive</b> provides a
comprehensive API and a graphical interface.
The library is based on an Active Object pattern that is a uniform way
to encapsulate:
</p>
<table width="100%">
	<tbody>
		<tr>
		<td  width="10%"></td>
			<td  width="40%" align="left">
				<ul class="listWithSpace">
				 	<li><b>a remotely</b> accessible object,</li>
  					<li>a <b>thread</b> as an asynchronous activity,</li>
 					 <li>an <b>actor</b> with its own script,</li>
  					
					</ul>
				</td>
				<td  width="5%"></td>
				<td  width="40%" align="left">
				<ul class="listWithSpace">
				<li>a <b>server</b> of incoming requests,</li>
  					<li>a <b>mobile</b> and potentially secure entity,</li>
  					<li>a <b>component </b> with server and client interfaces.</li>
  					</ul>
				</td>
				<td  width="5%"></td>

			</tr>
	</tbody>
</table>
<p class="textNormal">
<b>ProActive</b> is only made of standard Java classes, and requires <b>no
changes
to the Java Virtual Machine</b>. Overall, it simplifies the programming of 
applications distributed over Local Area Network (LAN), Clusters, Intranet or
Internet GRIDs.</p>

<table border="1" width="100%">
	<tbody>
		<tr align="center">
			<th>Main concepts and definitions:</th>
		</tr>
		<tr>
			<td>
			<ul class="listWithSpace">
				
			
			<li><b>Active Objects (AO):</b> a remote object, with its own thread, receiving calls
                     on its public methods</li>
<li><b>FIFO activity:</b> an AO, by default, executes the request it receives one after 
               the other, in the order they were received</li>
<li><b>No-sharing:</b> standard Java objects cannot be referenced from 2 AOs, ensured by 
            deep-copy of constructor params, method params, and results</li>
<li><b>Asynchronous Communications:</b> method calls towards AOs are asynchronous
<li><b>Future:</b>   the result of a non-void asynchronous method call </li>
<li><b>Request:</b>  the occurrence of a method call towards an AO</li>
<li><b>Service:</b>  the execution by an AO of a request</li>
<li><b>Reply:</b>    after a service, the method result is sent back to the caller</li>
<li><b>Wait-by-necessity:</b> automatic wait upon the use of a still awaited future </li>
<li><b>Automatic Continuation:</b> transmission of futures and replies between AO and JVMs</li>
<li><b>Migration:</b> an AO moving from one JVM to another, computational weak mobility:
           the AO decides to migrate and stack is lost</li>
<li><b>Group:</b> a typed group of objects or AOs. Methods are called in parallel on all
       group members.</li>
<li><b>Component:</b> made of AOs, a component defines server and client interfaces
<li><b>Primitive Component:</b> directly made of Java code and AOs</li>
<li><b>Composite Component:</b> contains other components (primitives or composites)</li>
<li><b>Parallel  Component:</b> a composite that is using groups to multicast calls to
                     inner components</li>
<li><b>Security:</b>  X.509 Authentication, Integrity, and Confidentiality defined 
           at deployment in an XML file on entities such as communications, 
           migration, dynamic code loading.</li>
<li><b>Virtual Node (VN):</b> an abstraction (a string) representing where to locate
                   AOs at creation</li>
<li><b>Deployment descriptor:</b> an XML file where a mapping VN --> JVMs --> Machine is
                       specified. </li>
<li><b>Node:</b> the result of mapping a VN to a set of JVMs. After activation, a VN 
      contains a set of nodes, living in a set of JVMs.</li>
<li><b>IC2D:</b> Interactive Control and Debugging of Distribution:
      a Graphical environment for monitoring and steering Grid applications</li></ul><br></br>
</td>
		</tr>
	</tbody>
</table><br></br><br></br>
<table width="100%" border="1">
	<tbody>
		<tr>
			<th>Main principles: asynchronous method calls and implicit futures</th>
		</tr>
		<tr>
			<td><pre>
A a = (A) ProActive.newActive("A", params, node);
<FONT ID="SingleLineComment">   // Create an active Object of type A in the JVM specified by Node</FONT>
a.foo (param); 
<FONT ID="SingleLineComment">   // A one way typed asynchronous communication towards the (remote) AO a</FONT>
<FONT ID="SingleLineComment">   // A request is sent to a,</FONT>
v = a.bar (param);
<FONT ID="SingleLineComment">   // A typed asynchronous communication with result.</FONT>
<FONT ID="SingleLineComment">   // v is first an awaited Future, to be transparently filled up after</FONT>
<FONT ID="SingleLineComment">   // service of the request, and reply</FONT>
...
v.gee (param);
<FONT ID="SingleLineComment">   // Use of the result of an asynchronous call.</FONT>
<FONT ID="SingleLineComment">   // If v is still an awaited future, it triggers an automatic </FONT>
<FONT ID="SingleLineComment">   // wait: Wait-by-necessity</FONT>
</pre>
			</td>
	</tbody>
</table><br></br>
<table width="100%" border="1">
	<tbody>
		<tr>
			<th>Explicit Synchronization:</th>
		</tr>
		<tr>
			<td><pre>
<b class="java">boolean </b>isAwaited(Object);
<FONT ID="SingleLineComment">   // Returns True if the object is still an awaited Future</FONT>
<b class="java">void </b> waitFor(Object);
<FONT ID="SingleLineComment">   // Blocks until the object is no longer awaited</FONT>
<FONT ID="SingleLineComment">   // A request is sent to a,</FONT>
<b class="java">void </b> waitForAll(Vector);
<FONT ID="SingleLineComment">   // Blocks until all the objects in Vector are no longer awaited</FONT>
<b class="java">int </b>waitForAny(Vector);
<FONT ID="SingleLineComment">   // Blocks until one of the objects in Vector is no longer awaited.</FONT>
<FONT ID="SingleLineComment">   // Returns the index of the available future.</FONT>

</pre>
			</td>
	</tbody>
</table><br></br>

<table width="100%" border="1">
	<tbody>
		<tr>
			<th>Programming AO Activity and services:</th>
		</tr>
		<tr>
			<td>
<p class="textNormal"> When an AO must implement an activity that is not FIFO, 
the RunActive interface has to be implemented: it specifies 
the AO behavior in the method named runActivity():</p>
<pre>
<b class="java">Interface </b>RunActive
<b class="java">void </b> runActivity(Body body)
<FONT ID="SingleLineComment">   // The activity of the active object instance of the current class</FONT></pre>
<p class="textNormal"> <b>Example:</b></p>
<pre>
<b class="java">public class </b> A <b class="java">implements</b>  RunActive {
<FONT ID="SingleLineComment">   // Implements RunActive for programming a specific behavior</FONT>
<FONT ID="SingleLineComment">   // runActivity() is automatically called when such an AO is created</FONT>
<b class="java">public void </b> runActivity(Body body) {
Service service = new Service(body);
while ( terminate ) {
	<FONT ID="SingleLineComment">...    // Do some activity on its own</FONT>
	...
	<FONT ID="SingleLineComment">...    // Do some services, e.g. a FIFO service on method named foo</FONT>
	...
	service.serveOldest("foo");
	... 
      }
    }
}

</pre>
<p class="textNormal"> Two other interfaces can also be specified:</p>
<pre>
<b class="java">Interface </b>InitActive
<b class="java">void </b> initActivity(Body body)
<FONT ID="SingleLineComment">   // Initializes the activity of the active object.</FONT>
<FONT ID="SingleLineComment">   // not called in case of restart after migration</FONT>
<FONT ID="SingleLineComment">   // Called before runActivity() method, and only once:</FONT>

<b class="java">Interface </b>EndActive
<b class="java">void </b> endActivity(Body body)
<FONT ID="SingleLineComment">   // Finalizes the active object after the activity stops by itself.</FONT>
<FONT ID="SingleLineComment">   // Called after the execution of runActivity() method, and only once:</FONT>
<FONT ID="SingleLineComment">   // not called before a migration</FONT>
</pre>
			</td>
	</tbody>
</table><br></br>
  
  <table width="100%" border="1">
	<tbody>
		<tr>
			<th>Reactive Active Object:</th>
		</tr>
		<tr>
			<td>
			<p class="textNormal"> Even when an AO is busy doing its own work, it can remain reactive to external 
events (method calls). One just has to program non-blocking services to take 
into account external inputs. 
</p>
<pre>

<b class="java">public class </b> BusyButReactive  <b class="java">implements</b>  RunActive {

<b class="java">public void </b> runActivity(Body body) {
Service service = new Service(body);
while ( ! hasToTerminate ) {
	<FONT ID="SingleLineComment">...    // Do some activity on its own</FONT>
	...
	<FONT ID="SingleLineComment">...    // Non blocking service</FONT>
	...
	service.serveOldest("changeParameters", "terminate");	... 
      }
    }
<b class="java">public void </b> changeParameters () {...<FONT ID="SingleLineComment">...    // change computation parameters</FONT>}
<b class="java">public void </b>  terminate (){ hasToTerminate=true;}
}
</pre>
<p class="textNormal">It also allows one to specify explicit termination of AOs (there is currently 
no Distributed Garbage Collector). Of course, the reactivity is up to the 
length of going around the loop. Similar techniques can be used to start, 
suspend, restart, and stop AOs.
</p>
			</td>
	</tbody>
</table><br></br>

<table width="100%" border="1">
	<tbody>
		<tr>
			<th>Service methods: </th>
		</tr>
		<tr>
			<td>
			<p class="textNormal"><b>Non-blocking services:</b> returns immediately if no matching request is pending
</p>
			<pre>
<b class="java">void </b>serveOldest();
<FONT ID="SingleLineComment">   // Serves the oldest request in the request queue</FONT>
<b class="java">void </b> serveOldest(String methodName)
<FONT ID="SingleLineComment">   // Serves the oldest request aimed at a method of name methodName</FONT>
<b class="java">void </b>serveOldest(RequestFilter requestFilter)
<FONT ID="SingleLineComment">   // Serves the oldest request matching the criteria given be the filter</FONT>

</pre>
<p class="textNormal"><b> Blocking services:</b> waits until a matching request can be served
</p>
			<pre>
<b class="java">void </b>blockingServeOldest();
<FONT ID="SingleLineComment">   // Serves the oldest request in the request queue</FONT>
<b class="java">void </b> blockingServeOldest(String methodName)
<FONT ID="SingleLineComment">   // Serves the oldest request aimed at a method of name methodName</FONT>
<b class="java">void </b>blockingServeOldest(RequestFilter requestFilter)
<FONT ID="SingleLineComment">   // Serves the oldest request matching the criteria given be the filter</FONT>
</pre>
<p class="textNormal"><b>Blocking timed services:</b> wait a matching request at most a time given in ms
</p>
			<pre>
<b class="java">void </b>blockingServeOldest (long timeout) 
<FONT ID="SingleLineComment">   // Serves the oldest request in the request queue.</FONT>
<FONT ID="SingleLineComment">   // Returns after timeout (in ms) if no request is available</FONT>
<b class="java">void </b> blockingServeOldest(String methodName, long timeout)
<FONT ID="SingleLineComment">   // Serves the oldest request aimed at a method of name methodName</FONT>
<FONT ID="SingleLineComment">   // Returns after timeout (in ms) if no request is available</FONT>
<b class="java">void </b>blockingServeOldest(RequestFilter requestFilter)
<FONT ID="SingleLineComment">   // Serves the oldest request matching the criteria given be the filter</FONT>
</pre>
<p class="textNormal"><b>Waiting primitives:
</b></p>
<pre>
<b class="java">void </b>waitForRequest();
<FONT ID="SingleLineComment">   // Wait until a request is available or until the body terminates</FONT>
<b class="java">void </b> waitForRequest(String methodName);
<FONT ID="SingleLineComment">   // Wait until a request is available on the given method name,</FONT>
<FONT ID="SingleLineComment">   // or until the body terminates</FONT>
</pre>
<p class="textNormal"><b>Others:
</b></p>
<pre>
<b class="java">void </b>fifoServing();
<FONT ID="SingleLineComment">   // Start a FIFO service policy. Call does not return. In case of </FONT>
<FONT ID="SingleLineComment">   // a migration, a new runActivity() will be started on the new site</FONT>
<b class="java">void </b>  lifoServing()
<FONT ID="SingleLineComment">   // Invoke a LIFO policy. Call does not return. In case of </FONT>
<FONT ID="SingleLineComment">   // a migration, a new runActivity() will be started on the new site</FONT>
<b class="java">void </b> serveYoungest()
<FONT ID="SingleLineComment">   // Serves the youngest request in the request queue</FONT>
<b class="java">void </b> flushAll()
<FONT ID="SingleLineComment">   // Removes all requests in the pending queue
</FONT>
</pre>

			</td>
	</tbody>
</table><br></br>

<table width="100%" border="1">
	<tbody>
		<tr>
			<th>Active Object Creation:</th>
		</tr>
		<tr>
			<td><pre>
Object newActive(String classname, Object[] constructorParameters,Node node);
<FONT ID="SingleLineComment">   // Creates a new AO of type classname. The AO is located on the given node,</FONT>
<FONT ID="SingleLineComment">   // or on a default node in the local JVM if the given node is nul</font>
Object newActive(String classname,Object[] constructorParameters,VirtualNode virtualnode);
<FONT ID="SingleLineComment">   // Creates a new set of AO of type classname.</FONT>
<FONT ID="SingleLineComment">   // The AO are located on each JVMs the Virtual Node is mapped onto</FONT>
Object turnActive(Object, Node node);
<FONT ID="SingleLineComment">   // Copy an existing Java object and turns it into an AO.</FONT>
<FONT ID="SingleLineComment">   // The AO is located on the given node, or on a default node in </FONT>
</pre>
			</td>
	</tbody>
</table><br></br>

<table width="100%" border="1">
	<tbody>
		<tr>
			<th>Groups:</th>
		</tr>
		<tr>
			<td><pre>
A ga = (A) ProActiveGroup.newGroup( "A", params, nodes);
<FONT ID="FormalComment">   // Created at once a group of AO of type "A" in the JVMs specified 
   // by nodes. ga is a Typed Group of type "A". 
   // The number of AO being created matches the number of param arrays.
   // Nodes can be a Virtual Node defined in an XML descriptor */</FONT>

ga.foo(...);
<FONT ID="FormalComment">   // A general group communication without result.
   // A request to foo is sent in parallel to AO in group ga  */</FONT>

V gv = ga.bar(...);
<FONT ID="FormalComment">   // A general group communication with a result.
   // gv is a typed group of "V", which is first a group
   // of awaited Futures, to be filled up asynchronously </FONT>

gv.gee (...);
<FONT ID="FormalComment">   // Use of the result of an asynchronous group call. It is also a  
   // collective operation: gee method is called in parallel on each object in group. 
   // Wait-by-necessity occurs when results are awaited */</FONT>

Group ag = ProActiveGroup.getGroup(ga);
<FONT ID="SingleLineComment">   // Get the group representation of a typed group</FONT>

ag.add(o);
<FONT ID="SingleLineComment">   // Add object in the group ag. o can be a standard Java object or an AO,</FONT>
<FONT ID="SingleLineComment">   // and in any case must be of a compatible type </FONT>

ag.remove(index)
<FONT ID="SingleLineComment">   // Removes the object at the specified index</FONT>

A ga2 = (A) ag.getGroupByType();
<FONT ID="SingleLineComment">   // Returns to the typed view of a group </FONT>

<b class="java">void </b>  setScatterGroup(g);
<FONT ID="FormalComment">   // By default, a group used as a parameter of a group communication
   // is sent to all as it is (deep copy of the group).
   // When set to scatter, upon a group call (ga.foo(g)) such a scatter 
   // parameter is dispatched in a round robing fashion to AOs in the
   // target group, e.g. upon ga.foo(g) */</FONT>
<b class="java">void </b> unsetScatterGroup(g);
<FONT ID="FormalComment">   // Get back to the default: entire group transmission in all group
   // communications, e.g. upon ga.foo(g) */</FONT>

</pre>
			</td>
	</tbody>
</table><br></br>

<table width="100%" border="1">
	<tbody>
		<tr>
			<th>Explicit Group Synchronizations:</th>
		</tr>
		<tr>
			<td>
			<p class="textNormal">Methods both in Interface Group, and static in class ProActiveGroup</p>
			<pre>
<b class="java">boolean </b> ProActiveGroup.allAwaited (Object);
<FONT ID="SingleLineComment">   // Returns True if object is a group and all members are still awaited</FONT>
<b class="java">boolean </b>ProActiveGroup.allArrived (Object);
<FONT ID="SingleLineComment">   // Returns False only if at least one member is still awaited</FONT>
<b class="java">void </b>  ProActiveGroup.waitAll (Object);
<FONT ID="SingleLineComment">   // Wait for all the members in group to arrive (all no longer awaited)</FONT>
<b class="java">void </b> ProActiveGroup.waitN (Object, int nb);
<FONT ID="SingleLineComment">   // Wait for at least nb members in group to arrive</FONT>
<b class="java">int </b> ProActiveGroup.waitOneAndGetIndex (Object);
<FONT ID="SingleLineComment">   // Waits for at least one member to arrived, and returns its index</FONT>

</pre>
			</td>
	</tbody>
</table><br></br>


<table width="100%" border="1">
	<tbody>
		<tr>
			<th>OO SPMD:</th>
		</tr>
		<tr>
			<td><pre>
A spmdGroup  =  (A) ProSPMD.newSPMDGroup("A", params, nodes);
<FONT ID="SingleLineComment">   // Creates an SPMD group and creates all members with params on the nodes.</FONT>
<FONT ID="SingleLineComment">   // An SPMD group is a typed group in which every member has a reference to</FONT>
<FONT ID="SingleLineComment">   // the others (the SPMD group itself).</FONT>
A mySpmdGroup = (A) ProSPMD.getSPMDGroup();
<FONT ID="SingleLineComment">   // Returns the SPMD group of the activity.</FONT>
int rank = ProSPMD.getMyRank();
<FONT ID="SingleLineComment">   // Returns the rank of the activity in its SPMD group.</FONT>
ProSPMD.barrier("barrierID");
<FONT ID="SingleLineComment">   // Blocks the activity (after the end of the current service) until all</FONT>
<FONT ID="SingleLineComment">   // other members of the SPMD group invoke the same barrier. </FONT>
<FONT ID="SingleLineComment">   // Three barriers are available : total barrier, neighbors based barrier</FONT>
<FONT ID="SingleLineComment">   // and method based barrier. </FONT>
</pre>
			</td>
	</tbody>
</table><br></br>


<table width="100%" border="1">
	<tbody>
		<tr>
			<th>Migration:</th>
		</tr>
		<tr>
			<td>
			<p class="textNormal">Methods both in Interface Group, and static in class ProActiveGroup</p>
			<pre>
<b class="java">void </b> migrateTo(Object o);
<FONT ID="SingleLineComment">   // Migrate the current AO to the same JVM as the AO</FONT>
<b class="java">void </b> void migrateTo(String nodeURL);
<FONT ID="SingleLineComment">   // Migrate the current AO to JVM given by the node URL</FONT>
<b class="java">int </b> void migrateTo(Node node);
<FONT ID="SingleLineComment">   // Migrate the current AO to JVM given by the node</FONT>
</pre>
<p class="textNormal">To initiate the migration of an object from outside, define a public method,
that upon service will call the static migrateTo primitive:
</p>
<pre>
<b class="java">public void </b>moveTo(Object) {
     <b class="java">try</b>{
       ProActive.migrateTo(t);
     } <b class="java">catch</b> (Exception e) {
       e.printStackTrace();
       logger.info("Cannot migrate.");
     }
   }
   
<b class="java">void </b>onDeparture(String MethodName);
<FONT ID="SingleLineComment">   // Specification of a method to execute before migration</FONT>
<b class="java">void </b> onArrival(String MethodName);
<FONT ID="SingleLineComment">   // Specification of a method to execute after migration, upon the </FONT>
<FONT ID="SingleLineComment">   // arrival in a new JVM</FONT>
<b class="java">void </b>setMigrationStrategy(MigrationStrategy);
<FONT ID="SingleLineComment">   // Specifies a migration itinerary</FONT>
<b class="java">void </b>migrationStrategy.add(Destination);
<FONT ID="SingleLineComment">   // Adds a JVM destination to an itinerary</FONT>
<b class="java">void </b>migrationStrategy.remove(Destination d) ;
<FONT ID="SingleLineComment">   // Remove a JVM destination in an itinerary</FONT>
</pre>
			</td>
	</tbody>
</table><br></br>

<table width="100%" border="1">
	<tbody>
		<tr>
			<th>Components:</th>
		</tr>
		<tr>
			<td>
			<p class="textNormal">Components are formed from AOs, a component is linked and communicates with
other remote components. A component can be composite, made of other 
components, and as such itself distributed over several machines.
Component systems are defined in XML files (ADL: Architecture Description 
Language); these files describe the definition, the assembly, and the 
bindings of components.</br>
Components follow the Fractal hierarchical component model specification and 
API, see http://fractal.objectweb.org</br>
The following methods are specific to ProActive.
</p>
<p>In the class org.objectweb.proactive.ProActive :
			<pre>
Component newActiveComponent("A", params, VirtualNode, ComponentParameters);
<FONT ID="FormalComment">   // Creates a new ProActive component from the specified class A.
   // The component is distributed on JVMs specified by the Virtual Node
   // The ComponentParameters defines the configuration of a component: 
   // name of component, interfaces (server and client), etc.
   // Returns a reference to a component, as defined in the Fractal API </FONT>
</pre>

<p>In the class org.objectweb.proactive.core.component.Fractive :
<pre>
ProActiveInterface createCollectiveClientInterface(String itfName, String itfSignature);
<FONT ID="FormalComment">   // This method is used in primitive components.
   // It generates a client collective interface named itfName, and typed as itfSignature.
   // This collective interface is a typed ProActive group.

</pre>

			</td>
	</tbody>
</table><br></br><br></br>

<table width="100%" border="1">
	<tbody>
		<tr>
			<th>Security:</th>
		</tr>
		<tr>
			<td>
			<p class="textNormal">An X.509 Public Key Infrastructure (PKI) allowing communication
Authentication, Integrity, and Confidentiality (AIC) to be configured in an
XML security file, at deployment, outside any source code.
Security is compatible with mobility, allows for hierarchical domain 
specificationand dynamically negotiated policies.<br></br>
<b>Example of specification:</b><pre>
&lt;Rule&gt;
   &lt;From&gt;&lt;Entity type="VN" name="VN1"/&gt; &lt;/From&gt;
   &lt;To&gt; &lt;Entity type="VN" name="VN2"/&gt; &lt;/To&gt;
   &lt;Communication&gt;
  &lt;Request value="authorized"&gt;
      &lt;Attributes authentication="required" 
                  integrity="required" 
                  confidentiality="optional"/&gt;
   &lt;/Request&gt; 
  &lt;/Communication&gt;
  &lt;Migration>denied&lt;/Migration&gt;
  &lt;AOCreation>denied&lt;/AOCreation&gt;
&lt;/Rule&gt;
</pre>


<p class="testNormal"> This rule specifies that: from Virual Node "VN1" to the VN "VN2", the 
communications (requests) are authorized, provided authentication and 
integrity are being used, while confidentiality is optional. 
Migration and AO creation are not authorized.
</p>

			</td>
	</tbody>
</table><br></br>

<table width="100%" border="1">
	<tbody>
		<tr>
			<th>Deployment:</th>
		</tr>
		<tr>
			<td>
			<p class="textNormal">Virtual Nodes (VN) allow one to specify the location where to create
AOs. A VN is uniquely identified as a String, is defined in an XML Deployment 
Descriptor where it is mapped onto JVMs. JVMs are themselves mapped onto 
physical machines: VN --> JVMs --> Machine.
Various protocols can be specified to create JVMs onto machines (ssh, 
Globus, LSF, PBS, rsh, rlogin, Web Services, etc.). 
After activation, a VN contains a set of nodes, living in a set of JVMs. 
Overall, VNs and deployment descriptors allow to abstract away from source 
code: machines, creation, lookup and registry protocols.<br></br>
<b>Descriptor example: creates one jvm on the local machine</b><br></br>
&lt;ProActiveDescriptor xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="DescriptorSchema.xsd"&gt;<br>
    &nbsp;&lt;componentDefinition&gt;<br>
    &nbsp;&nbsp;&lt;virtualNodesDefinition&gt;<br>
    &nbsp;&nbsp;&nbsp;&lt;virtualNode name="<b>Dispatcher</b>"/&gt;<br>
    &nbsp;&nbsp;&nbsp;<FONT ID="FormalComment">&lt;!-- Name of the Virtual Node that will be used in program source --&gt; </FONT><br>
    &nbsp;&nbsp;&lt;/virtualNodesDefinition&gt;<br>
    &nbsp;&lt;componentDefinition/&gt;<br>
    &nbsp;&lt;deployment&gt;<br>
    &nbsp;&nbsp;&lt;mapping&gt;<br>
    &nbsp;&nbsp;<FONT ID="FormalComment">&lt;!-- This part contains the mapping VNs -- JVMs --&gt; </FONT><br>
    &nbsp;&nbsp;&nbsp;&lt;map virtualNode="<b>Dispatcher</b>"&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;jvmSet&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;vmName value="<b>Jvm1</b>"/&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<FONT ID="FormalComment">&lt;!-- Virtual Node Dispatcher is mapped onto Jvm1 --&gt; </FONT><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/jvmSet&gt;<br>
    &nbsp;&nbsp;&nbsp;&lt;/map&gt;<br>
    &nbsp;&nbsp;&lt;/mapping&gt;<br>
    &nbsp;&nbsp;&lt;jvms&gt;<br>
    &nbsp;&nbsp;&nbsp;&lt;jvm name="<b>Jvm1</b>"&gt;<br>
    &nbsp;&nbsp;&nbsp;<FONT ID="FormalComment">&lt;!-- This part defines how the jvm will be obtained: creation or acquisition: creation in this example --&gt; </FONT><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;creation&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;processReference refid="<b>creationProcess</b>"/&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<FONT ID="FormalComment">&lt;!-- Jvm1 will be created using creationProcess defined below --&gt; </FONT><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/creation&gt;<br>
    &nbsp;&nbsp;&nbsp;&lt;/jvm&gt;<br>
    &nbsp;&nbsp;&lt;/jvms&gt;<br>
    &nbsp;&lt;/deployment&gt;<br>
    &nbsp;&lt;infrastructure&gt;<br>
    &nbsp;&nbsp;&lt;processes&gt;<br>
    &nbsp;&nbsp;&nbsp;&lt;processDefinition id="<b>creationProcess</b>"&gt;<br>
    &nbsp;&nbsp;&nbsp;<FONT ID="FormalComment">&lt;!-- Definition of creationProcess referenced above --&gt; </FONT><br> 
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;jvmProcess class="org.objectweb.proactive.core.process.JVMNodeProcess"/&gt;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<FONT ID="FormalComment">&lt;!-- creationProcess is a jvmProcess. The jvm will be created on the local machine using default settings (classpath, java path,...) --&gt; </FONT><br>
    &nbsp;&nbsp;&nbsp;&lt;/processDefinition&gt;<br>
    &nbsp;&nbsp;&lt;/processes&gt;<br>
    &nbsp;&lt;/infrastructure&gt;<br>
    &lt;/ProActiveDescriptor&gt;<br></br><br></br>
<b>Deployment API</b><br></br>
<pre>
ProActiveDescriptor pad = ProActive.getProActiveDescriptor(String File);
<FONT ID="FormalComment">   // Returns a ProActiveDescriptor object from the xml
   // descriptor file name </FONT>

pad.activateMapping(String VN);
<FONT ID="FormalComment">   // Activates the given Virtual Node: launches or acquires 
   // all the JVMs the VN is mapped onto </FONT>

pad.activateMappings();
<FONT ID="SingleLineComment">   // Activates all VNs defined in the ProActiveDescriptor </FONT>

VirtualNode vn = pad.getVirtualNode(String)
<FONT ID="FormalComment">   // Created at once a group of AO of type "A" in the JVMs specified
   // by the given vn. The Virtual Node is automatically activated if not
   // explicitly done before </FONT>

Node[] n = vn.getNodes();
<FONT ID="SingleLineComment">   // Returns all nodes mapped to the target Virtual Node</FONT>

Object[] n[0].getActiveObjects();
<FONT ID="SingleLineComment">   // Returns a reference to all AOs deployed on the target Node</FONT>

ProActiveRuntime part = n[0].getProActiveRuntime();
<FONT ID="FormalComment">   // Returns a reference to the ProActive Runtime (the JVM) where the 
   // node has been created </FONT>

pad.killall(boolean softly);
<FONT ID="FormalComment">   // Kills all the JVMs deployed with the descriptor
   // not softly: all JVMs are killed abruptely
   // softly: all JVMs that originated the creation of a rmi registry 
   // waits until registry is empty before dying </FONT>
</pre>

			</td>
	</tbody>
</table><br></br>

<table summary="Exceptions" width="100%" border="1">
	<tbody>
		<tr>
			<th>Exceptions</th>
		</tr>
		<tr>
			<td>
			<p class="textNormal"><b> Functional exceptions with asynchrony </b></p>
<pre>
ProActive.tryWithCatch(MyException.class);<FONT ID="SingleLineComment">// Just before the <b class="java">try</b></FONT>
<b class="java">try</b> {
    <FONT ID="FormalComment">// Some asynchronous calls with exceptions
    // One can use ProActive.throwArrivedException() and
    // ProActive.waitForPotentialException() here</FONT>    
    ProActive.endTryWithCatch();<FONT ID="SingleLineComment">// At the end of the <b class="java">try</b></FONT>
} <b class="java">catch</b> (MyException e) {
    <FONT ID="SingleLineComment">// ...</FONT>
} <b class="java">finally</b> {
    ProActive.removeTryWithCatch();<FONT ID="SingleLineComment">// At the beginning of the <b class="java">finally</b></FONT>
}
</pre>  

<p class="textNormal"><b>Non-Functional Exceptions</b></p>

<p class="textNormal">
Adding a handler to an active object on its side:
</p><pre>
ProActive.addNFEListenerOnAO(myAO, <b class="java">new</b> NFEListener() {
    <b class="java">public boolean</b> handleNFE(NonFunctionalException nfe) {
        <FONT ID="SingleLineComment">// Do something with the exception...</FONT>
        <FONT ID="SingleLineComment">// Return true if we were able to handle it</FONT>
        <b class="java">return true</b>;
    }
});
</pre>

<p class="textNormal">
Handlers can also be added to the client side of an active object with
</p>

<pre>ProActive.addNFEListenerOnProxy(ao, handler)</pre>
<p class="textNormal">or to a JVM with</p>
<pre>ProActive.addNFEListenerOnJVM(handler)</pre>

<p class="textNormal">
These handlers can also be removed with
</p>

<pre>ProActive.removeNFEListenerOnAO(ao, handler),
ProActive.removeNFEListenerOnProxy(ao, handler),
ProActive.removeNFEListenerOnJVM(handler)</pre>

<p class="textNormal">
It's possible to define an handler only for some exception types, for example:
</p>

<pre>
ProActive.addNFEListenerOnJVM(<b class="java">new</b> TypedNFEListener(
    SendRequestCommunicationException.<b class="java">class</b>,
    <b class="java">new</b> NFEListener() {
    <b class="java">public boolean</b> handleNFE(NonFunctionalException e) {
        <FONT ID="SingleLineComment">// Do something with the SendRequestCommunicationException...</FONT>
        <FONT ID="SingleLineComment">// Return true if we were able to handle it</FONT>
        <b class="java">return true</b>;
    }
}));
</pre>

<p class="textNormal">
The behaviour of the default handler (if none could handle the exception) is to throw
the exception if it's on the proxy side, or log it if it's on the body side.
</p>
			</td>
	</tbody>
</table><br></br>


<table width="100%" border="1">
	<tbody>
		<tr>
			<th>Export Active Objects as Web services</th>
		</tr>
		<tr>
			<td>
			<p class="textNormal">
ProActive allows active objects exportation as web services. The service is deployed onto a Jakarta Tomcat web server with a given url. 
It is identified by its urn, an unique id  of the service. It is also possible to choose the exported methods of the object.<br>
The WSDL file matching the service  will be accesible at
http://localhost:8080/servlet/wsdl?id=a for a service which name is
"a" and which id deployed on a web server which location is
http://localhost:8080.
 
<pre>
A a = (A) ProActive.newActive("A", new Object []{});
<FONT ID="FormalComment">   // Constructs an active object </FONT>

String [] methods = new String [] {"foo", "bar"};
<FONT ID="FormalComment"> //A String array containing the exported methods </FONT>

ProActive.exposeAsWebService(a,"http://localhost:8080","a",methods);
<FONT ID="FormalComment"> //Export the active object as a web service </FONT>

ProActive.unExposeAsWebService("a", "http://localhost:8080"); 
<FONT ID="FormalComment"> //Undeploy the service "a" on the web server located at http://localhost:8080 </FONT>
</pre>
</td>
</tbody>
</table><br></br>





<table width="100%" border="1">
	<tbody>
		<tr>
			<th>Deploying a fault-tolerant application</th>
		</tr>
		<tr>
			<td>
			<p class="textNormal">
ProActive can provide fault-tolerance capabilities through two differents
protocols: a Communication-Induced Checkpointing protocol (CIC) or a
pessimistic message logging protocol (PML). Making a ProActive application
fault-tolerant is <b>fully transparent</b>; active objects are turned
fault-tolerant using Java properties that can be set in the deployment
descriptor. The programmer can select <i>at deployment time</i> the most
adapted protocol regarding the application and the execution environment.
<BR><BR>

<b>A Fault-tolerant deployment descriptor</b><BR><BR><code>
&lt;ProActiveDescriptor&gt;
&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&lt;virtualNodesDefinition&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;virtualNode name="NonFT-Workers" property="multiple"/&gt;<br>    
&nbsp;&nbsp;&nbsp;&lt;virtualNode name="FT-Workers" property="multiple" ftServiceId="<b>appli</b>"/&gt; <br>
&nbsp;&nbsp;&lt;/virtualNodesDefinition&gt;<br>
&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&lt;serviceDefinition id="<b>appli</b>"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;faultTolerance&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<FONT ID="FormalComment">&lt;!-- Protocol selection : cic or pml --&gt; </FONT><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;protocol type="cic"&gt;&lt;/protocol&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<FONT ID="FormalComment">&lt;!-- URL of the fault-tolerance server --&gt; </FONT> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;globalServer url="rmi://localhost:1100/FTServer"&gt;&lt;/globalServer&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<FONT ID="FormalComment">&lt;!-- URL of the resource server; all the nodes
mapped on this virtual node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;will be registred in as resource nodes for recovery --&gt; </FONT><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;resourceServer url="rmi://localhost:1100/FTServer"&gt;&lt;/resourceServer&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<FONT ID="FormalComment">&lt;!-- Average time between two consecutive checkpoints for each object --&gt; </FONT><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ttc value="5"&gt;&lt;/ttc&gt;<FONT ID="FormalComment">&lt;!-- in seconds --&gt; </FONT><br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/faultTolerance&gt;<br>
&nbsp;&nbsp;&nbsp;&lt;/serviceDefinition&gt;<br>
&nbsp;&nbsp;&lt;/services&gt;<br>
&nbsp;&nbsp;...<br>
&lt;/ProActiveDescriptor&gt;<br>
</code><br>
<b>Starting the fault-tolerance server</b><BR><BR>
The global fault-tolerance server can be launched using the ProActive/scripts/[unix|windows]/FT/startGlobalFTServer.[sh|bat] script, with 5 optional parameters:
<ul>
<li> the protocol: <code>-proto [cic|pml]</code>. Default value is cic.
<li> the server name: <code>-name [serverName]</code>. Default name is FTServer.
<li> the port number: <code>-port [portNumber]</code>. Default port number is 1100.
<li> the fault detection period: <code>-fdperiod [periodInSec]</code>, the time between two consecutive fault detection scanning. Default value is 10 sec.
<li> the URL of a p2p service that can be used by the resource server: <code>-p2p [serviceURL]</code>. No default value. 
</ul>

</td>
</tbody>
</table>

<table border="1" width="100%">

  <tbody>

    <tr>

      <th>Peer-to-Peer Infrastructure</th>

    </tr>

    <tr>

      <td>
      <p class="textNormal">This aims to help you to
create a P2P
infrastructure over your desktop workstations network. It is
self-organized and configurable. The infrastructure maintains a dynamic
JVMs network for deploying computational applications.</p>

      <p class="textNormal"></p>

      <h3>Deploying the Infrastructure:</h3>

      <p class="textNormal">Firstly, you have to start P2P
Services on each shared machine:</p>

      <p class="textNormal textSmall">$ cd
ProActive/scripts/unix/p2p</p>

      <p class="textNormal textSmall">$ ./startP2PService
[-acq acquisitionMethod] [-port portNumber] [-s Peer ...]</p>

      <p class="textNormal">With that parameters (all are
optionals):</p>

      <ul>

        <li>-acq is the ProActive Runtime communication protocol
used &nbsp;by the peer. Examples: rmi, http, ibis,... By default it
is rmi.</li>

        <li>-port is the port number where the P2P Service
listens. By default it is 2410.</li>

        <li>-s specify addresses of peers which are used to join
the P2P infrastructure. Example: rmi://applepie.proactive.org:8080</li>

      </ul>

      <p><b>A simple example:</b></p>

      <p>&nbsp;&nbsp;&nbsp; <span class="textSmall">first.peer.host$ ./startP2PService.sh</span></p>

      <p class="textSmall">&nbsp;&nbsp;&nbsp;
second.peer.host$ ./startP2PService.sh -s //first.peer.host</p>

      <p class="textNormal"><span class="textSmall">&nbsp;&nbsp;&nbsp;
third.peer.host$ ./startP2PService.sh -s //second.peer.host</span></p>

      <h3>Acquiring Nodes:</h3>

      <p>Now you have a P2P Infrastructure running, you might
want to deploy your ProActive application on it. That is simple, just
modify the XML deployment descriptor:</p>

      <pre class="xml">
	...
	&lt;jvms&gt;
	  &lt;jvm name="Jvm1"&gt;
	    &lt;acquisition&gt;
	      &lt;serviceReference refid="p2plookup"/&gt;
	    &lt;/acquisition&gt;
	  &lt;/jvm&gt;
	  ...
	&lt;/jvms&gt;
	...
	&lt;infrastructure&gt;
	  ...
	  &lt;services&gt;
	    &lt;serviceDefinition id="p2plookup"&gt;
	      &lt;P2PService nodesAsked="2" acq="rmi" port="6666"&gt;
	        &lt;peerSet&gt;
	          &lt;peer&gt;//second.peer.host&lt;/peer&gt;
	        &lt;/peerSet&gt;
	      &lt;/P2PService&gt;
	    &lt;/serviceDefinition&gt;
	    ...
	  &lt;/services&gt;
	  ...
	&lt;/infrastructure&gt;
	...
	</pre>
    
    <p>In the <b>nodesAsked</b> argument, a special value <b>MAX</b> is
    allowed. When it is used, the P2P infrastructure returns the maximun
    number of nodes avilable, and continue while the application running to
    return new nodes to the application. To use all the benefit of that
    feature, you might add a nodes creation event listener to your application.</p>
    
    <p><b>Usage Example:</b></p>
    <pre class="java">
    <font id="FormalComment">// getting the p2p virtual node</font>
    VirtualNode vn = pad.getVirtualNode("p2pvn");
    <font id="FormalComment">// adding "this" as a listener</font>
    ((VirtualNodeImpl) vn).addNodeCreationEventListener(<b class="java">this</b>);
    <font id="FormalComment">// then activate the virtual node</font>
    vn.activate();
    </pre>
    <p>"this" has to implement the NodeCreationEventListener interface:</p>
    <pre class="java">
	<b class="java">public void</b> nodeCreated(NodeCreationEvent event) {
		<font id="FormalComment">// get the node</font>
 		Node newNode = event.getNode();
		<font id="FormalComment">// now you can create an active object on your node.</font>
	}
    </pre>
      </td>

    </tr>

  </tbody>
</table>
<table border="1" width="100%">

  <tbody>

    <tr>

      <th>Branch and Bound API</th>

    </tr>

    <tr>

      <td>
      <p class="textNormal">Firstly, create your own task:</p>
<pre class="java">
<b class="java">import</b> org.objectweb.proactive.branchnbound.core.Task;
<b class="java">public class</b> YourTask <b class="java">extends</b> Task {
  
  <b class="java">public</b> Result execute() {
    <font id="FormalComment">// Your code here for computing a solution</font>
  }

  <b class="java">public</b> Vector split() {
    <font id="FormalComment">// Your code for generating sub-tasks</font>
  }

  <b class="java">public Result</b> gather(Result[] results) {
  	<font id="FormalComment">// Override optional</font>
  	<font id="FormalComment">// Default behavior based on the smallest gave by the compareTo</font>
  }

  <b class="java">public void</b> initLowerBound() {
  	<font id="FormalComment">// Your code here for computing a lower bound</font>
  }

  <b class="java">public void</b> initUpperBound() {
    <font id="FormalComment">// Your code here for computing a lower bound</font>
  }

  <b class="java">public int</b> compareTo(Object arg) {
	<font id="FormalComment">// Strongly recommended to override this method</font>
	<font id="FormalComment">// with your behavior</font>
  }
}
</pre>
      <p class="textNormal">How to interact with the framework from inside a task:</p>
<ul>
	<li>Some class variables:
<pre class="java">
<b class="java">protected</b> Result initLowerBound; <font id="FormalComment">// to store your lower bound</font>
<b class="java">protected</b> Result initUpperBound; <font id="FormalComment">// to store you upper bound</font>
<b class="java">protected</b> Object bestKnownSolution; <font id="FormalComment">// set by the framework with the best current solution</font>
<b class="java">protected</b> Worker worker; <font id="FormalComment">// to interact with the framework (see below)</font>
</pre>
</li>
	<li>Interact with the framework (inside a Task):
<pre class="java">
<b class="java">this</b>.worker.setBestCurrentResult(newBestSolution); <font id="FormalComment">// the worker will broadcast the solution in all Tasks</font>
<b class="java">this</b>.worker.sendSubTasksToTheManager(subTaskList); <font id="FormalComment">// send a set of sub-tasks for computation to the framework</font>
BooleanWrapper workersAvailable = <b class="java">this</b>.worker.isHungry(); <font id="FormalComment">// for a smart split, check for free workers</font>
</pre>	
	</li>
</ul>
      <p class="textNormal">Secondly, choose your task queue:</p>
      <ul>
      	<li>BasicQueueImpl: execute task in FIFO order.</li>
      	<li>LargerQueueIml: execute task in larger order.</li>
      	<li>Extend TaskQueue: your own one.</li>
      </ul>

      <p class="textNormal">Finally, start the compution:</p>
<pre class="java">
Task task = <b class="java">new</b> YourTask(someArguments);

Manager manager =  ProActiveBranchNBound.newBnB(task,
                        nodes,
                        LargerQueueImpl.class.getName());

Result futureResult = manager.start(); <font id="FormalComment">// this call is asynchronous</font>
...
</pre>
      <p class="textNormal">Keep in mind that is only "initLower/UpperBound" and
      "split" methods are called on the root task. The "execute" method is called
      on the root task's splitted task. Here the methods order execution:</p>
      <ol>
      	<li class="java">rootTask.initLowerBound(); <font id="FormalComment">// compute a first lower bound</font></li>
      	<li class="java">rootTask.initUpperBound(); <font id="FormalComment">// compute a first upper bound</font></li>
      	<li class="java">Task splitted = rootTask.split(); <font id="FormalComment">// generate a set of tasks</font></li>
      	<li class="java"><b class="java">for</b> i <b class="java">in</b> splitted <b class="java">do in parallel</b>
<pre class="java">splitted[i].initLowerBound();
splitted[i].initUpperBound();
Result ri = splitted.execute();
</pre></li>
		<li class="java">Result final = rootTask.gather(Result[] ri); <font id="FormalComment">// gathering all result</font></li>
      </ol>

      </td>

    </tr>

  </tbody>
</table>
<table border="1" width="100%">

  <tbody>

    <tr>

      <th>File Transfer Deployment</th>

    </tr>

    <tr>

      <td>
<pre class="xml">
<p> File Transfer Deployment is a tool for transfering files at deployment time. This files are specified using the ProActive XML Deployment Descriptor in the following way:</p>
&lt;VirtualNode name="exampleVNode" <b>FileTransferDeploy</b>="<b>example</b>"/&gt;
....
&lt;/deployment&gt;
&lt;<b>FileTransferDefinitions</b>&gt;
   &lt;<b>FileTransfer</b> id="<b>example</b>"&gt;
      &lt;<b>file</b> src="hello.dat" dest="world.dat"/&gt;
      &lt;<b>dir</b> src="exampledir" dest="exampledir"/&gt;
  &lt;/<b>FileTransfer</b>&gt;
  ...
&lt;/<b>FileTransferDefinitions</b>&gt;
&lt;infrastructure&gt;
....
&lt;processDefinition id="xyz"&gt;
  &lt;sshProcess&gt;...
    &lt;<b>FileTransferDeploy</b>="<b>implicit</b>"&gt; <FONT ID="FormalComment">&lt;!-- referenceID or keyword "implicit" (inherit)--&gt;</FONT>
      &lt;<b>copyProtocol</b>&gt;processDefault, scp, rcp&lt;/<b>copyProtocol</b>&gt;
      &lt;<b>sourceInfo</b> prefix="/home/user"/&gt;
      &lt;<b>destinationInfo</b> prefix="/tmp" hostname="foo.org" username="smith" /&gt;
    &lt;/<b>FileTransferDeploy</b>&gt;
  &lt;/sshProcess&gt;
&lt;/processDefinition&gt;
...
</pre>
      </td>
    </tr>

  </tbody>
</table>
<br></br>

<p></p>





<!--
<!--
 Footer : start 

<br>
<hr>
<div class="textSmall" align="right">Copyright &copy;  2001-2005
INRIA All Rights Reserved.</div>
<!-- Footer : end -->
</body>
</html>
